"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-resizable-panels";
exports.ids = ["vendor-chunks/react-resizable-panels"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   PanelGroup: () => (/* binding */ PanelGroup),\n/* harmony export */   PanelResizeHandle: () => (/* binding */ PanelResizeHandle),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   getIntersectingRectangle: () => (/* binding */ getIntersectingRectangle),\n/* harmony export */   getPanelElement: () => (/* binding */ getPanelElement),\n/* harmony export */   getPanelElementsForGroup: () => (/* binding */ getPanelElementsForGroup),\n/* harmony export */   getPanelGroupElement: () => (/* binding */ getPanelGroupElement),\n/* harmony export */   getResizeHandleElement: () => (/* binding */ getResizeHandleElement),\n/* harmony export */   getResizeHandleElementIndex: () => (/* binding */ getResizeHandleElementIndex),\n/* harmony export */   getResizeHandleElementsForGroup: () => (/* binding */ getResizeHandleElementsForGroup),\n/* harmony export */   getResizeHandlePanelIds: () => (/* binding */ getResizeHandlePanelIds),\n/* harmony export */   intersects: () => (/* binding */ intersects)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n// eslint-disable-next-line no-restricted-imports\nconst { createElement, createContext, createRef, forwardRef, useCallback, useContext, useEffect, useImperativeHandle, useLayoutEffect, useMemo, useRef, useState } = react__WEBPACK_IMPORTED_MODULE_0__;\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = react__WEBPACK_IMPORTED_MODULE_0__[\"useId\".toString()];\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\nconst wrappedUseId = typeof useId === \"function\" ? useId : ()=>null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n    const idFromUseId = wrappedUseId();\n    const idRef = useRef(idFromParams || idFromUseId || null);\n    if (idRef.current === null) {\n        idRef.current = \"\" + counter++;\n    }\n    return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\nfunction PanelWithForwardedRef({ children, className: classNameFromProps = \"\", collapsedSize, collapsible, defaultSize, forwardedRef, id: idFromProps, maxSize, minSize, onCollapse, onExpand, onResize, order, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const context = useContext(PanelGroupContext);\n    if (context === null) {\n        throw Error(`Panel components must be rendered within a PanelGroup container`);\n    }\n    const { collapsePanel, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, reevaluatePanelConstraints, registerPanel, resizePanel, unregisterPanel } = context;\n    const panelId = useUniqueId(idFromProps);\n    const panelDataRef = useRef({\n        callbacks: {\n            onCollapse,\n            onExpand,\n            onResize\n        },\n        constraints: {\n            collapsedSize,\n            collapsible,\n            defaultSize,\n            maxSize,\n            minSize\n        },\n        id: panelId,\n        idIsFromProps: idFromProps !== undefined,\n        order\n    });\n    const devWarningsRef = useRef({\n        didLogMissingDefaultSizeWarning: false\n    });\n    // Normally we wouldn't log a warning during render,\n    // but effects don't run on the server, so we can't do it there\n    {\n        if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) {\n            if (defaultSize == null) {\n                devWarningsRef.current.didLogMissingDefaultSizeWarning = true;\n                console.warn(`WARNING: Panel defaultSize prop recommended to avoid layout shift after server rendering`);\n            }\n        }\n    }\n    useImperativeHandle(forwardedRef, ()=>({\n            collapse: ()=>{\n                collapsePanel(panelDataRef.current);\n            },\n            expand: ()=>{\n                expandPanel(panelDataRef.current);\n            },\n            getId () {\n                return panelId;\n            },\n            getSize () {\n                return getPanelSize(panelDataRef.current);\n            },\n            isCollapsed () {\n                return isPanelCollapsed(panelDataRef.current);\n            },\n            isExpanded () {\n                return !isPanelCollapsed(panelDataRef.current);\n            },\n            resize: (size)=>{\n                resizePanel(panelDataRef.current, size);\n            }\n        }), [\n        collapsePanel,\n        expandPanel,\n        getPanelSize,\n        isPanelCollapsed,\n        panelId,\n        resizePanel\n    ]);\n    const style = getPanelStyle(panelDataRef.current, defaultSize);\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        id: idFromProps,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        // CSS selectors\n        \"data-panel\": \"\",\n        \"data-panel-collapsible\": collapsible || undefined,\n        \"data-panel-group-id\": groupId,\n        \"data-panel-id\": panelId,\n        \"data-panel-size\": parseFloat(\"\" + style.flexGrow).toFixed(1)\n    });\n}\nconst Panel = forwardRef((props, ref)=>createElement(PanelWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\nlet currentCursorStyle = null;\nlet styleElement = null;\nfunction getCursorStyle(state, constraintFlags) {\n    if (constraintFlags) {\n        const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n        const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n        const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n        const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n        if (horizontalMin) {\n            if (verticalMin) {\n                return \"se-resize\";\n            } else if (verticalMax) {\n                return \"ne-resize\";\n            } else {\n                return \"e-resize\";\n            }\n        } else if (horizontalMax) {\n            if (verticalMin) {\n                return \"sw-resize\";\n            } else if (verticalMax) {\n                return \"nw-resize\";\n            } else {\n                return \"w-resize\";\n            }\n        } else if (verticalMin) {\n            return \"s-resize\";\n        } else if (verticalMax) {\n            return \"n-resize\";\n        }\n    }\n    switch(state){\n        case \"horizontal\":\n            return \"ew-resize\";\n        case \"intersection\":\n            return \"move\";\n        case \"vertical\":\n            return \"ns-resize\";\n    }\n}\nfunction resetGlobalCursorStyle() {\n    if (styleElement !== null) {\n        document.head.removeChild(styleElement);\n        currentCursorStyle = null;\n        styleElement = null;\n    }\n}\nfunction setGlobalCursorStyle(state, constraintFlags) {\n    const style = getCursorStyle(state, constraintFlags);\n    if (currentCursorStyle === style) {\n        return;\n    }\n    currentCursorStyle = style;\n    if (styleElement === null) {\n        styleElement = document.createElement(\"style\");\n        document.head.appendChild(styleElement);\n    }\n    styleElement.innerHTML = `*{cursor: ${style}!important;}`;\n}\nfunction isKeyDown(event) {\n    return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n    return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n    return event.type.startsWith(\"touch\");\n}\nfunction getResizeEventCoordinates(event) {\n    if (isMouseEvent(event)) {\n        return {\n            x: event.clientX,\n            y: event.clientY\n        };\n    } else if (isTouchEvent(event)) {\n        const touch = event.touches[0];\n        if (touch && touch.clientX && touch.clientY) {\n            return {\n                x: touch.clientX,\n                y: touch.clientY\n            };\n        }\n    }\n    return {\n        x: Infinity,\n        y: Infinity\n    };\n}\nfunction getInputType() {\n    if (typeof matchMedia === \"function\") {\n        return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n    }\n}\nfunction intersects(rectOne, rectTwo, strict) {\n    if (strict) {\n        return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n    } else {\n        return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n    }\n}\n// Forked from NPM stacking-order@2.0.0\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n */ function compare(a, b) {\n    if (a === b) throw new Error(\"Cannot compare node with itself\");\n    const ancestors = {\n        a: get_ancestors(a),\n        b: get_ancestors(b)\n    };\n    let common_ancestor;\n    // remove shared ancestors\n    while(ancestors.a.at(-1) === ancestors.b.at(-1)){\n        a = ancestors.a.pop();\n        b = ancestors.b.pop();\n        common_ancestor = a;\n    }\n    assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n    const z_indexes = {\n        a: get_z_index(find_stacking_context(ancestors.a)),\n        b: get_z_index(find_stacking_context(ancestors.b))\n    };\n    if (z_indexes.a === z_indexes.b) {\n        const children = common_ancestor.childNodes;\n        const furthest_ancestors = {\n            a: ancestors.a.at(-1),\n            b: ancestors.b.at(-1)\n        };\n        let i = children.length;\n        while(i--){\n            const child = children[i];\n            if (child === furthest_ancestors.a) return 1;\n            if (child === furthest_ancestors.b) return -1;\n        }\n    }\n    return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n/** @param {HTMLElement} node */ function is_flex_item(node) {\n    const display = getComputedStyle(get_parent(node)).display;\n    return display === \"flex\" || display === \"inline-flex\";\n}\n/** @param {HTMLElement} node */ function creates_stacking_context(node) {\n    const style = getComputedStyle(node);\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n    if (style.position === \"fixed\") return true;\n    // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n    // if (\n    //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n    //   is_flex_item(node)\n    // )\n    if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n    if (+style.opacity < 1) return true;\n    if (\"transform\" in style && style.transform !== \"none\") return true;\n    if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n    if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n    if (\"filter\" in style && style.filter !== \"none\") return true;\n    if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n    if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n    if (props.test(style.willChange)) return true;\n    // @ts-expect-error\n    if (style.webkitOverflowScrolling === \"touch\") return true;\n    return false;\n}\n/** @param {HTMLElement[]} nodes */ function find_stacking_context(nodes) {\n    let i = nodes.length;\n    while(i--){\n        const node = nodes[i];\n        assert(node, \"Missing node\");\n        if (creates_stacking_context(node)) return node;\n    }\n    return null;\n}\n/** @param {HTMLElement} node */ function get_z_index(node) {\n    return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n/** @param {HTMLElement} node */ function get_ancestors(node) {\n    const ancestors = [];\n    while(node){\n        ancestors.push(node);\n        node = get_parent(node);\n    }\n    return ancestors; // [ node, ... <body>, <html>, document ]\n}\n/** @param {HTMLElement} node */ function get_parent(node) {\n    var _node$parentNode;\n    // @ts-ignore\n    return ((_node$parentNode = node.parentNode) === null || _node$parentNode === void 0 ? void 0 : _node$parentNode.host) || node.parentNode;\n}\nconst EXCEEDED_HORIZONTAL_MIN = 1;\nconst EXCEEDED_HORIZONTAL_MAX = 2;\nconst EXCEEDED_VERTICAL_MIN = 4;\nconst EXCEEDED_VERTICAL_MAX = 8;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n    var _ownerDocumentCounts$;\n    const { ownerDocument } = element;\n    const data = {\n        direction,\n        element,\n        hitAreaMargins,\n        setResizeHandlerState\n    };\n    const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n    ownerDocumentCounts.set(ownerDocument, count + 1);\n    registeredResizeHandlers.add(data);\n    updateListeners();\n    return function unregisterResizeHandle() {\n        var _ownerDocumentCounts$2;\n        panelConstraintFlags.delete(resizeHandleId);\n        registeredResizeHandlers.delete(data);\n        const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n        ownerDocumentCounts.set(ownerDocument, count - 1);\n        updateListeners();\n        if (count === 1) {\n            ownerDocumentCounts.delete(ownerDocument);\n        }\n    };\n}\nfunction handlePointerDown(event) {\n    const { target } = event;\n    const { x, y } = getResizeEventCoordinates(event);\n    isPointerDown = true;\n    recalculateIntersectingHandles({\n        target,\n        x,\n        y\n    });\n    updateListeners();\n    if (intersectingHandles.length > 0) {\n        updateResizeHandlerStates(\"down\", event);\n        event.preventDefault();\n    }\n}\nfunction handlePointerMove(event) {\n    const { x, y } = getResizeEventCoordinates(event);\n    if (!isPointerDown) {\n        const { target } = event;\n        // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n        // at that point, the handles may not move with the pointer (depending on constraints)\n        // but the same set of active handles should be locked until the pointer is released\n        recalculateIntersectingHandles({\n            target,\n            x,\n            y\n        });\n    }\n    updateResizeHandlerStates(\"move\", event);\n    // Update cursor based on return value(s) from active handles\n    updateCursor();\n    if (intersectingHandles.length > 0) {\n        event.preventDefault();\n    }\n}\nfunction handlePointerUp(event) {\n    const { target } = event;\n    const { x, y } = getResizeEventCoordinates(event);\n    panelConstraintFlags.clear();\n    isPointerDown = false;\n    if (intersectingHandles.length > 0) {\n        event.preventDefault();\n    }\n    updateResizeHandlerStates(\"up\", event);\n    recalculateIntersectingHandles({\n        target,\n        x,\n        y\n    });\n    updateCursor();\n    updateListeners();\n}\nfunction recalculateIntersectingHandles({ target, x, y }) {\n    intersectingHandles.splice(0);\n    let targetElement = null;\n    if (target instanceof HTMLElement) {\n        targetElement = target;\n    }\n    registeredResizeHandlers.forEach((data)=>{\n        const { element: dragHandleElement, hitAreaMargins } = data;\n        const dragHandleRect = dragHandleElement.getBoundingClientRect();\n        const { bottom, left, right, top } = dragHandleRect;\n        const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n        const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n        if (eventIntersects) {\n            // TRICKY\n            // We listen for pointers events at the root in order to support hit area margins\n            // (determining when the pointer is close enough to an element to be considered a \"hit\")\n            // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n            // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n            // and the element that was actually clicked/touched\n            if (targetElement !== null && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible\n            // That is why we only check potentially intersecting handles,\n            // and why we skip if the event target is within the handle's DOM\n            compare(targetElement, dragHandleElement) > 0) {\n                // If the target is above the drag handle, then we also need to confirm they overlap\n                // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n                //\n                // It's not enough to compare only the target\n                // The target might be a small element inside of a larger container\n                // (For example, a SPAN or a DIV inside of a larger modal dialog)\n                let currentElement = targetElement;\n                let didIntersect = false;\n                while(currentElement){\n                    if (currentElement.contains(dragHandleElement)) {\n                        break;\n                    } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n                        didIntersect = true;\n                        break;\n                    }\n                    currentElement = currentElement.parentElement;\n                }\n                if (didIntersect) {\n                    return;\n                }\n            }\n            intersectingHandles.push(data);\n        }\n    });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n    panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n    let intersectsHorizontal = false;\n    let intersectsVertical = false;\n    intersectingHandles.forEach((data)=>{\n        const { direction } = data;\n        if (direction === \"horizontal\") {\n            intersectsHorizontal = true;\n        } else {\n            intersectsVertical = true;\n        }\n    });\n    let constraintFlags = 0;\n    panelConstraintFlags.forEach((flag)=>{\n        constraintFlags |= flag;\n    });\n    if (intersectsHorizontal && intersectsVertical) {\n        setGlobalCursorStyle(\"intersection\", constraintFlags);\n    } else if (intersectsHorizontal) {\n        setGlobalCursorStyle(\"horizontal\", constraintFlags);\n    } else if (intersectsVertical) {\n        setGlobalCursorStyle(\"vertical\", constraintFlags);\n    } else {\n        resetGlobalCursorStyle();\n    }\n}\nfunction updateListeners() {\n    ownerDocumentCounts.forEach((_, ownerDocument)=>{\n        const { body } = ownerDocument;\n        body.removeEventListener(\"contextmenu\", handlePointerUp);\n        body.removeEventListener(\"mousedown\", handlePointerDown);\n        body.removeEventListener(\"mouseleave\", handlePointerMove);\n        body.removeEventListener(\"mousemove\", handlePointerMove);\n        body.removeEventListener(\"touchmove\", handlePointerMove);\n        body.removeEventListener(\"touchstart\", handlePointerDown);\n    });\n    window.removeEventListener(\"mouseup\", handlePointerUp);\n    window.removeEventListener(\"touchcancel\", handlePointerUp);\n    window.removeEventListener(\"touchend\", handlePointerUp);\n    if (registeredResizeHandlers.size > 0) {\n        if (isPointerDown) {\n            if (intersectingHandles.length > 0) {\n                ownerDocumentCounts.forEach((count, ownerDocument)=>{\n                    const { body } = ownerDocument;\n                    if (count > 0) {\n                        body.addEventListener(\"contextmenu\", handlePointerUp);\n                        body.addEventListener(\"mouseleave\", handlePointerMove);\n                        body.addEventListener(\"mousemove\", handlePointerMove);\n                        body.addEventListener(\"touchmove\", handlePointerMove, {\n                            passive: false\n                        });\n                    }\n                });\n            }\n            window.addEventListener(\"mouseup\", handlePointerUp);\n            window.addEventListener(\"touchcancel\", handlePointerUp);\n            window.addEventListener(\"touchend\", handlePointerUp);\n        } else {\n            ownerDocumentCounts.forEach((count, ownerDocument)=>{\n                const { body } = ownerDocument;\n                if (count > 0) {\n                    body.addEventListener(\"mousedown\", handlePointerDown);\n                    body.addEventListener(\"mousemove\", handlePointerMove);\n                    body.addEventListener(\"touchmove\", handlePointerMove, {\n                        passive: false\n                    });\n                    body.addEventListener(\"touchstart\", handlePointerDown);\n                }\n            });\n        }\n    }\n}\nfunction updateResizeHandlerStates(action, event) {\n    registeredResizeHandlers.forEach((data)=>{\n        const { setResizeHandlerState } = data;\n        const isActive = intersectingHandles.includes(data);\n        setResizeHandlerState(action, isActive, event);\n    });\n}\nfunction assert(expectedCondition, message) {\n    if (!expectedCondition) {\n        console.error(message);\n        throw Error(message);\n    }\n}\nconst PRECISION = 10;\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n    actual = parseFloat(actual.toFixed(fractionDigits));\n    expected = parseFloat(expected.toFixed(fractionDigits));\n    const delta = actual - expected;\n    if (delta === 0) {\n        return 0;\n    } else {\n        return delta > 0 ? 1 : -1;\n    }\n}\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n    return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n    if (actual.length !== expected.length) {\n        return false;\n    }\n    for(let index = 0; index < actual.length; index++){\n        const actualSize = actual[index];\n        const expectedSize = expected[index];\n        if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({ panelConstraints: panelConstraintsArray, panelIndex, size }) {\n    const panelConstraints = panelConstraintsArray[panelIndex];\n    assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n    let { collapsedSize = 0, collapsible, maxSize = 100, minSize = 0 } = panelConstraints;\n    if (fuzzyCompareNumbers(size, minSize) < 0) {\n        if (collapsible) {\n            // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n            const halfwayPoint = (collapsedSize + minSize) / 2;\n            if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n                size = collapsedSize;\n            } else {\n                size = minSize;\n            }\n        } else {\n            size = minSize;\n        }\n    }\n    size = Math.min(maxSize, size);\n    size = parseFloat(size.toFixed(PRECISION));\n    return size;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({ delta, initialLayout, panelConstraints: panelConstraintsArray, pivotIndices, prevLayout, trigger }) {\n    if (fuzzyNumbersEqual(delta, 0)) {\n        return initialLayout;\n    }\n    const nextLayout = [\n        ...initialLayout\n    ];\n    const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n    assert(firstPivotIndex != null, \"Invalid first pivot index\");\n    assert(secondPivotIndex != null, \"Invalid second pivot index\");\n    let deltaApplied = 0;\n    // const DEBUG = [];\n    // DEBUG.push(`adjustLayoutByDelta()`);\n    // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n    // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n    // DEBUG.push(`  delta: ${delta}`);\n    // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n    // DEBUG.push(`  trigger: ${trigger}`);\n    // DEBUG.push(\"\");\n    // A resizing panel affects the panels before or after it.\n    //\n    // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n    // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n    //\n    // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n    // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n    {\n        // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n        // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n        if (trigger === \"keyboard\") {\n            {\n                // Check if we should expand a collapsed panel\n                const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints, `Panel constraints not found for index ${index}`);\n                const { collapsedSize = 0, collapsible, minSize = 0 } = panelConstraints;\n                // DEBUG.push(`edge case check 1: ${index}`);\n                // DEBUG.push(`  -> collapsible? ${collapsible}`);\n                if (collapsible) {\n                    const prevSize = initialLayout[index];\n                    assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n                    if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n                        const localDelta = minSize - prevSize;\n                        // DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        // DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n            {\n                // Check if we should collapse a panel at its minimum size\n                const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n                const panelConstraints = panelConstraintsArray[index];\n                assert(panelConstraints, `No panel constraints found for index ${index}`);\n                const { collapsedSize = 0, collapsible, minSize = 0 } = panelConstraints;\n                // DEBUG.push(`edge case check 2: ${index}`);\n                // DEBUG.push(`  -> collapsible? ${collapsible}`);\n                if (collapsible) {\n                    const prevSize = initialLayout[index];\n                    assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n                    if (fuzzyNumbersEqual(prevSize, minSize)) {\n                        const localDelta = prevSize - collapsedSize;\n                        // DEBUG.push(`  -> expand delta: ${localDelta}`);\n                        if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n                            delta = delta < 0 ? 0 - localDelta : localDelta;\n                        // DEBUG.push(`  -> delta: ${delta}`);\n                        }\n                    }\n                }\n            }\n        }\n    // DEBUG.push(\"\");\n    }\n    {\n        // Pre-calculate max available delta in the opposite direction of our pivot.\n        // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n        // If this amount is less than the requested delta, adjust the requested delta.\n        // If this amount is greater than the requested delta, that's useful information too–\n        // as an expanding panel might change from collapsed to min size.\n        const increment = delta < 0 ? 1 : -1;\n        let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        let maxAvailableDelta = 0;\n        // DEBUG.push(\"pre calc...\");\n        while(true){\n            const prevSize = initialLayout[index];\n            assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n            const maxSafeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: 100\n            });\n            const delta = maxSafeSize - prevSize;\n            // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n            maxAvailableDelta += delta;\n            index += increment;\n            if (index < 0 || index >= panelConstraintsArray.length) {\n                break;\n            }\n        }\n        // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n        const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n        delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n    }\n    {\n        // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n        const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        let index = pivotIndex;\n        while(index >= 0 && index < panelConstraintsArray.length){\n            const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n            const prevSize = initialLayout[index];\n            assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n            const unsafeSize = prevSize - deltaRemaining;\n            const safeSize = resizePanel({\n                panelConstraints: panelConstraintsArray,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                deltaApplied += prevSize - safeSize;\n                nextLayout[index] = safeSize;\n                if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n                    numeric: true\n                }) >= 0) {\n                    break;\n                }\n            }\n            if (delta < 0) {\n                index--;\n            } else {\n                index++;\n            }\n        }\n    }\n    // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n    // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    // DEBUG.push(\"\");\n    // If we were unable to resize any of the panels panels, return the previous state.\n    // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n    if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n        // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n        // console.log(DEBUG.join(\"\\n\"));\n        return prevLayout;\n    }\n    {\n        // Now distribute the applied delta to the panels in the other direction\n        const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const prevSize = initialLayout[pivotIndex];\n        assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n        const unsafeSize = prevSize + deltaApplied;\n        const safeSize = resizePanel({\n            panelConstraints: panelConstraintsArray,\n            panelIndex: pivotIndex,\n            size: unsafeSize\n        });\n        // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n        nextLayout[pivotIndex] = safeSize;\n        // Edge case where expanding or contracting one panel caused another one to change collapsed state\n        if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n            let deltaRemaining = unsafeSize - safeSize;\n            const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n            let index = pivotIndex;\n            while(index >= 0 && index < panelConstraintsArray.length){\n                const prevSize = nextLayout[index];\n                assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n                const unsafeSize = prevSize + deltaRemaining;\n                const safeSize = resizePanel({\n                    panelConstraints: panelConstraintsArray,\n                    panelIndex: index,\n                    size: unsafeSize\n                });\n                if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n                    deltaRemaining -= safeSize - prevSize;\n                    nextLayout[index] = safeSize;\n                }\n                if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n                    break;\n                }\n                if (delta > 0) {\n                    index--;\n                } else {\n                    index++;\n                }\n            }\n        }\n    }\n    // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n    // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n    // DEBUG.push(\"\");\n    const totalSize = nextLayout.reduce((total, size)=>size + total, 0);\n    // DEBUG.push(`total size: ${totalSize}`);\n    // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n    // In that case, fall back to our most recent valid layout\n    if (!fuzzyNumbersEqual(totalSize, 100)) {\n        // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n        // console.log(DEBUG.join(\"\\n\"));\n        return prevLayout;\n    }\n    // console.log(DEBUG.join(\"\\n\"));\n    return nextLayout;\n}\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n    return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n    const handles = getResizeHandleElementsForGroup(groupId, scope);\n    const index = handles.findIndex((handle)=>handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n    return index !== null && index !== void 0 ? index : null;\n}\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n    const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n    return index != null ? [\n        index,\n        index + 1\n    ] : [\n        -1,\n        -1\n    ];\n}\nfunction getPanelGroupElement(id, rootElement = document) {\n    var _dataset;\n    //If the root element is the PanelGroup\n    if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\n        return rootElement;\n    }\n    //Else query children\n    const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandleElement(id, scope = document) {\n    const element = scope.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n    var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n    const handle = getResizeHandleElement(handleId, scope);\n    const handles = getResizeHandleElementsForGroup(groupId, scope);\n    const index = handle ? handles.indexOf(handle) : -1;\n    const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n    const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n    return [\n        idBefore,\n        idAfter\n    ];\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterPanelGroupBehavior({ committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, panelGroupElement, setLayout }) {\n    useRef({\n        didWarnAboutMissingResizeHandle: false\n    });\n    useEffect(()=>{\n        if (!panelGroupElement) {\n            return;\n        }\n        const eagerValues = eagerValuesRef.current;\n        assert(eagerValues, `Eager values not found`);\n        const { panelDataArray } = eagerValues;\n        const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n        assert(groupElement != null, `No group found for id \"${groupId}\"`);\n        const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n        assert(handles, `No resize handles found for group id \"${groupId}\"`);\n        const cleanupFunctions = handles.map((handle)=>{\n            const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n            assert(handleId, `Resize handle element has no handle id attribute`);\n            const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n            if (idBefore == null || idAfter == null) {\n                return ()=>{};\n            }\n            const onKeyDown = (event)=>{\n                if (event.defaultPrevented) {\n                    return;\n                }\n                switch(event.key){\n                    case \"Enter\":\n                        {\n                            event.preventDefault();\n                            const index = panelDataArray.findIndex((panelData)=>panelData.id === idBefore);\n                            if (index >= 0) {\n                                const panelData = panelDataArray[index];\n                                assert(panelData, `No panel data found for index ${index}`);\n                                const size = layout[index];\n                                const { collapsedSize = 0, collapsible, minSize = 0 } = panelData.constraints;\n                                if (size != null && collapsible) {\n                                    const nextLayout = adjustLayoutByDelta({\n                                        delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                                        initialLayout: layout,\n                                        panelConstraints: panelDataArray.map((panelData)=>panelData.constraints),\n                                        pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                                        prevLayout: layout,\n                                        trigger: \"keyboard\"\n                                    });\n                                    if (layout !== nextLayout) {\n                                        setLayout(nextLayout);\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                }\n            };\n            handle.addEventListener(\"keydown\", onKeyDown);\n            return ()=>{\n                handle.removeEventListener(\"keydown\", onKeyDown);\n            };\n        });\n        return ()=>{\n            cleanupFunctions.forEach((cleanupFunction)=>cleanupFunction());\n        };\n    }, [\n        panelGroupElement,\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray,\n        setLayout\n    ]);\n}\nfunction areEqual(arrayA, arrayB) {\n    if (arrayA.length !== arrayB.length) {\n        return false;\n    }\n    for(let index = 0; index < arrayA.length; index++){\n        if (arrayA[index] !== arrayB[index]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getResizeEventCursorPosition(direction, event) {\n    const isHorizontal = direction === \"horizontal\";\n    const { x, y } = getResizeEventCoordinates(event);\n    return isHorizontal ? x : y;\n}\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n    const isHorizontal = direction === \"horizontal\";\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n    assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n    const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n    assert(groupId, `Resize handle element has no group id attribute`);\n    let { initialCursorPosition } = initialDragState;\n    const cursorPosition = getResizeEventCursorPosition(direction, event);\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement, `No group element found for id \"${groupId}\"`);\n    const groupRect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n    const offsetPixels = cursorPosition - initialCursorPosition;\n    const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n    return offsetPercentage;\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n    if (isKeyDown(event)) {\n        const isHorizontal = direction === \"horizontal\";\n        let delta = 0;\n        if (event.shiftKey) {\n            delta = 100;\n        } else if (keyboardResizeBy != null) {\n            delta = keyboardResizeBy;\n        } else {\n            delta = 10;\n        }\n        let movement = 0;\n        switch(event.key){\n            case \"ArrowDown\":\n                movement = isHorizontal ? 0 : delta;\n                break;\n            case \"ArrowLeft\":\n                movement = isHorizontal ? -delta : 0;\n                break;\n            case \"ArrowRight\":\n                movement = isHorizontal ? delta : 0;\n                break;\n            case \"ArrowUp\":\n                movement = isHorizontal ? 0 : -delta;\n                break;\n            case \"End\":\n                movement = 100;\n                break;\n            case \"Home\":\n                movement = -100;\n                break;\n        }\n        return movement;\n    } else {\n        if (initialDragState == null) {\n            return 0;\n        }\n        return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n    }\n}\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n    layout.forEach((size, index)=>{\n        const panelData = panelsArray[index];\n        assert(panelData, `Panel data not found for index ${index}`);\n        const { callbacks, constraints, id: panelId } = panelData;\n        const { collapsedSize = 0, collapsible } = constraints;\n        const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n        if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n            panelIdToLastNotifiedSizeMap[panelId] = size;\n            const { onCollapse, onExpand, onResize } = callbacks;\n            if (onResize) {\n                onResize(size, lastNotifiedSize);\n            }\n            if (collapsible && (onCollapse || onExpand)) {\n                if (onExpand && (lastNotifiedSize == null || lastNotifiedSize === collapsedSize) && size !== collapsedSize) {\n                    onExpand();\n                }\n                if (onCollapse && (lastNotifiedSize == null || lastNotifiedSize !== collapsedSize) && size === collapsedSize) {\n                    onCollapse();\n                }\n            }\n        }\n    });\n}\nfunction compareLayouts(a, b) {\n    if (a.length !== b.length) {\n        return false;\n    } else {\n        for(let index = 0; index < a.length; index++){\n            if (a[index] != b[index]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// This method returns a number between 1 and 100 representing\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({ defaultSize, dragState, layout, panelData, panelIndex, precision = 3 }) {\n    const size = layout[panelIndex];\n    let flexGrow;\n    if (size == null) {\n        // Initial render (before panels have registered themselves)\n        // In order to support server rendering, fall back to default size if provided\n        flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\n    } else if (panelData.length === 1) {\n        // Special case: Single panel group should always fill full width/height\n        flexGrow = \"1\";\n    } else {\n        flexGrow = size.toPrecision(precision);\n    }\n    return {\n        flexBasis: 0,\n        flexGrow,\n        flexShrink: 1,\n        // Without this, Panel sizes may be unintentionally overridden by their content\n        overflow: \"hidden\",\n        // Disable pointer events inside of a panel during resize\n        // This avoid edge cases like nested iframes\n        pointerEvents: dragState !== null ? \"none\" : undefined\n    };\n}\nfunction debounce(callback, durationMs = 10) {\n    let timeoutId = null;\n    let callable = (...args)=>{\n        if (timeoutId !== null) {\n            clearTimeout(timeoutId);\n        }\n        timeoutId = setTimeout(()=>{\n            callback(...args);\n        }, durationMs);\n    };\n    return callable;\n}\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n    try {\n        if (typeof localStorage !== \"undefined\") {\n            // Bypass this check for future calls\n            storageObject.getItem = (name)=>{\n                return localStorage.getItem(name);\n            };\n            storageObject.setItem = (name, value)=>{\n                localStorage.setItem(name, value);\n            };\n        } else {\n            throw new Error(\"localStorage not supported in this environment\");\n        }\n    } catch (error) {\n        console.error(error);\n        storageObject.getItem = ()=>null;\n        storageObject.setItem = ()=>{};\n    }\n}\nfunction getPanelGroupKey(autoSaveId) {\n    return `react-resizable-panels:${autoSaveId}`;\n}\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n    return panels.map((panel)=>{\n        const { constraints, id, idIsFromProps, order } = panel;\n        if (idIsFromProps) {\n            return id;\n        } else {\n            return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n        }\n    }).sort((a, b)=>a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n    try {\n        const panelGroupKey = getPanelGroupKey(autoSaveId);\n        const serialized = storage.getItem(panelGroupKey);\n        if (serialized) {\n            const parsed = JSON.parse(serialized);\n            if (typeof parsed === \"object\" && parsed != null) {\n                return parsed;\n            }\n        }\n    } catch (error) {}\n    return null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n    var _loadSerializedPanelG2;\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const panelKey = getPanelKey(panels);\n    const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n    state[panelKey] = {\n        expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n        layout: sizes\n    };\n    try {\n        storage.setItem(panelGroupKey, JSON.stringify(state));\n    } catch (error) {\n        console.error(error);\n    }\n}\nfunction validatePanelConstraints({ panelConstraints: panelConstraintsArray, panelId, panelIndex }) {\n    {\n        const warnings = [];\n        const panelConstraints = panelConstraintsArray[panelIndex];\n        assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);\n        const { collapsedSize = 0, collapsible = false, defaultSize, maxSize = 100, minSize = 0 } = panelConstraints;\n        if (minSize > maxSize) {\n            warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\n        }\n        if (defaultSize != null) {\n            if (defaultSize < 0) {\n                warnings.push(\"default size should not be less than 0\");\n            } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {\n                warnings.push(\"default size should not be less than min size\");\n            }\n            if (defaultSize > 100) {\n                warnings.push(\"default size should not be greater than 100\");\n            } else if (defaultSize > maxSize) {\n                warnings.push(\"default size should not be greater than max size\");\n            }\n        }\n        if (collapsedSize > minSize) {\n            warnings.push(\"collapsed size should not be greater than min size\");\n        }\n        if (warnings.length > 0) {\n            const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n            console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\n            return false;\n        }\n    }\n    return true;\n}\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({ layout: prevLayout, panelConstraints }) {\n    const nextLayout = [\n        ...prevLayout\n    ];\n    const nextLayoutTotalSize = nextLayout.reduce((accumulated, current)=>accumulated + current, 0);\n    // Validate layout expectations\n    if (nextLayout.length !== panelConstraints.length) {\n        throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size)=>`${size}%`).join(\", \")}`);\n    } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100)) {\n        // This is not ideal so we should warn about it, but it may be recoverable in some cases\n        // (especially if the amount is small)\n        {\n            console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size)=>`${size}%`).join(\", \")}. Layout normalization will be applied.`);\n        }\n        for(let index = 0; index < panelConstraints.length; index++){\n            const unsafeSize = nextLayout[index];\n            assert(unsafeSize != null, `No layout data found for index ${index}`);\n            const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    let remainingSize = 0;\n    // First pass: Validate the proposed layout given each panel's constraints\n    for(let index = 0; index < panelConstraints.length; index++){\n        const unsafeSize = nextLayout[index];\n        assert(unsafeSize != null, `No layout data found for index ${index}`);\n        const safeSize = resizePanel({\n            panelConstraints,\n            panelIndex: index,\n            size: unsafeSize\n        });\n        if (unsafeSize != safeSize) {\n            remainingSize += unsafeSize - safeSize;\n            nextLayout[index] = safeSize;\n        }\n    }\n    // If there is additional, left over space, assign it to any panel(s) that permits it\n    // (It's not worth taking multiple additional passes to evenly distribute)\n    if (!fuzzyNumbersEqual(remainingSize, 0)) {\n        for(let index = 0; index < panelConstraints.length; index++){\n            const prevSize = nextLayout[index];\n            assert(prevSize != null, `No layout data found for index ${index}`);\n            const unsafeSize = prevSize + remainingSize;\n            const safeSize = resizePanel({\n                panelConstraints,\n                panelIndex: index,\n                size: unsafeSize\n            });\n            if (prevSize !== safeSize) {\n                remainingSize -= safeSize - prevSize;\n                nextLayout[index] = safeSize;\n                // Once we've used up the remainder, bail\n                if (fuzzyNumbersEqual(remainingSize, 0)) {\n                    break;\n                }\n            }\n        }\n    }\n    return nextLayout;\n}\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n    getItem: (name)=>{\n        initializeDefaultStorage(defaultStorage);\n        return defaultStorage.getItem(name);\n    },\n    setItem: (name, value)=>{\n        initializeDefaultStorage(defaultStorage);\n        defaultStorage.setItem(name, value);\n    }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({ autoSaveId = null, children, className: classNameFromProps = \"\", direction, forwardedRef, id: idFromProps = null, onLayout = null, keyboardResizeBy = null, storage = defaultStorage, style: styleFromProps, tagName: Type = \"div\", ...rest }) {\n    const groupId = useUniqueId(idFromProps);\n    const panelGroupElementRef = useRef(null);\n    const [dragState, setDragState] = useState(null);\n    const [layout, setLayout] = useState([]);\n    const panelIdToLastNotifiedSizeMapRef = useRef({});\n    const panelSizeBeforeCollapseRef = useRef(new Map());\n    const prevDeltaRef = useRef(0);\n    const committedValuesRef = useRef({\n        autoSaveId,\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout,\n        storage\n    });\n    const eagerValuesRef = useRef({\n        layout,\n        panelDataArray: [],\n        panelDataArrayChanged: false\n    });\n    const devWarningsRef = useRef({\n        didLogIdAndOrderWarning: false,\n        didLogPanelConstraintsWarning: false,\n        prevPanelIds: []\n    });\n    useImperativeHandle(forwardedRef, ()=>({\n            getId: ()=>committedValuesRef.current.id,\n            getLayout: ()=>{\n                const { layout } = eagerValuesRef.current;\n                return layout;\n            },\n            setLayout: (unsafeLayout)=>{\n                const { onLayout } = committedValuesRef.current;\n                const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n                const safeLayout = validatePanelGroupLayout({\n                    layout: unsafeLayout,\n                    panelConstraints: panelDataArray.map((panelData)=>panelData.constraints)\n                });\n                if (!areEqual(prevLayout, safeLayout)) {\n                    setLayout(safeLayout);\n                    eagerValuesRef.current.layout = safeLayout;\n                    if (onLayout) {\n                        onLayout(safeLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }), []);\n    useWindowSplitterPanelGroupBehavior({\n        committedValuesRef,\n        eagerValuesRef,\n        groupId,\n        layout,\n        panelDataArray: eagerValuesRef.current.panelDataArray,\n        setLayout,\n        panelGroupElement: panelGroupElementRef.current\n    });\n    useEffect(()=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        // If this panel has been configured to persist sizing information, save sizes to local storage.\n        if (autoSaveId) {\n            if (layout.length === 0 || layout.length !== panelDataArray.length) {\n                return;\n            }\n            let debouncedSave = debounceMap[autoSaveId];\n            // Limit the frequency of localStorage updates.\n            if (debouncedSave == null) {\n                debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n                debounceMap[autoSaveId] = debouncedSave;\n            }\n            // Clone mutable data before passing to the debounced function,\n            // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n            const clonedPanelDataArray = [\n                ...panelDataArray\n            ];\n            const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n            debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n        }\n    }, [\n        autoSaveId,\n        layout,\n        storage\n    ]);\n    // DEV warnings\n    useEffect(()=>{\n        {\n            const { panelDataArray } = eagerValuesRef.current;\n            const { didLogIdAndOrderWarning, didLogPanelConstraintsWarning, prevPanelIds } = devWarningsRef.current;\n            if (!didLogIdAndOrderWarning) {\n                const panelIds = panelDataArray.map(({ id })=>id);\n                devWarningsRef.current.prevPanelIds = panelIds;\n                const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n                if (panelsHaveChanged) {\n                    if (panelDataArray.find(({ idIsFromProps, order })=>!idIsFromProps || order == null)) {\n                        devWarningsRef.current.didLogIdAndOrderWarning = true;\n                        console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\n                    }\n                }\n            }\n            if (!didLogPanelConstraintsWarning) {\n                const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n                for(let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++){\n                    const panelData = panelDataArray[panelIndex];\n                    assert(panelData, `Panel data not found for index ${panelIndex}`);\n                    const isValid = validatePanelConstraints({\n                        panelConstraints,\n                        panelId: panelData.id,\n                        panelIndex\n                    });\n                    if (!isValid) {\n                        devWarningsRef.current.didLogPanelConstraintsWarning = true;\n                        break;\n                    }\n                }\n            }\n        }\n    });\n    // External APIs are safe to memoize via committed values ref\n    const collapsePanel = useCallback((panelData)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n            if (panelSize !== collapsedSize) {\n                // Store size before collapse;\n                // This is the size that gets restored if the expand() API is used.\n                panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    initialLayout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    prevLayout,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const expandPanel = useCallback((panelData)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        if (panelData.constraints.collapsible) {\n            const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n            const { collapsedSize = 0, panelSize, minSize = 0, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n            if (panelSize === collapsedSize) {\n                // Restore this panel to the size it was before it was collapsed, if possible.\n                const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n                const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n                const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n                const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n                const nextLayout = adjustLayoutByDelta({\n                    delta,\n                    initialLayout: prevLayout,\n                    panelConstraints: panelConstraintsArray,\n                    pivotIndices,\n                    prevLayout,\n                    trigger: \"imperative-api\"\n                });\n                if (!compareLayouts(prevLayout, nextLayout)) {\n                    setLayout(nextLayout);\n                    eagerValuesRef.current.layout = nextLayout;\n                    if (onLayout) {\n                        onLayout(nextLayout);\n                    }\n                    callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n                }\n            }\n        }\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const getPanelSize = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n        return panelSize;\n    }, []);\n    // This API should never read from committedValuesRef\n    const getPanelStyle = useCallback((panelData, defaultSize)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n        return computePanelFlexBoxStyle({\n            defaultSize,\n            dragState,\n            layout,\n            panelData: panelDataArray,\n            panelIndex\n        });\n    }, [\n        dragState,\n        layout\n    ]);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelCollapsed = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        return collapsible === true && panelSize === collapsedSize;\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const isPanelExpanded = useCallback((panelData)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize = 0, collapsible, panelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n        return !collapsible || panelSize > collapsedSize;\n    }, []);\n    const registerPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        panelDataArray.push(panelData);\n        panelDataArray.sort((panelA, panelB)=>{\n            const orderA = panelA.order;\n            const orderB = panelB.order;\n            if (orderA == null && orderB == null) {\n                return 0;\n            } else if (orderA == null) {\n                return -1;\n            } else if (orderB == null) {\n                return 1;\n            } else {\n                return orderA - orderB;\n            }\n        });\n        eagerValuesRef.current.panelDataArrayChanged = true;\n    }, []);\n    const registerResizeHandle = useCallback((dragHandleId)=>{\n        return function resizeHandler(event) {\n            event.preventDefault();\n            const panelGroupElement = panelGroupElementRef.current;\n            if (!panelGroupElement) {\n                return ()=>null;\n            }\n            const { direction, dragState, id: groupId, keyboardResizeBy, onLayout } = committedValuesRef.current;\n            const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n            const { initialLayout } = dragState !== null && dragState !== void 0 ? dragState : {};\n            const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n            let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n            if (delta === 0) {\n                return;\n            }\n            // Support RTL layouts\n            const isHorizontal = direction === \"horizontal\";\n            if (document.dir === \"rtl\" && isHorizontal) {\n                delta = -delta;\n            }\n            const panelConstraints = panelDataArray.map((panelData)=>panelData.constraints);\n            const nextLayout = adjustLayoutByDelta({\n                delta,\n                initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n                panelConstraints,\n                pivotIndices,\n                prevLayout,\n                trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n            });\n            const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n            // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n            // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n            if (isMouseEvent(event) || isTouchEvent(event)) {\n                // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n                // In this case, Panel sizes might not change–\n                // but updating cursor in this scenario would cause a flicker.\n                if (prevDeltaRef.current != delta) {\n                    prevDeltaRef.current = delta;\n                    if (!layoutChanged) {\n                        // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n                        // This mimics VS Code behavior.\n                        if (isHorizontal) {\n                            reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n                        } else {\n                            reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n                        }\n                    } else {\n                        reportConstraintsViolation(dragHandleId, 0);\n                    }\n                }\n            }\n            if (layoutChanged) {\n                setLayout(nextLayout);\n                eagerValuesRef.current.layout = nextLayout;\n                if (onLayout) {\n                    onLayout(nextLayout);\n                }\n                callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n            }\n        };\n    }, []);\n    // External APIs are safe to memoize via committed values ref\n    const resizePanel = useCallback((panelData, unsafePanelSize)=>{\n        const { onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n        const panelConstraintsArray = panelDataArray.map((panelData)=>panelData.constraints);\n        const { panelSize, pivotIndices } = panelDataHelper(panelDataArray, panelData, prevLayout);\n        assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n            delta,\n            initialLayout: prevLayout,\n            panelConstraints: panelConstraintsArray,\n            pivotIndices,\n            prevLayout,\n            trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n            setLayout(nextLayout);\n            eagerValuesRef.current.layout = nextLayout;\n            if (onLayout) {\n                onLayout(nextLayout);\n            }\n            callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n    }, []);\n    const reevaluatePanelConstraints = useCallback((panelData, prevConstraints)=>{\n        const { layout, panelDataArray } = eagerValuesRef.current;\n        const { collapsedSize: prevCollapsedSize = 0, collapsible: prevCollapsible } = prevConstraints;\n        const { collapsedSize: nextCollapsedSize = 0, collapsible: nextCollapsible, maxSize: nextMaxSize = 100, minSize: nextMinSize = 0 } = panelData.constraints;\n        const { panelSize: prevPanelSize } = panelDataHelper(panelDataArray, panelData, layout);\n        if (prevPanelSize == null) {\n            // It's possible that the panels in this group have changed since the last render\n            return;\n        }\n        if (prevCollapsible && nextCollapsible && prevPanelSize === prevCollapsedSize) {\n            if (prevCollapsedSize !== nextCollapsedSize) {\n                resizePanel(panelData, nextCollapsedSize);\n            }\n        } else if (prevPanelSize < nextMinSize) {\n            resizePanel(panelData, nextMinSize);\n        } else if (prevPanelSize > nextMaxSize) {\n            resizePanel(panelData, nextMaxSize);\n        }\n    }, [\n        resizePanel\n    ]);\n    const startDragging = useCallback((dragHandleId, event)=>{\n        const { direction } = committedValuesRef.current;\n        const { layout } = eagerValuesRef.current;\n        if (!panelGroupElementRef.current) {\n            return;\n        }\n        const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n        assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n        const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n        setDragState({\n            dragHandleId,\n            dragHandleRect: handleElement.getBoundingClientRect(),\n            initialCursorPosition,\n            initialLayout: layout\n        });\n    }, []);\n    const stopDragging = useCallback(()=>{\n        setDragState(null);\n    }, []);\n    const unregisterPanel = useCallback((panelData)=>{\n        const { panelDataArray } = eagerValuesRef.current;\n        const index = findPanelDataIndex(panelDataArray, panelData);\n        if (index >= 0) {\n            panelDataArray.splice(index, 1);\n            // TRICKY\n            // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n            // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n            // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n            delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n            eagerValuesRef.current.panelDataArrayChanged = true;\n        }\n    }, []);\n    const context = useMemo(()=>({\n            collapsePanel,\n            direction,\n            dragState,\n            expandPanel,\n            getPanelSize,\n            getPanelStyle,\n            groupId,\n            isPanelCollapsed,\n            isPanelExpanded,\n            reevaluatePanelConstraints,\n            registerPanel,\n            registerResizeHandle,\n            resizePanel,\n            startDragging,\n            stopDragging,\n            unregisterPanel,\n            panelGroupElement: panelGroupElementRef.current\n        }), [\n        collapsePanel,\n        dragState,\n        direction,\n        expandPanel,\n        getPanelSize,\n        getPanelStyle,\n        groupId,\n        isPanelCollapsed,\n        isPanelExpanded,\n        reevaluatePanelConstraints,\n        registerPanel,\n        registerResizeHandle,\n        resizePanel,\n        startDragging,\n        stopDragging,\n        unregisterPanel\n    ]);\n    const style = {\n        display: \"flex\",\n        flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n    };\n    return createElement(PanelGroupContext.Provider, {\n        value: context\n    }, createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        id: idFromProps,\n        ref: panelGroupElementRef,\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        // CSS selectors\n        \"data-panel-group\": \"\",\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId\n    }));\n}\nconst PanelGroup = forwardRef((props, ref)=>createElement(PanelGroupWithForwardedRef, {\n        ...props,\n        forwardedRef: ref\n    }));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n    return panelDataArray.findIndex((prevPanelData)=>prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    const isLastPanel = panelIndex === panelDataArray.length - 1;\n    const pivotIndices = isLastPanel ? [\n        panelIndex - 1,\n        panelIndex\n    ] : [\n        panelIndex,\n        panelIndex + 1\n    ];\n    const panelSize = layout[panelIndex];\n    return {\n        ...panelData.constraints,\n        panelSize,\n        pivotIndices\n    };\n}\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\nfunction useWindowSplitterResizeHandlerBehavior({ disabled, handleId, resizeHandler, panelGroupElement }) {\n    useEffect(()=>{\n        if (disabled || resizeHandler == null || panelGroupElement == null) {\n            return;\n        }\n        const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n        if (handleElement == null) {\n            return;\n        }\n        const onKeyDown = (event)=>{\n            if (event.defaultPrevented) {\n                return;\n            }\n            switch(event.key){\n                case \"ArrowDown\":\n                case \"ArrowLeft\":\n                case \"ArrowRight\":\n                case \"ArrowUp\":\n                case \"End\":\n                case \"Home\":\n                    {\n                        event.preventDefault();\n                        resizeHandler(event);\n                        break;\n                    }\n                case \"F6\":\n                    {\n                        event.preventDefault();\n                        const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n                        assert(groupId, `No group element found for id \"${groupId}\"`);\n                        const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n                        const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n                        assert(index !== null, `No resize element found for id \"${handleId}\"`);\n                        const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n                        const nextHandle = handles[nextIndex];\n                        nextHandle.focus();\n                        break;\n                    }\n            }\n        };\n        handleElement.addEventListener(\"keydown\", onKeyDown);\n        return ()=>{\n            handleElement.removeEventListener(\"keydown\", onKeyDown);\n        };\n    }, [\n        panelGroupElement,\n        disabled,\n        handleId,\n        resizeHandler\n    ]);\n}\nfunction PanelResizeHandle({ children = null, className: classNameFromProps = \"\", disabled = false, hitAreaMargins, id: idFromProps, onDragging, style: styleFromProps = {}, tabIndex = 0, tagName: Type = \"div\", ...rest }) {\n    const elementRef = useRef(null);\n    // Use a ref to guard against users passing inline props\n    const callbacksRef = useRef({\n        onDragging\n    });\n    useEffect(()=>{\n        callbacksRef.current.onDragging = onDragging;\n    });\n    const panelGroupContext = useContext(PanelGroupContext);\n    if (panelGroupContext === null) {\n        throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n    }\n    const { direction, groupId, registerResizeHandle: registerResizeHandleWithParentGroup, startDragging, stopDragging, panelGroupElement } = panelGroupContext;\n    const resizeHandleId = useUniqueId(idFromProps);\n    const [state, setState] = useState(\"inactive\");\n    const [isFocused, setIsFocused] = useState(false);\n    const [resizeHandler, setResizeHandler] = useState(null);\n    const committedValuesRef = useRef({\n        state\n    });\n    useEffect(()=>{\n        if (disabled) {\n            setResizeHandler(null);\n        } else {\n            const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n            setResizeHandler(()=>resizeHandler);\n        }\n    }, [\n        disabled,\n        resizeHandleId,\n        registerResizeHandleWithParentGroup\n    ]);\n    useEffect(()=>{\n        var _hitAreaMargins$coars, _hitAreaMargins$fine;\n        if (disabled || resizeHandler == null) {\n            return;\n        }\n        const element = elementRef.current;\n        assert(element, \"Element ref not attached\");\n        const setResizeHandlerState = (action, isActive, event)=>{\n            if (isActive) {\n                switch(action){\n                    case \"down\":\n                        {\n                            setState(\"drag\");\n                            startDragging(resizeHandleId, event);\n                            const { onDragging } = callbacksRef.current;\n                            if (onDragging) {\n                                onDragging(true);\n                            }\n                            break;\n                        }\n                    case \"move\":\n                        {\n                            const { state } = committedValuesRef.current;\n                            if (state !== \"drag\") {\n                                setState(\"hover\");\n                            }\n                            resizeHandler(event);\n                            break;\n                        }\n                    case \"up\":\n                        {\n                            setState(\"hover\");\n                            stopDragging();\n                            const { onDragging } = callbacksRef.current;\n                            if (onDragging) {\n                                onDragging(false);\n                            }\n                            break;\n                        }\n                }\n            } else {\n                setState(\"inactive\");\n            }\n        };\n        return registerResizeHandle(resizeHandleId, element, direction, {\n            // Coarse inputs (e.g. finger/touch)\n            coarse: (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15,\n            // Fine inputs (e.g. mouse)\n            fine: (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5\n        }, setResizeHandlerState);\n    }, [\n        direction,\n        disabled,\n        hitAreaMargins,\n        registerResizeHandleWithParentGroup,\n        resizeHandleId,\n        resizeHandler,\n        startDragging,\n        stopDragging\n    ]);\n    useWindowSplitterResizeHandlerBehavior({\n        disabled,\n        handleId: resizeHandleId,\n        resizeHandler,\n        panelGroupElement\n    });\n    const style = {\n        touchAction: \"none\",\n        userSelect: \"none\"\n    };\n    return createElement(Type, {\n        ...rest,\n        children,\n        className: classNameFromProps,\n        id: idFromProps,\n        onBlur: ()=>setIsFocused(false),\n        onFocus: ()=>setIsFocused(true),\n        ref: elementRef,\n        role: \"separator\",\n        style: {\n            ...style,\n            ...styleFromProps\n        },\n        tabIndex,\n        // CSS selectors\n        \"data-panel-group-direction\": direction,\n        \"data-panel-group-id\": groupId,\n        \"data-resize-handle\": \"\",\n        \"data-resize-handle-active\": state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n        \"data-resize-handle-state\": state,\n        \"data-panel-resize-handle-enabled\": !disabled,\n        \"data-panel-resize-handle-id\": resizeHandleId\n    });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\nfunction getPanelElement(id, scope = document) {\n    const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n    if (element) {\n        return element;\n    }\n    return null;\n}\nfunction getPanelElementsForGroup(groupId, scope = document) {\n    return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n    if (!intersects(rectOne, rectTwo, strict)) {\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        };\n    }\n    return {\n        x: Math.max(rectOne.x, rectTwo.x),\n        y: Math.max(rectOne.y, rectTwo.y),\n        width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n        height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlLXBhbmVscy9kaXN0L3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMuZGV2ZWxvcG1lbnQubm9kZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBRS9CLGtHQUFrRztBQUVsRyxpREFBaUQ7QUFFakQsTUFBTSxFQUNKQyxhQUFhLEVBQ2JDLGFBQWEsRUFDYkMsU0FBUyxFQUNUQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsVUFBVSxFQUNWQyxTQUFTLEVBQ1RDLG1CQUFtQixFQUNuQkMsZUFBZSxFQUNmQyxPQUFPLEVBQ1BDLE1BQU0sRUFDTkMsUUFBUSxFQUNULEdBQUdaLGtDQUFLQTtBQUVULGdGQUFnRjtBQUNoRixNQUFNYSxRQUFRYixrQ0FBSyxDQUFDLFFBQVFjLFFBQVEsR0FBRztBQUV2QyxNQUFNQyxvQkFBb0JiLGNBQWM7QUFDeENhLGtCQUFrQkMsV0FBVyxHQUFHO0FBRWhDLE1BQU1DLGVBQWUsT0FBT0osVUFBVSxhQUFhQSxRQUFRLElBQU07QUFDakUsSUFBSUssVUFBVTtBQUNkLFNBQVNDLFlBQVlDLGVBQWUsSUFBSTtJQUN0QyxNQUFNQyxjQUFjSjtJQUNwQixNQUFNSyxRQUFRWCxPQUFPUyxnQkFBZ0JDLGVBQWU7SUFDcEQsSUFBSUMsTUFBTUMsT0FBTyxLQUFLLE1BQU07UUFDMUJELE1BQU1DLE9BQU8sR0FBRyxLQUFLTDtJQUN2QjtJQUNBLE9BQU9FLGlCQUFpQixRQUFRQSxpQkFBaUIsS0FBSyxJQUFJQSxlQUFlRSxNQUFNQyxPQUFPO0FBQ3hGO0FBRUEsU0FBU0Msc0JBQXNCLEVBQzdCQyxRQUFRLEVBQ1JDLFdBQVdDLHFCQUFxQixFQUFFLEVBQ2xDQyxhQUFhLEVBQ2JDLFdBQVcsRUFDWEMsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLElBQUlDLFdBQVcsRUFDZkMsT0FBTyxFQUNQQyxPQUFPLEVBQ1BDLFVBQVUsRUFDVkMsUUFBUSxFQUNSQyxRQUFRLEVBQ1JDLEtBQUssRUFDTEMsT0FBT0MsY0FBYyxFQUNyQkMsU0FBU0MsT0FBTyxLQUFLLEVBQ3JCLEdBQUdDLE1BQ0o7SUFDQyxNQUFNQyxVQUFVdkMsV0FBV1M7SUFDM0IsSUFBSThCLFlBQVksTUFBTTtRQUNwQixNQUFNQyxNQUFNLENBQUMsK0RBQStELENBQUM7SUFDL0U7SUFDQSxNQUFNLEVBQ0pDLGFBQWEsRUFDYkMsV0FBVyxFQUNYQyxZQUFZLEVBQ1pDLGFBQWEsRUFDYkMsT0FBTyxFQUNQQyxnQkFBZ0IsRUFDaEJDLDBCQUEwQixFQUMxQkMsYUFBYSxFQUNiQyxXQUFXLEVBQ1hDLGVBQWUsRUFDaEIsR0FBR1g7SUFDSixNQUFNWSxVQUFVdEMsWUFBWWM7SUFDNUIsTUFBTXlCLGVBQWUvQyxPQUFPO1FBQzFCZ0QsV0FBVztZQUNUdkI7WUFDQUM7WUFDQUM7UUFDRjtRQUNBc0IsYUFBYTtZQUNYaEM7WUFDQUM7WUFDQUM7WUFDQUk7WUFDQUM7UUFDRjtRQUNBSCxJQUFJeUI7UUFDSkksZUFBZTVCLGdCQUFnQjZCO1FBQy9CdkI7SUFDRjtJQUNBLE1BQU13QixpQkFBaUJwRCxPQUFPO1FBQzVCcUQsaUNBQWlDO0lBQ25DO0lBRUEsb0RBQW9EO0lBQ3BELCtEQUErRDtJQUMvRDtRQUNFLElBQUksQ0FBQ0QsZUFBZXhDLE9BQU8sQ0FBQ3lDLCtCQUErQixFQUFFO1lBQzNELElBQUlsQyxlQUFlLE1BQU07Z0JBQ3ZCaUMsZUFBZXhDLE9BQU8sQ0FBQ3lDLCtCQUErQixHQUFHO2dCQUN6REMsUUFBUUMsSUFBSSxDQUFDLENBQUMsd0ZBQXdGLENBQUM7WUFDekc7UUFDRjtJQUNGO0lBQ0ExRCxvQkFBb0J1QixjQUFjLElBQU87WUFDdkNvQyxVQUFVO2dCQUNScEIsY0FBY1csYUFBYW5DLE9BQU87WUFDcEM7WUFDQTZDLFFBQVE7Z0JBQ05wQixZQUFZVSxhQUFhbkMsT0FBTztZQUNsQztZQUNBOEM7Z0JBQ0UsT0FBT1o7WUFDVDtZQUNBYTtnQkFDRSxPQUFPckIsYUFBYVMsYUFBYW5DLE9BQU87WUFDMUM7WUFDQWdEO2dCQUNFLE9BQU9uQixpQkFBaUJNLGFBQWFuQyxPQUFPO1lBQzlDO1lBQ0FpRDtnQkFDRSxPQUFPLENBQUNwQixpQkFBaUJNLGFBQWFuQyxPQUFPO1lBQy9DO1lBQ0FrRCxRQUFRQyxDQUFBQTtnQkFDTm5CLFlBQVlHLGFBQWFuQyxPQUFPLEVBQUVtRDtZQUNwQztRQUNGLElBQUk7UUFBQzNCO1FBQWVDO1FBQWFDO1FBQWNHO1FBQWtCSztRQUFTRjtLQUFZO0lBQ3RGLE1BQU1mLFFBQVFVLGNBQWNRLGFBQWFuQyxPQUFPLEVBQUVPO0lBQ2xELE9BQU83QixjQUFjMEMsTUFBTTtRQUN6QixHQUFHQyxJQUFJO1FBQ1BuQjtRQUNBQyxXQUFXQztRQUNYSyxJQUFJQztRQUNKTyxPQUFPO1lBQ0wsR0FBR0EsS0FBSztZQUNSLEdBQUdDLGNBQWM7UUFDbkI7UUFDQSxnQkFBZ0I7UUFDaEIsY0FBYztRQUNkLDBCQUEwQlosZUFBZWlDO1FBQ3pDLHVCQUF1Qlg7UUFDdkIsaUJBQWlCTTtRQUNqQixtQkFBbUJrQixXQUFXLEtBQUtuQyxNQUFNb0MsUUFBUSxFQUFFQyxPQUFPLENBQUM7SUFDN0Q7QUFDRjtBQUNBLE1BQU1DLFFBQVExRSxXQUFXLENBQUMyRSxPQUFPQyxNQUFRL0UsY0FBY3VCLHVCQUF1QjtRQUM1RSxHQUFHdUQsS0FBSztRQUNSaEQsY0FBY2lEO0lBQ2hCO0FBQ0F4RCxzQkFBc0JSLFdBQVcsR0FBRztBQUNwQzhELE1BQU05RCxXQUFXLEdBQUc7QUFFcEIsSUFBSWlFLHFCQUFxQjtBQUN6QixJQUFJQyxlQUFlO0FBQ25CLFNBQVNDLGVBQWVDLEtBQUssRUFBRUMsZUFBZTtJQUM1QyxJQUFJQSxpQkFBaUI7UUFDbkIsTUFBTUMsZ0JBQWdCLENBQUNELGtCQUFrQkUsdUJBQXNCLE1BQU87UUFDdEUsTUFBTUMsZ0JBQWdCLENBQUNILGtCQUFrQkksdUJBQXNCLE1BQU87UUFDdEUsTUFBTUMsY0FBYyxDQUFDTCxrQkFBa0JNLHFCQUFvQixNQUFPO1FBQ2xFLE1BQU1DLGNBQWMsQ0FBQ1Asa0JBQWtCUSxxQkFBb0IsTUFBTztRQUNsRSxJQUFJUCxlQUFlO1lBQ2pCLElBQUlJLGFBQWE7Z0JBQ2YsT0FBTztZQUNULE9BQU8sSUFBSUUsYUFBYTtnQkFDdEIsT0FBTztZQUNULE9BQU87Z0JBQ0wsT0FBTztZQUNUO1FBQ0YsT0FBTyxJQUFJSixlQUFlO1lBQ3hCLElBQUlFLGFBQWE7Z0JBQ2YsT0FBTztZQUNULE9BQU8sSUFBSUUsYUFBYTtnQkFDdEIsT0FBTztZQUNULE9BQU87Z0JBQ0wsT0FBTztZQUNUO1FBQ0YsT0FBTyxJQUFJRixhQUFhO1lBQ3RCLE9BQU87UUFDVCxPQUFPLElBQUlFLGFBQWE7WUFDdEIsT0FBTztRQUNUO0lBQ0Y7SUFDQSxPQUFRUjtRQUNOLEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztJQUNYO0FBQ0Y7QUFDQSxTQUFTVTtJQUNQLElBQUlaLGlCQUFpQixNQUFNO1FBQ3pCYSxTQUFTQyxJQUFJLENBQUNDLFdBQVcsQ0FBQ2Y7UUFDMUJELHFCQUFxQjtRQUNyQkMsZUFBZTtJQUNqQjtBQUNGO0FBQ0EsU0FBU2dCLHFCQUFxQmQsS0FBSyxFQUFFQyxlQUFlO0lBQ2xELE1BQU03QyxRQUFRMkMsZUFBZUMsT0FBT0M7SUFDcEMsSUFBSUosdUJBQXVCekMsT0FBTztRQUNoQztJQUNGO0lBQ0F5QyxxQkFBcUJ6QztJQUNyQixJQUFJMEMsaUJBQWlCLE1BQU07UUFDekJBLGVBQWVhLFNBQVM5RixhQUFhLENBQUM7UUFDdEM4RixTQUFTQyxJQUFJLENBQUNHLFdBQVcsQ0FBQ2pCO0lBQzVCO0lBQ0FBLGFBQWFrQixTQUFTLEdBQUcsQ0FBQyxVQUFVLEVBQUU1RCxNQUFNLFlBQVksQ0FBQztBQUMzRDtBQUVBLFNBQVM2RCxVQUFVQyxLQUFLO0lBQ3RCLE9BQU9BLE1BQU1DLElBQUksS0FBSztBQUN4QjtBQUNBLFNBQVNDLGFBQWFGLEtBQUs7SUFDekIsT0FBT0EsTUFBTUMsSUFBSSxDQUFDRSxVQUFVLENBQUM7QUFDL0I7QUFDQSxTQUFTQyxhQUFhSixLQUFLO0lBQ3pCLE9BQU9BLE1BQU1DLElBQUksQ0FBQ0UsVUFBVSxDQUFDO0FBQy9CO0FBRUEsU0FBU0UsMEJBQTBCTCxLQUFLO0lBQ3RDLElBQUlFLGFBQWFGLFFBQVE7UUFDdkIsT0FBTztZQUNMTSxHQUFHTixNQUFNTyxPQUFPO1lBQ2hCQyxHQUFHUixNQUFNUyxPQUFPO1FBQ2xCO0lBQ0YsT0FBTyxJQUFJTCxhQUFhSixRQUFRO1FBQzlCLE1BQU1VLFFBQVFWLE1BQU1XLE9BQU8sQ0FBQyxFQUFFO1FBQzlCLElBQUlELFNBQVNBLE1BQU1ILE9BQU8sSUFBSUcsTUFBTUQsT0FBTyxFQUFFO1lBQzNDLE9BQU87Z0JBQ0xILEdBQUdJLE1BQU1ILE9BQU87Z0JBQ2hCQyxHQUFHRSxNQUFNRCxPQUFPO1lBQ2xCO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTEgsR0FBR007UUFDSEosR0FBR0k7SUFDTDtBQUNGO0FBRUEsU0FBU0M7SUFDUCxJQUFJLE9BQU9DLGVBQWUsWUFBWTtRQUNwQyxPQUFPQSxXQUFXLG9CQUFvQkMsT0FBTyxHQUFHLFdBQVc7SUFDN0Q7QUFDRjtBQUVBLFNBQVNDLFdBQVdDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxNQUFNO0lBQzFDLElBQUlBLFFBQVE7UUFDVixPQUFPRixRQUFRWCxDQUFDLEdBQUdZLFFBQVFaLENBQUMsR0FBR1ksUUFBUUUsS0FBSyxJQUFJSCxRQUFRWCxDQUFDLEdBQUdXLFFBQVFHLEtBQUssR0FBR0YsUUFBUVosQ0FBQyxJQUFJVyxRQUFRVCxDQUFDLEdBQUdVLFFBQVFWLENBQUMsR0FBR1UsUUFBUUcsTUFBTSxJQUFJSixRQUFRVCxDQUFDLEdBQUdTLFFBQVFJLE1BQU0sR0FBR0gsUUFBUVYsQ0FBQztJQUMzSyxPQUFPO1FBQ0wsT0FBT1MsUUFBUVgsQ0FBQyxJQUFJWSxRQUFRWixDQUFDLEdBQUdZLFFBQVFFLEtBQUssSUFBSUgsUUFBUVgsQ0FBQyxHQUFHVyxRQUFRRyxLQUFLLElBQUlGLFFBQVFaLENBQUMsSUFBSVcsUUFBUVQsQ0FBQyxJQUFJVSxRQUFRVixDQUFDLEdBQUdVLFFBQVFHLE1BQU0sSUFBSUosUUFBUVQsQ0FBQyxHQUFHUyxRQUFRSSxNQUFNLElBQUlILFFBQVFWLENBQUM7SUFDL0s7QUFDRjtBQUVBLHVDQUF1QztBQUV2Qzs7Ozs7Q0FLQyxHQUNELFNBQVNjLFFBQVFDLENBQUMsRUFBRUMsQ0FBQztJQUNuQixJQUFJRCxNQUFNQyxHQUFHLE1BQU0sSUFBSWhGLE1BQU07SUFDN0IsTUFBTWlGLFlBQVk7UUFDaEJGLEdBQUdHLGNBQWNIO1FBQ2pCQyxHQUFHRSxjQUFjRjtJQUNuQjtJQUNBLElBQUlHO0lBRUosMEJBQTBCO0lBQzFCLE1BQU9GLFVBQVVGLENBQUMsQ0FBQ0ssRUFBRSxDQUFDLENBQUMsT0FBT0gsVUFBVUQsQ0FBQyxDQUFDSSxFQUFFLENBQUMsQ0FBQyxHQUFJO1FBQ2hETCxJQUFJRSxVQUFVRixDQUFDLENBQUNNLEdBQUc7UUFDbkJMLElBQUlDLFVBQVVELENBQUMsQ0FBQ0ssR0FBRztRQUNuQkYsa0JBQWtCSjtJQUNwQjtJQUNBTyxPQUFPSCxpQkFBaUI7SUFDeEIsTUFBTUksWUFBWTtRQUNoQlIsR0FBR1MsWUFBWUMsc0JBQXNCUixVQUFVRixDQUFDO1FBQ2hEQyxHQUFHUSxZQUFZQyxzQkFBc0JSLFVBQVVELENBQUM7SUFDbEQ7SUFDQSxJQUFJTyxVQUFVUixDQUFDLEtBQUtRLFVBQVVQLENBQUMsRUFBRTtRQUMvQixNQUFNckcsV0FBV3dHLGdCQUFnQk8sVUFBVTtRQUMzQyxNQUFNQyxxQkFBcUI7WUFDekJaLEdBQUdFLFVBQVVGLENBQUMsQ0FBQ0ssRUFBRSxDQUFDLENBQUM7WUFDbkJKLEdBQUdDLFVBQVVELENBQUMsQ0FBQ0ksRUFBRSxDQUFDLENBQUM7UUFDckI7UUFDQSxJQUFJUSxJQUFJakgsU0FBU2tILE1BQU07UUFDdkIsTUFBT0QsSUFBSztZQUNWLE1BQU1FLFFBQVFuSCxRQUFRLENBQUNpSCxFQUFFO1lBQ3pCLElBQUlFLFVBQVVILG1CQUFtQlosQ0FBQyxFQUFFLE9BQU87WUFDM0MsSUFBSWUsVUFBVUgsbUJBQW1CWCxDQUFDLEVBQUUsT0FBTyxDQUFDO1FBQzlDO0lBQ0Y7SUFDQSxPQUFPZSxLQUFLQyxJQUFJLENBQUNULFVBQVVSLENBQUMsR0FBR1EsVUFBVVAsQ0FBQztBQUM1QztBQUNBLE1BQU0vQyxRQUFRO0FBRWQsOEJBQThCLEdBQzlCLFNBQVNnRSxhQUFhQyxJQUFJO0lBQ3hCLE1BQU1DLFVBQVVDLGlCQUFpQkMsV0FBV0gsT0FBT0MsT0FBTztJQUMxRCxPQUFPQSxZQUFZLFVBQVVBLFlBQVk7QUFDM0M7QUFFQSw4QkFBOEIsR0FDOUIsU0FBU0cseUJBQXlCSixJQUFJO0lBQ3BDLE1BQU14RyxRQUFRMEcsaUJBQWlCRjtJQUUvQiw4R0FBOEc7SUFDOUcsSUFBSXhHLE1BQU02RyxRQUFRLEtBQUssU0FBUyxPQUFPO0lBQ3ZDLG9GQUFvRjtJQUNwRixPQUFPO0lBQ1AsZ0VBQWdFO0lBQ2hFLHVCQUF1QjtJQUN2QixJQUFJO0lBQ0osSUFBSTdHLE1BQU04RyxNQUFNLEtBQUssVUFBVzlHLENBQUFBLE1BQU02RyxRQUFRLEtBQUssWUFBWU4sYUFBYUMsS0FBSSxHQUFJLE9BQU87SUFDM0YsSUFBSSxDQUFDeEcsTUFBTStHLE9BQU8sR0FBRyxHQUFHLE9BQU87SUFDL0IsSUFBSSxlQUFlL0csU0FBU0EsTUFBTWdILFNBQVMsS0FBSyxRQUFRLE9BQU87SUFDL0QsSUFBSSxxQkFBcUJoSCxTQUFTQSxNQUFNaUgsZUFBZSxLQUFLLFFBQVEsT0FBTztJQUMzRSxJQUFJLGtCQUFrQmpILFNBQVNBLE1BQU1rSCxZQUFZLEtBQUssVUFBVSxPQUFPO0lBQ3ZFLElBQUksWUFBWWxILFNBQVNBLE1BQU1tSCxNQUFNLEtBQUssUUFBUSxPQUFPO0lBQ3pELElBQUksa0JBQWtCbkgsU0FBU0EsTUFBTW9ILFlBQVksS0FBSyxRQUFRLE9BQU87SUFDckUsSUFBSSxlQUFlcEgsU0FBU0EsTUFBTXFILFNBQVMsS0FBSyxXQUFXLE9BQU87SUFDbEUsSUFBSTlFLE1BQU0rRSxJQUFJLENBQUN0SCxNQUFNdUgsVUFBVSxHQUFHLE9BQU87SUFDekMsbUJBQW1CO0lBQ25CLElBQUl2SCxNQUFNd0gsdUJBQXVCLEtBQUssU0FBUyxPQUFPO0lBQ3RELE9BQU87QUFDVDtBQUVBLGlDQUFpQyxHQUNqQyxTQUFTekIsc0JBQXNCMEIsS0FBSztJQUNsQyxJQUFJdkIsSUFBSXVCLE1BQU10QixNQUFNO0lBQ3BCLE1BQU9ELElBQUs7UUFDVixNQUFNTSxPQUFPaUIsS0FBSyxDQUFDdkIsRUFBRTtRQUNyQk4sT0FBT1ksTUFBTTtRQUNiLElBQUlJLHlCQUF5QkosT0FBTyxPQUFPQTtJQUM3QztJQUNBLE9BQU87QUFDVDtBQUVBLDhCQUE4QixHQUM5QixTQUFTVixZQUFZVSxJQUFJO0lBQ3ZCLE9BQU9BLFFBQVFrQixPQUFPaEIsaUJBQWlCRixNQUFNTSxNQUFNLEtBQUs7QUFDMUQ7QUFFQSw4QkFBOEIsR0FDOUIsU0FBU3RCLGNBQWNnQixJQUFJO0lBQ3pCLE1BQU1qQixZQUFZLEVBQUU7SUFDcEIsTUFBT2lCLEtBQU07UUFDWGpCLFVBQVVvQyxJQUFJLENBQUNuQjtRQUNmQSxPQUFPRyxXQUFXSDtJQUNwQjtJQUNBLE9BQU9qQixXQUFXLHlDQUF5QztBQUM3RDtBQUVBLDhCQUE4QixHQUM5QixTQUFTb0IsV0FBV0gsSUFBSTtJQUN0QixJQUFJb0I7SUFDSixhQUFhO0lBQ2IsT0FBTyxDQUFDLENBQUNBLG1CQUFtQnBCLEtBQUtxQixVQUFVLE1BQU0sUUFBUUQscUJBQXFCLEtBQUssSUFBSSxLQUFLLElBQUlBLGlCQUFpQkUsSUFBSSxLQUFLdEIsS0FBS3FCLFVBQVU7QUFDM0k7QUFFQSxNQUFNOUUsMEJBQTBCO0FBQ2hDLE1BQU1FLDBCQUEwQjtBQUNoQyxNQUFNRSx3QkFBd0I7QUFDOUIsTUFBTUUsd0JBQXdCO0FBQzlCLE1BQU0wRSxrQkFBa0JwRCxtQkFBbUI7QUFDM0MsSUFBSXFELHNCQUFzQixFQUFFO0FBQzVCLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxzQkFBc0IsSUFBSUM7QUFDOUIsSUFBSUMsdUJBQXVCLElBQUlEO0FBQy9CLE1BQU1FLDJCQUEyQixJQUFJQztBQUNyQyxTQUFTQyxxQkFBcUJDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxTQUFTLEVBQUVDLGNBQWMsRUFBRUMscUJBQXFCO0lBQ3JHLElBQUlDO0lBQ0osTUFBTSxFQUNKQyxhQUFhLEVBQ2QsR0FBR0w7SUFDSixNQUFNTSxPQUFPO1FBQ1hMO1FBQ0FEO1FBQ0FFO1FBQ0FDO0lBQ0Y7SUFDQSxNQUFNSSxRQUFRLENBQUNILHdCQUF3Qlgsb0JBQW9CZSxHQUFHLENBQUNILGNBQWEsTUFBTyxRQUFRRCwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7SUFDdEpYLG9CQUFvQmdCLEdBQUcsQ0FBQ0osZUFBZUUsUUFBUTtJQUMvQ1gseUJBQXlCYyxHQUFHLENBQUNKO0lBQzdCSztJQUNBLE9BQU8sU0FBU0M7UUFDZCxJQUFJQztRQUNKbEIscUJBQXFCbUIsTUFBTSxDQUFDZjtRQUM1QkgseUJBQXlCa0IsTUFBTSxDQUFDUjtRQUNoQyxNQUFNQyxRQUFRLENBQUNNLHlCQUF5QnBCLG9CQUFvQmUsR0FBRyxDQUFDSCxjQUFhLE1BQU8sUUFBUVEsMkJBQTJCLEtBQUssSUFBSUEseUJBQXlCO1FBQ3pKcEIsb0JBQW9CZ0IsR0FBRyxDQUFDSixlQUFlRSxRQUFRO1FBQy9DSTtRQUNBLElBQUlKLFVBQVUsR0FBRztZQUNmZCxvQkFBb0JxQixNQUFNLENBQUNUO1FBQzdCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNVLGtCQUFrQjFGLEtBQUs7SUFDOUIsTUFBTSxFQUNKMkYsTUFBTSxFQUNQLEdBQUczRjtJQUNKLE1BQU0sRUFDSk0sQ0FBQyxFQUNERSxDQUFDLEVBQ0YsR0FBR0gsMEJBQTBCTDtJQUM5Qm1FLGdCQUFnQjtJQUNoQnlCLCtCQUErQjtRQUM3QkQ7UUFDQXJGO1FBQ0FFO0lBQ0Y7SUFDQThFO0lBQ0EsSUFBSXBCLG9CQUFvQjdCLE1BQU0sR0FBRyxHQUFHO1FBQ2xDd0QsMEJBQTBCLFFBQVE3RjtRQUNsQ0EsTUFBTThGLGNBQWM7SUFDdEI7QUFDRjtBQUNBLFNBQVNDLGtCQUFrQi9GLEtBQUs7SUFDOUIsTUFBTSxFQUNKTSxDQUFDLEVBQ0RFLENBQUMsRUFDRixHQUFHSCwwQkFBMEJMO0lBQzlCLElBQUksQ0FBQ21FLGVBQWU7UUFDbEIsTUFBTSxFQUNKd0IsTUFBTSxFQUNQLEdBQUczRjtRQUVKLHFHQUFxRztRQUNyRyxzRkFBc0Y7UUFDdEYsb0ZBQW9GO1FBQ3BGNEYsK0JBQStCO1lBQzdCRDtZQUNBckY7WUFDQUU7UUFDRjtJQUNGO0lBQ0FxRiwwQkFBMEIsUUFBUTdGO0lBRWxDLDZEQUE2RDtJQUM3RGdHO0lBQ0EsSUFBSTlCLG9CQUFvQjdCLE1BQU0sR0FBRyxHQUFHO1FBQ2xDckMsTUFBTThGLGNBQWM7SUFDdEI7QUFDRjtBQUNBLFNBQVNHLGdCQUFnQmpHLEtBQUs7SUFDNUIsTUFBTSxFQUNKMkYsTUFBTSxFQUNQLEdBQUczRjtJQUNKLE1BQU0sRUFDSk0sQ0FBQyxFQUNERSxDQUFDLEVBQ0YsR0FBR0gsMEJBQTBCTDtJQUM5QnNFLHFCQUFxQjRCLEtBQUs7SUFDMUIvQixnQkFBZ0I7SUFDaEIsSUFBSUQsb0JBQW9CN0IsTUFBTSxHQUFHLEdBQUc7UUFDbENyQyxNQUFNOEYsY0FBYztJQUN0QjtJQUNBRCwwQkFBMEIsTUFBTTdGO0lBQ2hDNEYsK0JBQStCO1FBQzdCRDtRQUNBckY7UUFDQUU7SUFDRjtJQUNBd0Y7SUFDQVY7QUFDRjtBQUNBLFNBQVNNLCtCQUErQixFQUN0Q0QsTUFBTSxFQUNOckYsQ0FBQyxFQUNERSxDQUFDLEVBQ0Y7SUFDQzBELG9CQUFvQmlDLE1BQU0sQ0FBQztJQUMzQixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSVQsa0JBQWtCVSxhQUFhO1FBQ2pDRCxnQkFBZ0JUO0lBQ2xCO0lBQ0FwQix5QkFBeUIrQixPQUFPLENBQUNyQixDQUFBQTtRQUMvQixNQUFNLEVBQ0pOLFNBQVM0QixpQkFBaUIsRUFDMUIxQixjQUFjLEVBQ2YsR0FBR0k7UUFDSixNQUFNdUIsaUJBQWlCRCxrQkFBa0JFLHFCQUFxQjtRQUM5RCxNQUFNLEVBQ0pDLE1BQU0sRUFDTkMsSUFBSSxFQUNKQyxLQUFLLEVBQ0xDLEdBQUcsRUFDSixHQUFHTDtRQUNKLE1BQU1NLFNBQVM3QyxrQkFBa0JZLGVBQWVrQyxNQUFNLEdBQUdsQyxlQUFlbUMsSUFBSTtRQUM1RSxNQUFNQyxrQkFBa0IzRyxLQUFLcUcsT0FBT0csVUFBVXhHLEtBQUtzRyxRQUFRRSxVQUFVdEcsS0FBS3FHLE1BQU1DLFVBQVV0RyxLQUFLa0csU0FBU0k7UUFDeEcsSUFBSUcsaUJBQWlCO1lBQ25CLFNBQVM7WUFDVCxpRkFBaUY7WUFDakYsd0ZBQXdGO1lBQ3hGLHFGQUFxRjtZQUNyRixnR0FBZ0c7WUFDaEcsb0RBQW9EO1lBQ3BELElBQUliLGtCQUFrQixRQUFRRyxzQkFBc0JILGlCQUFpQixDQUFDRyxrQkFBa0JXLFFBQVEsQ0FBQ2Qsa0JBQWtCLENBQUNBLGNBQWNjLFFBQVEsQ0FBQ1gsc0JBQzNJLDJFQUEyRTtZQUMzRSw4REFBOEQ7WUFDOUQsaUVBQWlFO1lBQ2pFakYsUUFBUThFLGVBQWVHLHFCQUFxQixHQUFHO2dCQUM3QyxvRkFBb0Y7Z0JBQ3BGLHdHQUF3RztnQkFDeEcsRUFBRTtnQkFDRiw2Q0FBNkM7Z0JBQzdDLG1FQUFtRTtnQkFDbkUsaUVBQWlFO2dCQUNqRSxJQUFJWSxpQkFBaUJmO2dCQUNyQixJQUFJZ0IsZUFBZTtnQkFDbkIsTUFBT0QsZUFBZ0I7b0JBQ3JCLElBQUlBLGVBQWVELFFBQVEsQ0FBQ1gsb0JBQW9CO3dCQUM5QztvQkFDRixPQUFPLElBQUl2RixXQUFXbUcsZUFBZVYscUJBQXFCLElBQUlELGdCQUFnQixPQUFPO3dCQUNuRlksZUFBZTt3QkFDZjtvQkFDRjtvQkFDQUQsaUJBQWlCQSxlQUFlRSxhQUFhO2dCQUMvQztnQkFDQSxJQUFJRCxjQUFjO29CQUNoQjtnQkFDRjtZQUNGO1lBQ0FsRCxvQkFBb0JMLElBQUksQ0FBQ29CO1FBQzNCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNxQywyQkFBMkI1QyxjQUFjLEVBQUU2QyxJQUFJO0lBQ3REakQscUJBQXFCYyxHQUFHLENBQUNWLGdCQUFnQjZDO0FBQzNDO0FBQ0EsU0FBU3ZCO0lBQ1AsSUFBSXdCLHVCQUF1QjtJQUMzQixJQUFJQyxxQkFBcUI7SUFDekJ2RCxvQkFBb0JvQyxPQUFPLENBQUNyQixDQUFBQTtRQUMxQixNQUFNLEVBQ0pMLFNBQVMsRUFDVixHQUFHSztRQUNKLElBQUlMLGNBQWMsY0FBYztZQUM5QjRDLHVCQUF1QjtRQUN6QixPQUFPO1lBQ0xDLHFCQUFxQjtRQUN2QjtJQUNGO0lBQ0EsSUFBSTFJLGtCQUFrQjtJQUN0QnVGLHFCQUFxQmdDLE9BQU8sQ0FBQ2lCLENBQUFBO1FBQzNCeEksbUJBQW1Cd0k7SUFDckI7SUFDQSxJQUFJQyx3QkFBd0JDLG9CQUFvQjtRQUM5QzdILHFCQUFxQixnQkFBZ0JiO0lBQ3ZDLE9BQU8sSUFBSXlJLHNCQUFzQjtRQUMvQjVILHFCQUFxQixjQUFjYjtJQUNyQyxPQUFPLElBQUkwSSxvQkFBb0I7UUFDN0I3SCxxQkFBcUIsWUFBWWI7SUFDbkMsT0FBTztRQUNMUztJQUNGO0FBQ0Y7QUFDQSxTQUFTOEY7SUFDUGxCLG9CQUFvQmtDLE9BQU8sQ0FBQyxDQUFDb0IsR0FBRzFDO1FBQzlCLE1BQU0sRUFDSjJDLElBQUksRUFDTCxHQUFHM0M7UUFDSjJDLEtBQUtDLG1CQUFtQixDQUFDLGVBQWUzQjtRQUN4QzBCLEtBQUtDLG1CQUFtQixDQUFDLGFBQWFsQztRQUN0Q2lDLEtBQUtDLG1CQUFtQixDQUFDLGNBQWM3QjtRQUN2QzRCLEtBQUtDLG1CQUFtQixDQUFDLGFBQWE3QjtRQUN0QzRCLEtBQUtDLG1CQUFtQixDQUFDLGFBQWE3QjtRQUN0QzRCLEtBQUtDLG1CQUFtQixDQUFDLGNBQWNsQztJQUN6QztJQUNBbUMsT0FBT0QsbUJBQW1CLENBQUMsV0FBVzNCO0lBQ3RDNEIsT0FBT0QsbUJBQW1CLENBQUMsZUFBZTNCO0lBQzFDNEIsT0FBT0QsbUJBQW1CLENBQUMsWUFBWTNCO0lBQ3ZDLElBQUkxQix5QkFBeUJuRyxJQUFJLEdBQUcsR0FBRztRQUNyQyxJQUFJK0YsZUFBZTtZQUNqQixJQUFJRCxvQkFBb0I3QixNQUFNLEdBQUcsR0FBRztnQkFDbEMrQixvQkFBb0JrQyxPQUFPLENBQUMsQ0FBQ3BCLE9BQU9GO29CQUNsQyxNQUFNLEVBQ0oyQyxJQUFJLEVBQ0wsR0FBRzNDO29CQUNKLElBQUlFLFFBQVEsR0FBRzt3QkFDYnlDLEtBQUtHLGdCQUFnQixDQUFDLGVBQWU3Qjt3QkFDckMwQixLQUFLRyxnQkFBZ0IsQ0FBQyxjQUFjL0I7d0JBQ3BDNEIsS0FBS0csZ0JBQWdCLENBQUMsYUFBYS9CO3dCQUNuQzRCLEtBQUtHLGdCQUFnQixDQUFDLGFBQWEvQixtQkFBbUI7NEJBQ3BEZ0MsU0FBUzt3QkFDWDtvQkFDRjtnQkFDRjtZQUNGO1lBQ0FGLE9BQU9DLGdCQUFnQixDQUFDLFdBQVc3QjtZQUNuQzRCLE9BQU9DLGdCQUFnQixDQUFDLGVBQWU3QjtZQUN2QzRCLE9BQU9DLGdCQUFnQixDQUFDLFlBQVk3QjtRQUN0QyxPQUFPO1lBQ0w3QixvQkFBb0JrQyxPQUFPLENBQUMsQ0FBQ3BCLE9BQU9GO2dCQUNsQyxNQUFNLEVBQ0oyQyxJQUFJLEVBQ0wsR0FBRzNDO2dCQUNKLElBQUlFLFFBQVEsR0FBRztvQkFDYnlDLEtBQUtHLGdCQUFnQixDQUFDLGFBQWFwQztvQkFDbkNpQyxLQUFLRyxnQkFBZ0IsQ0FBQyxhQUFhL0I7b0JBQ25DNEIsS0FBS0csZ0JBQWdCLENBQUMsYUFBYS9CLG1CQUFtQjt3QkFDcERnQyxTQUFTO29CQUNYO29CQUNBSixLQUFLRyxnQkFBZ0IsQ0FBQyxjQUFjcEM7Z0JBQ3RDO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTRywwQkFBMEJtQyxNQUFNLEVBQUVoSSxLQUFLO0lBQzlDdUUseUJBQXlCK0IsT0FBTyxDQUFDckIsQ0FBQUE7UUFDL0IsTUFBTSxFQUNKSCxxQkFBcUIsRUFDdEIsR0FBR0c7UUFDSixNQUFNZ0QsV0FBVy9ELG9CQUFvQmdFLFFBQVEsQ0FBQ2pEO1FBQzlDSCxzQkFBc0JrRCxRQUFRQyxVQUFVakk7SUFDMUM7QUFDRjtBQUVBLFNBQVM4QixPQUFPcUcsaUJBQWlCLEVBQUVDLE9BQU87SUFDeEMsSUFBSSxDQUFDRCxtQkFBbUI7UUFDdEJ4SyxRQUFRMEssS0FBSyxDQUFDRDtRQUNkLE1BQU01TCxNQUFNNEw7SUFDZDtBQUNGO0FBRUEsTUFBTUUsWUFBWTtBQUVsQixTQUFTQyxvQkFBb0JDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxpQkFBaUJKLFNBQVM7SUFDdkVFLFNBQVNuSyxXQUFXbUssT0FBT2pLLE9BQU8sQ0FBQ21LO0lBQ25DRCxXQUFXcEssV0FBV29LLFNBQVNsSyxPQUFPLENBQUNtSztJQUN2QyxNQUFNQyxRQUFRSCxTQUFTQztJQUN2QixJQUFJRSxVQUFVLEdBQUc7UUFDZixPQUFPO0lBQ1QsT0FBTztRQUNMLE9BQU9BLFFBQVEsSUFBSSxJQUFJLENBQUM7SUFDMUI7QUFDRjtBQUVBLFNBQVNDLGtCQUFrQkosTUFBTSxFQUFFQyxRQUFRLEVBQUVDLGNBQWM7SUFDekQsT0FBT0gsb0JBQW9CQyxRQUFRQyxVQUFVQyxvQkFBb0I7QUFDbkU7QUFFQSxTQUFTRyxrQkFBa0JMLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxjQUFjO0lBQ3pELElBQUlGLE9BQU9uRyxNQUFNLEtBQUtvRyxTQUFTcEcsTUFBTSxFQUFFO1FBQ3JDLE9BQU87SUFDVDtJQUNBLElBQUssSUFBSXlHLFFBQVEsR0FBR0EsUUFBUU4sT0FBT25HLE1BQU0sRUFBRXlHLFFBQVM7UUFDbEQsTUFBTUMsYUFBYVAsTUFBTSxDQUFDTSxNQUFNO1FBQ2hDLE1BQU1FLGVBQWVQLFFBQVEsQ0FBQ0ssTUFBTTtRQUNwQyxJQUFJLENBQUNGLGtCQUFrQkcsWUFBWUMsY0FBY04saUJBQWlCO1lBQ2hFLE9BQU87UUFDVDtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUEsMEVBQTBFO0FBQzFFLFNBQVN6TCxZQUFZLEVBQ25CZ00sa0JBQWtCQyxxQkFBcUIsRUFDdkNDLFVBQVUsRUFDVi9LLElBQUksRUFDTDtJQUNDLE1BQU02SyxtQkFBbUJDLHFCQUFxQixDQUFDQyxXQUFXO0lBQzFEckgsT0FBT21ILG9CQUFvQixNQUFNLENBQUMsc0NBQXNDLEVBQUVFLFdBQVcsQ0FBQztJQUN0RixJQUFJLEVBQ0Y3TixnQkFBZ0IsQ0FBQyxFQUNqQkMsV0FBVyxFQUNYSyxVQUFVLEdBQUcsRUFDYkMsVUFBVSxDQUFDLEVBQ1osR0FBR29OO0lBQ0osSUFBSVYsb0JBQW9CbkssTUFBTXZDLFdBQVcsR0FBRztRQUMxQyxJQUFJTixhQUFhO1lBQ2YsdUhBQXVIO1lBQ3ZILE1BQU02TixlQUFlLENBQUM5TixnQkFBZ0JPLE9BQU0sSUFBSztZQUNqRCxJQUFJME0sb0JBQW9CbkssTUFBTWdMLGdCQUFnQixHQUFHO2dCQUMvQ2hMLE9BQU85QztZQUNULE9BQU87Z0JBQ0w4QyxPQUFPdkM7WUFDVDtRQUNGLE9BQU87WUFDTHVDLE9BQU92QztRQUNUO0lBQ0Y7SUFDQXVDLE9BQU9tRSxLQUFLOEcsR0FBRyxDQUFDek4sU0FBU3dDO0lBQ3pCQSxPQUFPQyxXQUFXRCxLQUFLRyxPQUFPLENBQUMrSjtJQUMvQixPQUFPbEs7QUFDVDtBQUVBLHlFQUF5RTtBQUN6RSxTQUFTa0wsb0JBQW9CLEVBQzNCWCxLQUFLLEVBQ0xZLGFBQWEsRUFDYk4sa0JBQWtCQyxxQkFBcUIsRUFDdkNNLFlBQVksRUFDWkMsVUFBVSxFQUNWQyxPQUFPLEVBQ1I7SUFDQyxJQUFJZCxrQkFBa0JELE9BQU8sSUFBSTtRQUMvQixPQUFPWTtJQUNUO0lBQ0EsTUFBTUksYUFBYTtXQUFJSjtLQUFjO0lBQ3JDLE1BQU0sQ0FBQ0ssaUJBQWlCQyxpQkFBaUIsR0FBR0w7SUFDNUMxSCxPQUFPOEgsbUJBQW1CLE1BQU07SUFDaEM5SCxPQUFPK0gsb0JBQW9CLE1BQU07SUFDakMsSUFBSUMsZUFBZTtJQUVuQixvQkFBb0I7SUFDcEIsdUNBQXVDO0lBQ3ZDLDhEQUE4RDtJQUM5RCx3REFBd0Q7SUFDeEQsbUNBQW1DO0lBQ25DLDREQUE0RDtJQUM1RCx1Q0FBdUM7SUFDdkMsa0JBQWtCO0lBRWxCLDBEQUEwRDtJQUMxRCxFQUFFO0lBQ0YsdUhBQXVIO0lBQ3ZILHdHQUF3RztJQUN4RyxFQUFFO0lBQ0YsNEZBQTRGO0lBQzVGLGtIQUFrSDtJQUVsSDtRQUNFLHNHQUFzRztRQUN0RyxxR0FBcUc7UUFDckcsSUFBSUosWUFBWSxZQUFZO1lBQzFCO2dCQUNFLDhDQUE4QztnQkFDOUMsTUFBTVosUUFBUUgsUUFBUSxJQUFJa0IsbUJBQW1CRDtnQkFDN0MsTUFBTVgsbUJBQW1CQyxxQkFBcUIsQ0FBQ0osTUFBTTtnQkFDckRoSCxPQUFPbUgsa0JBQWtCLENBQUMsc0NBQXNDLEVBQUVILE1BQU0sQ0FBQztnQkFDekUsTUFBTSxFQUNKeE4sZ0JBQWdCLENBQUMsRUFDakJDLFdBQVcsRUFDWE0sVUFBVSxDQUFDLEVBQ1osR0FBR29OO2dCQUVKLDZDQUE2QztnQkFDN0Msa0RBQWtEO2dCQUNsRCxJQUFJMU4sYUFBYTtvQkFDZixNQUFNd08sV0FBV1IsYUFBYSxDQUFDVCxNQUFNO29CQUNyQ2hILE9BQU9pSSxZQUFZLE1BQU0sQ0FBQywwQ0FBMEMsRUFBRWpCLE1BQU0sQ0FBQztvQkFDN0UsSUFBSUYsa0JBQWtCbUIsVUFBVXpPLGdCQUFnQjt3QkFDOUMsTUFBTTBPLGFBQWFuTyxVQUFVa087d0JBQzdCLGtEQUFrRDt3QkFFbEQsSUFBSXhCLG9CQUFvQnlCLFlBQVl6SCxLQUFLMEgsR0FBRyxDQUFDdEIsVUFBVSxHQUFHOzRCQUN4REEsUUFBUUEsUUFBUSxJQUFJLElBQUlxQixhQUFhQTt3QkFDckMsc0NBQXNDO3dCQUN4QztvQkFDRjtnQkFDRjtZQUNGO1lBRUE7Z0JBQ0UsMERBQTBEO2dCQUMxRCxNQUFNbEIsUUFBUUgsUUFBUSxJQUFJaUIsa0JBQWtCQztnQkFDNUMsTUFBTVosbUJBQW1CQyxxQkFBcUIsQ0FBQ0osTUFBTTtnQkFDckRoSCxPQUFPbUgsa0JBQWtCLENBQUMscUNBQXFDLEVBQUVILE1BQU0sQ0FBQztnQkFDeEUsTUFBTSxFQUNKeE4sZ0JBQWdCLENBQUMsRUFDakJDLFdBQVcsRUFDWE0sVUFBVSxDQUFDLEVBQ1osR0FBR29OO2dCQUVKLDZDQUE2QztnQkFDN0Msa0RBQWtEO2dCQUNsRCxJQUFJMU4sYUFBYTtvQkFDZixNQUFNd08sV0FBV1IsYUFBYSxDQUFDVCxNQUFNO29CQUNyQ2hILE9BQU9pSSxZQUFZLE1BQU0sQ0FBQywwQ0FBMEMsRUFBRWpCLE1BQU0sQ0FBQztvQkFDN0UsSUFBSUYsa0JBQWtCbUIsVUFBVWxPLFVBQVU7d0JBQ3hDLE1BQU1tTyxhQUFhRCxXQUFXek87d0JBQzlCLGtEQUFrRDt3QkFFbEQsSUFBSWlOLG9CQUFvQnlCLFlBQVl6SCxLQUFLMEgsR0FBRyxDQUFDdEIsVUFBVSxHQUFHOzRCQUN4REEsUUFBUUEsUUFBUSxJQUFJLElBQUlxQixhQUFhQTt3QkFDckMsc0NBQXNDO3dCQUN4QztvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDQSxrQkFBa0I7SUFDcEI7SUFFQTtRQUNFLDRFQUE0RTtRQUM1RSx3R0FBd0c7UUFDeEcsK0VBQStFO1FBQy9FLHFGQUFxRjtRQUNyRixpRUFBaUU7UUFFakUsTUFBTUUsWUFBWXZCLFFBQVEsSUFBSSxJQUFJLENBQUM7UUFDbkMsSUFBSUcsUUFBUUgsUUFBUSxJQUFJa0IsbUJBQW1CRDtRQUMzQyxJQUFJTyxvQkFBb0I7UUFFeEIsNkJBQTZCO1FBQzdCLE1BQU8sS0FBTTtZQUNYLE1BQU1KLFdBQVdSLGFBQWEsQ0FBQ1QsTUFBTTtZQUNyQ2hILE9BQU9pSSxZQUFZLE1BQU0sQ0FBQywwQ0FBMEMsRUFBRWpCLE1BQU0sQ0FBQztZQUM3RSxNQUFNc0IsY0FBY25OLFlBQVk7Z0JBQzlCZ00sa0JBQWtCQztnQkFDbEJDLFlBQVlMO2dCQUNaMUssTUFBTTtZQUNSO1lBQ0EsTUFBTXVLLFFBQVF5QixjQUFjTDtZQUM1QiwyREFBMkQ7WUFFM0RJLHFCQUFxQnhCO1lBQ3JCRyxTQUFTb0I7WUFDVCxJQUFJcEIsUUFBUSxLQUFLQSxTQUFTSSxzQkFBc0I3RyxNQUFNLEVBQUU7Z0JBQ3REO1lBQ0Y7UUFDRjtRQUVBLGdFQUFnRTtRQUNoRSxNQUFNZ0ksY0FBYzlILEtBQUs4RyxHQUFHLENBQUM5RyxLQUFLMEgsR0FBRyxDQUFDdEIsUUFBUXBHLEtBQUswSCxHQUFHLENBQUNFO1FBQ3ZEeEIsUUFBUUEsUUFBUSxJQUFJLElBQUkwQixjQUFjQTtJQUN0QywrQ0FBK0M7SUFDL0Msa0JBQWtCO0lBQ3BCO0lBRUE7UUFDRSxvSEFBb0g7UUFFcEgsTUFBTUMsYUFBYTNCLFFBQVEsSUFBSWlCLGtCQUFrQkM7UUFDakQsSUFBSWYsUUFBUXdCO1FBQ1osTUFBT3hCLFNBQVMsS0FBS0EsUUFBUUksc0JBQXNCN0csTUFBTSxDQUFFO1lBQ3pELE1BQU1rSSxpQkFBaUJoSSxLQUFLMEgsR0FBRyxDQUFDdEIsU0FBU3BHLEtBQUswSCxHQUFHLENBQUNIO1lBQ2xELE1BQU1DLFdBQVdSLGFBQWEsQ0FBQ1QsTUFBTTtZQUNyQ2hILE9BQU9pSSxZQUFZLE1BQU0sQ0FBQywwQ0FBMEMsRUFBRWpCLE1BQU0sQ0FBQztZQUM3RSxNQUFNMEIsYUFBYVQsV0FBV1E7WUFDOUIsTUFBTUUsV0FBV3hOLFlBQVk7Z0JBQzNCZ00sa0JBQWtCQztnQkFDbEJDLFlBQVlMO2dCQUNaMUssTUFBTW9NO1lBQ1I7WUFDQSxJQUFJLENBQUM1QixrQkFBa0JtQixVQUFVVSxXQUFXO2dCQUMxQ1gsZ0JBQWdCQyxXQUFXVTtnQkFDM0JkLFVBQVUsQ0FBQ2IsTUFBTSxHQUFHMkI7Z0JBQ3BCLElBQUlYLGFBQWFZLFdBQVcsQ0FBQyxHQUFHQyxhQUFhLENBQUNwSSxLQUFLMEgsR0FBRyxDQUFDdEIsT0FBTytCLFdBQVcsQ0FBQyxJQUFJbE4sV0FBVztvQkFDdkZvTixTQUFTO2dCQUNYLE1BQU0sR0FBRztvQkFDUDtnQkFDRjtZQUNGO1lBQ0EsSUFBSWpDLFFBQVEsR0FBRztnQkFDYkc7WUFDRixPQUFPO2dCQUNMQTtZQUNGO1FBQ0Y7SUFDRjtJQUNBLG1EQUFtRDtJQUNuRCxpREFBaUQ7SUFDakQsa0JBQWtCO0lBRWxCLG1GQUFtRjtJQUNuRixnRkFBZ0Y7SUFDaEYsSUFBSUQsa0JBQWtCWSxZQUFZRSxhQUFhO1FBQzdDLHNFQUFzRTtRQUN0RSxpQ0FBaUM7UUFFakMsT0FBT0Y7SUFDVDtJQUNBO1FBQ0Usd0VBQXdFO1FBQ3hFLE1BQU1hLGFBQWEzQixRQUFRLElBQUlrQixtQkFBbUJEO1FBQ2xELE1BQU1HLFdBQVdSLGFBQWEsQ0FBQ2UsV0FBVztRQUMxQ3hJLE9BQU9pSSxZQUFZLE1BQU0sQ0FBQywwQ0FBMEMsRUFBRU8sV0FBVyxDQUFDO1FBQ2xGLE1BQU1FLGFBQWFULFdBQVdEO1FBQzlCLE1BQU1XLFdBQVd4TixZQUFZO1lBQzNCZ00sa0JBQWtCQztZQUNsQkMsWUFBWW1CO1lBQ1psTSxNQUFNb007UUFDUjtRQUVBLDhHQUE4RztRQUM5R2IsVUFBVSxDQUFDVyxXQUFXLEdBQUdHO1FBRXpCLGtHQUFrRztRQUNsRyxJQUFJLENBQUM3QixrQkFBa0I2QixVQUFVRCxhQUFhO1lBQzVDLElBQUlELGlCQUFpQkMsYUFBYUM7WUFDbEMsTUFBTUgsYUFBYTNCLFFBQVEsSUFBSWtCLG1CQUFtQkQ7WUFDbEQsSUFBSWQsUUFBUXdCO1lBQ1osTUFBT3hCLFNBQVMsS0FBS0EsUUFBUUksc0JBQXNCN0csTUFBTSxDQUFFO2dCQUN6RCxNQUFNMEgsV0FBV0osVUFBVSxDQUFDYixNQUFNO2dCQUNsQ2hILE9BQU9pSSxZQUFZLE1BQU0sQ0FBQywwQ0FBMEMsRUFBRWpCLE1BQU0sQ0FBQztnQkFDN0UsTUFBTTBCLGFBQWFULFdBQVdRO2dCQUM5QixNQUFNRSxXQUFXeE4sWUFBWTtvQkFDM0JnTSxrQkFBa0JDO29CQUNsQkMsWUFBWUw7b0JBQ1oxSyxNQUFNb007Z0JBQ1I7Z0JBQ0EsSUFBSSxDQUFDNUIsa0JBQWtCbUIsVUFBVVUsV0FBVztvQkFDMUNGLGtCQUFrQkUsV0FBV1Y7b0JBQzdCSixVQUFVLENBQUNiLE1BQU0sR0FBRzJCO2dCQUN0QjtnQkFDQSxJQUFJN0Isa0JBQWtCMkIsZ0JBQWdCLElBQUk7b0JBQ3hDO2dCQUNGO2dCQUNBLElBQUk1QixRQUFRLEdBQUc7b0JBQ2JHO2dCQUNGLE9BQU87b0JBQ0xBO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsbURBQW1EO0lBQ25ELGlEQUFpRDtJQUNqRCxrQkFBa0I7SUFFbEIsTUFBTStCLFlBQVlsQixXQUFXbUIsTUFBTSxDQUFDLENBQUNDLE9BQU8zTSxPQUFTQSxPQUFPMk0sT0FBTztJQUNuRSwwQ0FBMEM7SUFFMUMsNEZBQTRGO0lBQzVGLDBEQUEwRDtJQUMxRCxJQUFJLENBQUNuQyxrQkFBa0JpQyxXQUFXLE1BQU07UUFDdEMsc0VBQXNFO1FBQ3RFLGlDQUFpQztRQUVqQyxPQUFPcEI7SUFDVDtJQUVBLGlDQUFpQztJQUNqQyxPQUFPRTtBQUNUO0FBRUEsU0FBU3FCLGdDQUFnQ25PLE9BQU8sRUFBRW9PLFFBQVF4TCxRQUFRO0lBQ2hFLE9BQU95TCxNQUFNQyxJQUFJLENBQUNGLE1BQU1HLGdCQUFnQixDQUFDLENBQUMsbURBQW1ELEVBQUV2TyxRQUFRLEVBQUUsQ0FBQztBQUM1RztBQUVBLFNBQVN3Tyw0QkFBNEJ4TyxPQUFPLEVBQUVuQixFQUFFLEVBQUV1UCxRQUFReEwsUUFBUTtJQUNoRSxNQUFNNkwsVUFBVU4sZ0NBQWdDbk8sU0FBU29PO0lBQ3pELE1BQU1uQyxRQUFRd0MsUUFBUUMsU0FBUyxDQUFDQyxDQUFBQSxTQUFVQSxPQUFPQyxZQUFZLENBQUMsbUNBQW1DL1A7SUFDakcsT0FBT29OLFVBQVUsUUFBUUEsVUFBVSxLQUFLLElBQUlBLFFBQVE7QUFDdEQ7QUFFQSxTQUFTNEMsc0JBQXNCN08sT0FBTyxFQUFFOE8sWUFBWSxFQUFFQyxpQkFBaUI7SUFDckUsTUFBTTlDLFFBQVF1Qyw0QkFBNEJ4TyxTQUFTOE8sY0FBY0M7SUFDakUsT0FBTzlDLFNBQVMsT0FBTztRQUFDQTtRQUFPQSxRQUFRO0tBQUUsR0FBRztRQUFDLENBQUM7UUFBRyxDQUFDO0tBQUU7QUFDdEQ7QUFFQSxTQUFTK0MscUJBQXFCblEsRUFBRSxFQUFFb1EsY0FBY3JNLFFBQVE7SUFDdEQsSUFBSXNNO0lBQ0osdUNBQXVDO0lBQ3ZDLElBQUlELHVCQUF1QnpGLGVBQWUsQ0FBQ3lGLGdCQUFnQixRQUFRQSxnQkFBZ0IsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDQyxXQUFXRCxZQUFZRSxPQUFPLE1BQU0sUUFBUUQsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTRSxZQUFZLEtBQUt2USxJQUFJO1FBQzdNLE9BQU9vUTtJQUNUO0lBRUEscUJBQXFCO0lBQ3JCLE1BQU1uSCxVQUFVbUgsWUFBWUksYUFBYSxDQUFDLENBQUMsd0NBQXdDLEVBQUV4USxHQUFHLEVBQUUsQ0FBQztJQUMzRixJQUFJaUosU0FBUztRQUNYLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTd0gsdUJBQXVCelEsRUFBRSxFQUFFdVAsUUFBUXhMLFFBQVE7SUFDbEQsTUFBTWtGLFVBQVVzRyxNQUFNaUIsYUFBYSxDQUFDLENBQUMsOEJBQThCLEVBQUV4USxHQUFHLEVBQUUsQ0FBQztJQUMzRSxJQUFJaUosU0FBUztRQUNYLE9BQU9BO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTeUgsd0JBQXdCdlAsT0FBTyxFQUFFd1AsUUFBUSxFQUFFQyxXQUFXLEVBQUVyQixRQUFReEwsUUFBUTtJQUMvRSxJQUFJOE0sdUJBQXVCQyxvQkFBb0JDLGlCQUFpQkM7SUFDaEUsTUFBTWxCLFNBQVNXLHVCQUF1QkUsVUFBVXBCO0lBQ2hELE1BQU1LLFVBQVVOLGdDQUFnQ25PLFNBQVNvTztJQUN6RCxNQUFNbkMsUUFBUTBDLFNBQVNGLFFBQVFxQixPQUFPLENBQUNuQixVQUFVLENBQUM7SUFDbEQsTUFBTW9CLFdBQVcsQ0FBQ0wsd0JBQXdCLENBQUNDLHFCQUFxQkYsV0FBVyxDQUFDeEQsTUFBTSxNQUFNLFFBQVEwRCx1QkFBdUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsbUJBQW1COVEsRUFBRSxNQUFNLFFBQVE2USwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7SUFDdk8sTUFBTU0sVUFBVSxDQUFDSixrQkFBa0IsQ0FBQ0MsZUFBZUosV0FBVyxDQUFDeEQsUUFBUSxFQUFFLE1BQU0sUUFBUTRELGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhaFIsRUFBRSxNQUFNLFFBQVErUSxvQkFBb0IsS0FBSyxJQUFJQSxrQkFBa0I7SUFDdE0sT0FBTztRQUFDRztRQUFVQztLQUFRO0FBQzVCO0FBRUEsMkRBQTJEO0FBRTNELFNBQVNDLG9DQUFvQyxFQUMzQ0Msa0JBQWtCLEVBQ2xCQyxjQUFjLEVBQ2RuUSxPQUFPLEVBQ1BvUSxNQUFNLEVBQ05DLGNBQWMsRUFDZHRCLGlCQUFpQixFQUNqQnVCLFNBQVMsRUFDVjtJQUNDOVMsT0FBTztRQUNMK1MsaUNBQWlDO0lBQ25DO0lBQ0FuVCxVQUFVO1FBQ1IsSUFBSSxDQUFDMlIsbUJBQW1CO1lBQ3RCO1FBQ0Y7UUFDQSxNQUFNeUIsY0FBY0wsZUFBZS9SLE9BQU87UUFDMUM2RyxPQUFPdUwsYUFBYSxDQUFDLHNCQUFzQixDQUFDO1FBQzVDLE1BQU0sRUFDSkgsY0FBYyxFQUNmLEdBQUdHO1FBQ0osTUFBTUMsZUFBZXpCLHFCQUFxQmhQLFNBQVMrTztRQUNuRDlKLE9BQU93TCxnQkFBZ0IsTUFBTSxDQUFDLHVCQUF1QixFQUFFelEsUUFBUSxDQUFDLENBQUM7UUFDakUsTUFBTXlPLFVBQVVOLGdDQUFnQ25PLFNBQVMrTztRQUN6RDlKLE9BQU93SixTQUFTLENBQUMsc0NBQXNDLEVBQUV6TyxRQUFRLENBQUMsQ0FBQztRQUNuRSxNQUFNMFEsbUJBQW1CakMsUUFBUWtDLEdBQUcsQ0FBQ2hDLENBQUFBO1lBQ25DLE1BQU1hLFdBQVdiLE9BQU9DLFlBQVksQ0FBQztZQUNyQzNKLE9BQU91SyxVQUFVLENBQUMsZ0RBQWdELENBQUM7WUFDbkUsTUFBTSxDQUFDTyxVQUFVQyxRQUFRLEdBQUdULHdCQUF3QnZQLFNBQVN3UCxVQUFVYSxnQkFBZ0J0QjtZQUN2RixJQUFJZ0IsWUFBWSxRQUFRQyxXQUFXLE1BQU07Z0JBQ3ZDLE9BQU8sS0FBTztZQUNoQjtZQUNBLE1BQU1ZLFlBQVl6TixDQUFBQTtnQkFDaEIsSUFBSUEsTUFBTTBOLGdCQUFnQixFQUFFO29CQUMxQjtnQkFDRjtnQkFDQSxPQUFRMU4sTUFBTTJOLEdBQUc7b0JBQ2YsS0FBSzt3QkFDSDs0QkFDRTNOLE1BQU04RixjQUFjOzRCQUNwQixNQUFNZ0QsUUFBUW9FLGVBQWUzQixTQUFTLENBQUNxQyxDQUFBQSxZQUFhQSxVQUFVbFMsRUFBRSxLQUFLa1I7NEJBQ3JFLElBQUk5RCxTQUFTLEdBQUc7Z0NBQ2QsTUFBTThFLFlBQVlWLGNBQWMsQ0FBQ3BFLE1BQU07Z0NBQ3ZDaEgsT0FBTzhMLFdBQVcsQ0FBQyw4QkFBOEIsRUFBRTlFLE1BQU0sQ0FBQztnQ0FDMUQsTUFBTTFLLE9BQU82TyxNQUFNLENBQUNuRSxNQUFNO2dDQUMxQixNQUFNLEVBQ0p4TixnQkFBZ0IsQ0FBQyxFQUNqQkMsV0FBVyxFQUNYTSxVQUFVLENBQUMsRUFDWixHQUFHK1IsVUFBVXRRLFdBQVc7Z0NBQ3pCLElBQUljLFFBQVEsUUFBUTdDLGFBQWE7b0NBQy9CLE1BQU1vTyxhQUFhTCxvQkFBb0I7d0NBQ3JDWCxPQUFPQyxrQkFBa0J4SyxNQUFNOUMsaUJBQWlCTyxVQUFVUCxnQkFBZ0JBLGdCQUFnQjhDO3dDQUMxRm1MLGVBQWUwRDt3Q0FDZmhFLGtCQUFrQmlFLGVBQWVNLEdBQUcsQ0FBQ0ksQ0FBQUEsWUFBYUEsVUFBVXRRLFdBQVc7d0NBQ3ZFa00sY0FBY2tDLHNCQUFzQjdPLFNBQVN3UCxVQUFVVDt3Q0FDdkRuQyxZQUFZd0Q7d0NBQ1p2RCxTQUFTO29DQUNYO29DQUNBLElBQUl1RCxXQUFXdEQsWUFBWTt3Q0FDekJ3RCxVQUFVeEQ7b0NBQ1o7Z0NBQ0Y7NEJBQ0Y7NEJBQ0E7d0JBQ0Y7Z0JBQ0o7WUFDRjtZQUNBNkIsT0FBTzFELGdCQUFnQixDQUFDLFdBQVcyRjtZQUNuQyxPQUFPO2dCQUNMakMsT0FBTzVELG1CQUFtQixDQUFDLFdBQVc2RjtZQUN4QztRQUNGO1FBQ0EsT0FBTztZQUNMRixpQkFBaUJqSCxPQUFPLENBQUN1SCxDQUFBQSxrQkFBbUJBO1FBQzlDO0lBQ0YsR0FBRztRQUFDakM7UUFBbUJtQjtRQUFvQkM7UUFBZ0JuUTtRQUFTb1E7UUFBUUM7UUFBZ0JDO0tBQVU7QUFDeEc7QUFFQSxTQUFTVyxTQUFTQyxNQUFNLEVBQUVDLE1BQU07SUFDOUIsSUFBSUQsT0FBTzFMLE1BQU0sS0FBSzJMLE9BQU8zTCxNQUFNLEVBQUU7UUFDbkMsT0FBTztJQUNUO0lBQ0EsSUFBSyxJQUFJeUcsUUFBUSxHQUFHQSxRQUFRaUYsT0FBTzFMLE1BQU0sRUFBRXlHLFFBQVM7UUFDbEQsSUFBSWlGLE1BQU0sQ0FBQ2pGLE1BQU0sS0FBS2tGLE1BQU0sQ0FBQ2xGLE1BQU0sRUFBRTtZQUNuQyxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBLFNBQVNtRiw2QkFBNkJySixTQUFTLEVBQUU1RSxLQUFLO0lBQ3BELE1BQU1rTyxlQUFldEosY0FBYztJQUNuQyxNQUFNLEVBQ0p0RSxDQUFDLEVBQ0RFLENBQUMsRUFDRixHQUFHSCwwQkFBMEJMO0lBQzlCLE9BQU9rTyxlQUFlNU4sSUFBSUU7QUFDNUI7QUFFQSxTQUFTMk4sOEJBQThCbk8sS0FBSyxFQUFFMkwsWUFBWSxFQUFFL0csU0FBUyxFQUFFd0osZ0JBQWdCLEVBQUV4QyxpQkFBaUI7SUFDeEcsTUFBTXNDLGVBQWV0SixjQUFjO0lBQ25DLE1BQU15SixnQkFBZ0JsQyx1QkFBdUJSLGNBQWNDO0lBQzNEOUosT0FBT3VNLGVBQWUsQ0FBQyx1Q0FBdUMsRUFBRTFDLGFBQWEsQ0FBQyxDQUFDO0lBQy9FLE1BQU05TyxVQUFVd1IsY0FBYzVDLFlBQVksQ0FBQztJQUMzQzNKLE9BQU9qRixTQUFTLENBQUMsK0NBQStDLENBQUM7SUFDakUsSUFBSSxFQUNGeVIscUJBQXFCLEVBQ3RCLEdBQUdGO0lBQ0osTUFBTUcsaUJBQWlCTiw2QkFBNkJySixXQUFXNUU7SUFDL0QsTUFBTXNOLGVBQWV6QixxQkFBcUJoUCxTQUFTK087SUFDbkQ5SixPQUFPd0wsY0FBYyxDQUFDLCtCQUErQixFQUFFelEsUUFBUSxDQUFDLENBQUM7SUFDakUsTUFBTTJSLFlBQVlsQixhQUFhN0cscUJBQXFCO0lBQ3BELE1BQU1nSSxvQkFBb0JQLGVBQWVNLFVBQVVwTixLQUFLLEdBQUdvTixVQUFVbk4sTUFBTTtJQUMzRSxNQUFNcU4sZUFBZUgsaUJBQWlCRDtJQUN0QyxNQUFNSyxtQkFBbUJELGVBQWVELG9CQUFvQjtJQUM1RCxPQUFPRTtBQUNUO0FBRUEsd0VBQXdFO0FBQ3hFLFNBQVNDLHlCQUF5QjVPLEtBQUssRUFBRTJMLFlBQVksRUFBRS9HLFNBQVMsRUFBRXdKLGdCQUFnQixFQUFFUyxnQkFBZ0IsRUFBRWpELGlCQUFpQjtJQUNySCxJQUFJN0wsVUFBVUMsUUFBUTtRQUNwQixNQUFNa08sZUFBZXRKLGNBQWM7UUFDbkMsSUFBSStELFFBQVE7UUFDWixJQUFJM0ksTUFBTThPLFFBQVEsRUFBRTtZQUNsQm5HLFFBQVE7UUFDVixPQUFPLElBQUlrRyxvQkFBb0IsTUFBTTtZQUNuQ2xHLFFBQVFrRztRQUNWLE9BQU87WUFDTGxHLFFBQVE7UUFDVjtRQUNBLElBQUlvRyxXQUFXO1FBQ2YsT0FBUS9PLE1BQU0yTixHQUFHO1lBQ2YsS0FBSztnQkFDSG9CLFdBQVdiLGVBQWUsSUFBSXZGO2dCQUM5QjtZQUNGLEtBQUs7Z0JBQ0hvRyxXQUFXYixlQUFlLENBQUN2RixRQUFRO2dCQUNuQztZQUNGLEtBQUs7Z0JBQ0hvRyxXQUFXYixlQUFldkYsUUFBUTtnQkFDbEM7WUFDRixLQUFLO2dCQUNIb0csV0FBV2IsZUFBZSxJQUFJLENBQUN2RjtnQkFDL0I7WUFDRixLQUFLO2dCQUNIb0csV0FBVztnQkFDWDtZQUNGLEtBQUs7Z0JBQ0hBLFdBQVcsQ0FBQztnQkFDWjtRQUNKO1FBQ0EsT0FBT0E7SUFDVCxPQUFPO1FBQ0wsSUFBSVgsb0JBQW9CLE1BQU07WUFDNUIsT0FBTztRQUNUO1FBQ0EsT0FBT0QsOEJBQThCbk8sT0FBTzJMLGNBQWMvRyxXQUFXd0osa0JBQWtCeEM7SUFDekY7QUFDRjtBQUVBLGtEQUFrRDtBQUNsRCxTQUFTb0QsbUJBQW1CMUMsV0FBVyxFQUFFVyxNQUFNLEVBQUVnQyw0QkFBNEI7SUFDM0VoQyxPQUFPM0csT0FBTyxDQUFDLENBQUNsSSxNQUFNMEs7UUFDcEIsTUFBTThFLFlBQVl0QixXQUFXLENBQUN4RCxNQUFNO1FBQ3BDaEgsT0FBTzhMLFdBQVcsQ0FBQywrQkFBK0IsRUFBRTlFLE1BQU0sQ0FBQztRQUMzRCxNQUFNLEVBQ0p6TCxTQUFTLEVBQ1RDLFdBQVcsRUFDWDVCLElBQUl5QixPQUFPLEVBQ1osR0FBR3lRO1FBQ0osTUFBTSxFQUNKdFMsZ0JBQWdCLENBQUMsRUFDakJDLFdBQVcsRUFDWixHQUFHK0I7UUFDSixNQUFNNFIsbUJBQW1CRCw0QkFBNEIsQ0FBQzlSLFFBQVE7UUFDOUQsSUFBSStSLG9CQUFvQixRQUFROVEsU0FBUzhRLGtCQUFrQjtZQUN6REQsNEJBQTRCLENBQUM5UixRQUFRLEdBQUdpQjtZQUN4QyxNQUFNLEVBQ0p0QyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUkMsUUFBUSxFQUNULEdBQUdxQjtZQUNKLElBQUlyQixVQUFVO2dCQUNaQSxTQUFTb0MsTUFBTThRO1lBQ2pCO1lBQ0EsSUFBSTNULGVBQWdCTyxDQUFBQSxjQUFjQyxRQUFPLEdBQUk7Z0JBQzNDLElBQUlBLFlBQWFtVCxDQUFBQSxvQkFBb0IsUUFBUUEscUJBQXFCNVQsYUFBWSxLQUFNOEMsU0FBUzlDLGVBQWU7b0JBQzFHUztnQkFDRjtnQkFDQSxJQUFJRCxjQUFlb1QsQ0FBQUEsb0JBQW9CLFFBQVFBLHFCQUFxQjVULGFBQVksS0FBTThDLFNBQVM5QyxlQUFlO29CQUM1R1E7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLFNBQVNxVCxlQUFlNU4sQ0FBQyxFQUFFQyxDQUFDO0lBQzFCLElBQUlELEVBQUVjLE1BQU0sS0FBS2IsRUFBRWEsTUFBTSxFQUFFO1FBQ3pCLE9BQU87SUFDVCxPQUFPO1FBQ0wsSUFBSyxJQUFJeUcsUUFBUSxHQUFHQSxRQUFRdkgsRUFBRWMsTUFBTSxFQUFFeUcsUUFBUztZQUM3QyxJQUFJdkgsQ0FBQyxDQUFDdUgsTUFBTSxJQUFJdEgsQ0FBQyxDQUFDc0gsTUFBTSxFQUFFO2dCQUN4QixPQUFPO1lBQ1Q7UUFDRjtJQUNGO0lBQ0EsT0FBTztBQUNUO0FBRUEsOERBQThEO0FBRTlELCtEQUErRDtBQUMvRCxTQUFTc0cseUJBQXlCLEVBQ2hDNVQsV0FBVyxFQUNYNlQsU0FBUyxFQUNUcEMsTUFBTSxFQUNOVyxTQUFTLEVBQ1R6RSxVQUFVLEVBQ1ZtRyxZQUFZLENBQUMsRUFDZDtJQUNDLE1BQU1sUixPQUFPNk8sTUFBTSxDQUFDOUQsV0FBVztJQUMvQixJQUFJN0s7SUFDSixJQUFJRixRQUFRLE1BQU07UUFDaEIsNERBQTREO1FBQzVELDhFQUE4RTtRQUM5RUUsV0FBVzlDLGVBQWVnQyxZQUFZaEMsWUFBWWtQLFdBQVcsQ0FBQzRFLGFBQWE7SUFDN0UsT0FBTyxJQUFJMUIsVUFBVXZMLE1BQU0sS0FBSyxHQUFHO1FBQ2pDLHdFQUF3RTtRQUN4RS9ELFdBQVc7SUFDYixPQUFPO1FBQ0xBLFdBQVdGLEtBQUtzTSxXQUFXLENBQUM0RTtJQUM5QjtJQUNBLE9BQU87UUFDTEMsV0FBVztRQUNYalI7UUFDQWtSLFlBQVk7UUFDWiwrRUFBK0U7UUFDL0VDLFVBQVU7UUFDVix5REFBeUQ7UUFDekQsNENBQTRDO1FBQzVDQyxlQUFlTCxjQUFjLE9BQU8sU0FBUzdSO0lBQy9DO0FBQ0Y7QUFFQSxTQUFTbVMsU0FBU0MsUUFBUSxFQUFFQyxhQUFhLEVBQUU7SUFDekMsSUFBSUMsWUFBWTtJQUNoQixJQUFJQyxXQUFXLENBQUMsR0FBR0M7UUFDakIsSUFBSUYsY0FBYyxNQUFNO1lBQ3RCRyxhQUFhSDtRQUNmO1FBQ0FBLFlBQVlJLFdBQVc7WUFDckJOLFlBQVlJO1FBQ2QsR0FBR0g7SUFDTDtJQUNBLE9BQU9FO0FBQ1Q7QUFFQSxpR0FBaUc7QUFDakcsaURBQWlEO0FBQ2pELDRFQUE0RTtBQUM1RSwyQ0FBMkM7QUFDM0MsU0FBU0kseUJBQXlCQyxhQUFhO0lBQzdDLElBQUk7UUFDRixJQUFJLE9BQU9DLGlCQUFpQixhQUFhO1lBQ3ZDLHFDQUFxQztZQUNyQ0QsY0FBY0UsT0FBTyxHQUFHQyxDQUFBQTtnQkFDdEIsT0FBT0YsYUFBYUMsT0FBTyxDQUFDQztZQUM5QjtZQUNBSCxjQUFjSSxPQUFPLEdBQUcsQ0FBQ0QsTUFBTUU7Z0JBQzdCSixhQUFhRyxPQUFPLENBQUNELE1BQU1FO1lBQzdCO1FBQ0YsT0FBTztZQUNMLE1BQU0sSUFBSWpVLE1BQU07UUFDbEI7SUFDRixFQUFFLE9BQU82TCxPQUFPO1FBQ2QxSyxRQUFRMEssS0FBSyxDQUFDQTtRQUNkK0gsY0FBY0UsT0FBTyxHQUFHLElBQU07UUFDOUJGLGNBQWNJLE9BQU8sR0FBRyxLQUFPO0lBQ2pDO0FBQ0Y7QUFFQSxTQUFTRSxpQkFBaUJDLFVBQVU7SUFDbEMsT0FBTyxDQUFDLHVCQUF1QixFQUFFQSxXQUFXLENBQUM7QUFDL0M7QUFFQSw2RkFBNkY7QUFDN0YsK0RBQStEO0FBQy9ELHlFQUF5RTtBQUN6RSwyRkFBMkY7QUFDM0YsU0FBU0MsWUFBWUMsTUFBTTtJQUN6QixPQUFPQSxPQUFPckQsR0FBRyxDQUFDc0QsQ0FBQUE7UUFDaEIsTUFBTSxFQUNKeFQsV0FBVyxFQUNYNUIsRUFBRSxFQUNGNkIsYUFBYSxFQUNidEIsS0FBSyxFQUNOLEdBQUc2VTtRQUNKLElBQUl2VCxlQUFlO1lBQ2pCLE9BQU83QjtRQUNULE9BQU87WUFDTCxPQUFPTyxRQUFRLENBQUMsRUFBRUEsTUFBTSxDQUFDLEVBQUU4VSxLQUFLQyxTQUFTLENBQUMxVCxhQUFhLENBQUMsR0FBR3lULEtBQUtDLFNBQVMsQ0FBQzFUO1FBQzVFO0lBQ0YsR0FBRzJULElBQUksQ0FBQyxDQUFDMVAsR0FBR0MsSUFBTUQsRUFBRW9KLGFBQWEsQ0FBQ25KLElBQUkwUCxJQUFJLENBQUM7QUFDN0M7QUFDQSxTQUFTQyw4QkFBOEJSLFVBQVUsRUFBRVMsT0FBTztJQUN4RCxJQUFJO1FBQ0YsTUFBTUMsZ0JBQWdCWCxpQkFBaUJDO1FBQ3ZDLE1BQU1XLGFBQWFGLFFBQVFkLE9BQU8sQ0FBQ2U7UUFDbkMsSUFBSUMsWUFBWTtZQUNkLE1BQU1DLFNBQVNSLEtBQUtTLEtBQUssQ0FBQ0Y7WUFDMUIsSUFBSSxPQUFPQyxXQUFXLFlBQVlBLFVBQVUsTUFBTTtnQkFDaEQsT0FBT0E7WUFDVDtRQUNGO0lBQ0YsRUFBRSxPQUFPbEosT0FBTyxDQUFDO0lBQ2pCLE9BQU87QUFDVDtBQUNBLFNBQVNvSixvQkFBb0JkLFVBQVUsRUFBRUUsTUFBTSxFQUFFYSx3QkFBd0IsRUFBRUMsS0FBSyxFQUFFUCxPQUFPO0lBQ3ZGLElBQUlRO0lBQ0osTUFBTVAsZ0JBQWdCWCxpQkFBaUJDO0lBQ3ZDLE1BQU1rQixXQUFXakIsWUFBWUM7SUFDN0IsTUFBTS9SLFFBQVEsQ0FBQzhTLHlCQUF5QlQsOEJBQThCUixZQUFZUyxRQUFPLE1BQU8sUUFBUVEsMkJBQTJCLEtBQUssSUFBSUEseUJBQXlCLENBQUM7SUFDdEs5UyxLQUFLLENBQUMrUyxTQUFTLEdBQUc7UUFDaEJDLGVBQWVDLE9BQU9DLFdBQVcsQ0FBQ04seUJBQXlCTyxPQUFPO1FBQ2xFaEYsUUFBUTBFO0lBQ1Y7SUFDQSxJQUFJO1FBQ0ZQLFFBQVFaLE9BQU8sQ0FBQ2EsZUFBZU4sS0FBS0MsU0FBUyxDQUFDbFM7SUFDaEQsRUFBRSxPQUFPdUosT0FBTztRQUNkMUssUUFBUTBLLEtBQUssQ0FBQ0E7SUFDaEI7QUFDRjtBQUVBLFNBQVM2Six5QkFBeUIsRUFDaENqSixrQkFBa0JDLHFCQUFxQixFQUN2Qy9MLE9BQU8sRUFDUGdNLFVBQVUsRUFDWDtJQUNDO1FBQ0UsTUFBTWdKLFdBQVcsRUFBRTtRQUNuQixNQUFNbEosbUJBQW1CQyxxQkFBcUIsQ0FBQ0MsV0FBVztRQUMxRHJILE9BQU9tSCxrQkFBa0IsQ0FBQyxxQ0FBcUMsRUFBRUUsV0FBVyxDQUFDO1FBQzdFLE1BQU0sRUFDSjdOLGdCQUFnQixDQUFDLEVBQ2pCQyxjQUFjLEtBQUssRUFDbkJDLFdBQVcsRUFDWEksVUFBVSxHQUFHLEVBQ2JDLFVBQVUsQ0FBQyxFQUNaLEdBQUdvTjtRQUNKLElBQUlwTixVQUFVRCxTQUFTO1lBQ3JCdVcsU0FBU3RPLElBQUksQ0FBQyxDQUFDLFVBQVUsRUFBRWhJLFFBQVEsd0NBQXdDLEVBQUVELFFBQVEsRUFBRSxDQUFDO1FBQzFGO1FBQ0EsSUFBSUosZUFBZSxNQUFNO1lBQ3ZCLElBQUlBLGNBQWMsR0FBRztnQkFDbkIyVyxTQUFTdE8sSUFBSSxDQUFDO1lBQ2hCLE9BQU8sSUFBSXJJLGNBQWNLLFdBQVksRUFBQ04sZUFBZUMsZ0JBQWdCRixhQUFZLEdBQUk7Z0JBQ25GNlcsU0FBU3RPLElBQUksQ0FBQztZQUNoQjtZQUNBLElBQUlySSxjQUFjLEtBQUs7Z0JBQ3JCMlcsU0FBU3RPLElBQUksQ0FBQztZQUNoQixPQUFPLElBQUlySSxjQUFjSSxTQUFTO2dCQUNoQ3VXLFNBQVN0TyxJQUFJLENBQUM7WUFDaEI7UUFDRjtRQUNBLElBQUl2SSxnQkFBZ0JPLFNBQVM7WUFDM0JzVyxTQUFTdE8sSUFBSSxDQUFDO1FBQ2hCO1FBQ0EsSUFBSXNPLFNBQVM5UCxNQUFNLEdBQUcsR0FBRztZQUN2QixNQUFNa08sT0FBT3BULFdBQVcsT0FBTyxDQUFDLE9BQU8sRUFBRUEsUUFBUSxDQUFDLENBQUMsR0FBRztZQUN0RFEsUUFBUUMsSUFBSSxDQUFDLENBQUMsRUFBRTJTLEtBQUssa0NBQWtDLEVBQUU0QixTQUFTakIsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUM5RSxPQUFPO1FBQ1Q7SUFDRjtJQUNBLE9BQU87QUFDVDtBQUVBLHlFQUF5RTtBQUN6RSxTQUFTa0IseUJBQXlCLEVBQ2hDbkYsUUFBUXhELFVBQVUsRUFDbEJSLGdCQUFnQixFQUNqQjtJQUNDLE1BQU1VLGFBQWE7V0FBSUY7S0FBVztJQUNsQyxNQUFNNEksc0JBQXNCMUksV0FBV21CLE1BQU0sQ0FBQyxDQUFDd0gsYUFBYXJYLFVBQVlxWCxjQUFjclgsU0FBUztJQUUvRiwrQkFBK0I7SUFDL0IsSUFBSTBPLFdBQVd0SCxNQUFNLEtBQUs0RyxpQkFBaUI1RyxNQUFNLEVBQUU7UUFDakQsTUFBTTdGLE1BQU0sQ0FBQyxRQUFRLEVBQUV5TSxpQkFBaUI1RyxNQUFNLENBQUMsZUFBZSxFQUFFc0gsV0FBVzZELEdBQUcsQ0FBQ3BQLENBQUFBLE9BQVEsQ0FBQyxFQUFFQSxLQUFLLENBQUMsQ0FBQyxFQUFFOFMsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNqSCxPQUFPLElBQUksQ0FBQ3RJLGtCQUFrQnlKLHFCQUFxQixNQUFNO1FBQ3ZELHdGQUF3RjtRQUN4RixzQ0FBc0M7UUFDdEM7WUFDRTFVLFFBQVFDLElBQUksQ0FBQyxDQUFDLG9DQUFvQyxFQUFFK0wsV0FBVzZELEdBQUcsQ0FBQ3BQLENBQUFBLE9BQVEsQ0FBQyxFQUFFQSxLQUFLLENBQUMsQ0FBQyxFQUFFOFMsSUFBSSxDQUFDLE1BQU0sdUNBQXVDLENBQUM7UUFDNUk7UUFDQSxJQUFLLElBQUlwSSxRQUFRLEdBQUdBLFFBQVFHLGlCQUFpQjVHLE1BQU0sRUFBRXlHLFFBQVM7WUFDNUQsTUFBTTBCLGFBQWFiLFVBQVUsQ0FBQ2IsTUFBTTtZQUNwQ2hILE9BQU8wSSxjQUFjLE1BQU0sQ0FBQywrQkFBK0IsRUFBRTFCLE1BQU0sQ0FBQztZQUNwRSxNQUFNMkIsV0FBVyxNQUFNNEgsc0JBQXNCN0g7WUFDN0NiLFVBQVUsQ0FBQ2IsTUFBTSxHQUFHMkI7UUFDdEI7SUFDRjtJQUNBLElBQUk4SCxnQkFBZ0I7SUFFcEIsMEVBQTBFO0lBQzFFLElBQUssSUFBSXpKLFFBQVEsR0FBR0EsUUFBUUcsaUJBQWlCNUcsTUFBTSxFQUFFeUcsUUFBUztRQUM1RCxNQUFNMEIsYUFBYWIsVUFBVSxDQUFDYixNQUFNO1FBQ3BDaEgsT0FBTzBJLGNBQWMsTUFBTSxDQUFDLCtCQUErQixFQUFFMUIsTUFBTSxDQUFDO1FBQ3BFLE1BQU0yQixXQUFXeE4sWUFBWTtZQUMzQmdNO1lBQ0FFLFlBQVlMO1lBQ1oxSyxNQUFNb007UUFDUjtRQUNBLElBQUlBLGNBQWNDLFVBQVU7WUFDMUI4SCxpQkFBaUIvSCxhQUFhQztZQUM5QmQsVUFBVSxDQUFDYixNQUFNLEdBQUcyQjtRQUN0QjtJQUNGO0lBRUEscUZBQXFGO0lBQ3JGLDBFQUEwRTtJQUMxRSxJQUFJLENBQUM3QixrQkFBa0IySixlQUFlLElBQUk7UUFDeEMsSUFBSyxJQUFJekosUUFBUSxHQUFHQSxRQUFRRyxpQkFBaUI1RyxNQUFNLEVBQUV5RyxRQUFTO1lBQzVELE1BQU1pQixXQUFXSixVQUFVLENBQUNiLE1BQU07WUFDbENoSCxPQUFPaUksWUFBWSxNQUFNLENBQUMsK0JBQStCLEVBQUVqQixNQUFNLENBQUM7WUFDbEUsTUFBTTBCLGFBQWFULFdBQVd3STtZQUM5QixNQUFNOUgsV0FBV3hOLFlBQVk7Z0JBQzNCZ007Z0JBQ0FFLFlBQVlMO2dCQUNaMUssTUFBTW9NO1lBQ1I7WUFDQSxJQUFJVCxhQUFhVSxVQUFVO2dCQUN6QjhILGlCQUFpQjlILFdBQVdWO2dCQUM1QkosVUFBVSxDQUFDYixNQUFNLEdBQUcyQjtnQkFFcEIseUNBQXlDO2dCQUN6QyxJQUFJN0Isa0JBQWtCMkosZUFBZSxJQUFJO29CQUN2QztnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU81STtBQUNUO0FBRUEsTUFBTTZJLGtDQUFrQztBQUN4QyxNQUFNQyxpQkFBaUI7SUFDckJuQyxTQUFTQyxDQUFBQTtRQUNQSix5QkFBeUJzQztRQUN6QixPQUFPQSxlQUFlbkMsT0FBTyxDQUFDQztJQUNoQztJQUNBQyxTQUFTLENBQUNELE1BQU1FO1FBQ2ROLHlCQUF5QnNDO1FBQ3pCQSxlQUFlakMsT0FBTyxDQUFDRCxNQUFNRTtJQUMvQjtBQUNGO0FBQ0EsTUFBTWlDLGNBQWMsQ0FBQztBQUNyQixTQUFTQywyQkFBMkIsRUFDbENoQyxhQUFhLElBQUksRUFDakJ4VixRQUFRLEVBQ1JDLFdBQVdDLHFCQUFxQixFQUFFLEVBQ2xDdUosU0FBUyxFQUNUbkosWUFBWSxFQUNaQyxJQUFJQyxjQUFjLElBQUksRUFDdEJpWCxXQUFXLElBQUksRUFDZi9ELG1CQUFtQixJQUFJLEVBQ3ZCdUMsVUFBVXFCLGNBQWMsRUFDeEJ2VyxPQUFPQyxjQUFjLEVBQ3JCQyxTQUFTQyxPQUFPLEtBQUssRUFDckIsR0FBR0MsTUFDSjtJQUNDLE1BQU1PLFVBQVVoQyxZQUFZYztJQUM1QixNQUFNa1gsdUJBQXVCeFksT0FBTztJQUNwQyxNQUFNLENBQUNnVixXQUFXeUQsYUFBYSxHQUFHeFksU0FBUztJQUMzQyxNQUFNLENBQUMyUyxRQUFRRSxVQUFVLEdBQUc3UyxTQUFTLEVBQUU7SUFDdkMsTUFBTXlZLGtDQUFrQzFZLE9BQU8sQ0FBQztJQUNoRCxNQUFNMlksNkJBQTZCM1ksT0FBTyxJQUFJZ0s7SUFDOUMsTUFBTTRPLGVBQWU1WSxPQUFPO0lBQzVCLE1BQU0wUyxxQkFBcUIxUyxPQUFPO1FBQ2hDc1c7UUFDQS9MO1FBQ0F5SztRQUNBM1QsSUFBSW1CO1FBQ0pnUztRQUNBK0Q7UUFDQXhCO0lBQ0Y7SUFDQSxNQUFNcEUsaUJBQWlCM1MsT0FBTztRQUM1QjRTO1FBQ0FDLGdCQUFnQixFQUFFO1FBQ2xCZ0csdUJBQXVCO0lBQ3pCO0lBQ0EsTUFBTXpWLGlCQUFpQnBELE9BQU87UUFDNUI4WSx5QkFBeUI7UUFDekJDLCtCQUErQjtRQUMvQkMsY0FBYyxFQUFFO0lBQ2xCO0lBQ0FuWixvQkFBb0J1QixjQUFjLElBQU87WUFDdkNzQyxPQUFPLElBQU1nUCxtQkFBbUI5UixPQUFPLENBQUNTLEVBQUU7WUFDMUM0WCxXQUFXO2dCQUNULE1BQU0sRUFDSnJHLE1BQU0sRUFDUCxHQUFHRCxlQUFlL1IsT0FBTztnQkFDMUIsT0FBT2dTO1lBQ1Q7WUFDQUUsV0FBV29HLENBQUFBO2dCQUNULE1BQU0sRUFDSlgsUUFBUSxFQUNULEdBQUc3RixtQkFBbUI5UixPQUFPO2dCQUM5QixNQUFNLEVBQ0pnUyxRQUFReEQsVUFBVSxFQUNsQnlELGNBQWMsRUFDZixHQUFHRixlQUFlL1IsT0FBTztnQkFDMUIsTUFBTXVZLGFBQWFwQix5QkFBeUI7b0JBQzFDbkYsUUFBUXNHO29CQUNSdEssa0JBQWtCaUUsZUFBZU0sR0FBRyxDQUFDSSxDQUFBQSxZQUFhQSxVQUFVdFEsV0FBVztnQkFDekU7Z0JBQ0EsSUFBSSxDQUFDd1EsU0FBU3JFLFlBQVkrSixhQUFhO29CQUNyQ3JHLFVBQVVxRztvQkFDVnhHLGVBQWUvUixPQUFPLENBQUNnUyxNQUFNLEdBQUd1RztvQkFDaEMsSUFBSVosVUFBVTt3QkFDWkEsU0FBU1k7b0JBQ1g7b0JBQ0F4RSxtQkFBbUI5QixnQkFBZ0JzRyxZQUFZVCxnQ0FBZ0M5WCxPQUFPO2dCQUN4RjtZQUNGO1FBQ0YsSUFBSSxFQUFFO0lBQ042UixvQ0FBb0M7UUFDbENDO1FBQ0FDO1FBQ0FuUTtRQUNBb1E7UUFDQUMsZ0JBQWdCRixlQUFlL1IsT0FBTyxDQUFDaVMsY0FBYztRQUNyREM7UUFDQXZCLG1CQUFtQmlILHFCQUFxQjVYLE9BQU87SUFDakQ7SUFDQWhCLFVBQVU7UUFDUixNQUFNLEVBQ0ppVCxjQUFjLEVBQ2YsR0FBR0YsZUFBZS9SLE9BQU87UUFFMUIsZ0dBQWdHO1FBQ2hHLElBQUkwVixZQUFZO1lBQ2QsSUFBSTFELE9BQU81SyxNQUFNLEtBQUssS0FBSzRLLE9BQU81SyxNQUFNLEtBQUs2SyxlQUFlN0ssTUFBTSxFQUFFO2dCQUNsRTtZQUNGO1lBQ0EsSUFBSW9SLGdCQUFnQmYsV0FBVyxDQUFDL0IsV0FBVztZQUUzQywrQ0FBK0M7WUFDL0MsSUFBSThDLGlCQUFpQixNQUFNO2dCQUN6QkEsZ0JBQWdCOUQsU0FBUzhCLHFCQUFxQmU7Z0JBQzlDRSxXQUFXLENBQUMvQixXQUFXLEdBQUc4QztZQUM1QjtZQUVBLCtEQUErRDtZQUMvRCxvR0FBb0c7WUFDcEcsTUFBTUMsdUJBQXVCO21CQUFJeEc7YUFBZTtZQUNoRCxNQUFNeUcsaUNBQWlDLElBQUl0UCxJQUFJMk8sMkJBQTJCL1gsT0FBTztZQUNqRndZLGNBQWM5QyxZQUFZK0Msc0JBQXNCQyxnQ0FBZ0MxRyxRQUFRbUU7UUFDMUY7SUFDRixHQUFHO1FBQUNUO1FBQVkxRDtRQUFRbUU7S0FBUTtJQUVoQyxlQUFlO0lBQ2ZuWCxVQUFVO1FBQ1I7WUFDRSxNQUFNLEVBQ0ppVCxjQUFjLEVBQ2YsR0FBR0YsZUFBZS9SLE9BQU87WUFDMUIsTUFBTSxFQUNKa1ksdUJBQXVCLEVBQ3ZCQyw2QkFBNkIsRUFDN0JDLFlBQVksRUFDYixHQUFHNVYsZUFBZXhDLE9BQU87WUFDMUIsSUFBSSxDQUFDa1kseUJBQXlCO2dCQUM1QixNQUFNUyxXQUFXMUcsZUFBZU0sR0FBRyxDQUFDLENBQUMsRUFDbkM5UixFQUFFLEVBQ0gsR0FBS0E7Z0JBQ04rQixlQUFleEMsT0FBTyxDQUFDb1ksWUFBWSxHQUFHTztnQkFDdEMsTUFBTUMsb0JBQW9CUixhQUFhaFIsTUFBTSxHQUFHLEtBQUssQ0FBQ3lMLFNBQVN1RixjQUFjTztnQkFDN0UsSUFBSUMsbUJBQW1CO29CQUNyQixJQUFJM0csZUFBZTRHLElBQUksQ0FBQyxDQUFDLEVBQ3ZCdlcsYUFBYSxFQUNidEIsS0FBSyxFQUNOLEdBQUssQ0FBQ3NCLGlCQUFpQnRCLFNBQVMsT0FBTzt3QkFDdEN3QixlQUFleEMsT0FBTyxDQUFDa1ksdUJBQXVCLEdBQUc7d0JBQ2pEeFYsUUFBUUMsSUFBSSxDQUFDLENBQUMsa0ZBQWtGLENBQUM7b0JBQ25HO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJLENBQUN3ViwrQkFBK0I7Z0JBQ2xDLE1BQU1uSyxtQkFBbUJpRSxlQUFlTSxHQUFHLENBQUNJLENBQUFBLFlBQWFBLFVBQVV0USxXQUFXO2dCQUM5RSxJQUFLLElBQUk2TCxhQUFhLEdBQUdBLGFBQWFGLGlCQUFpQjVHLE1BQU0sRUFBRThHLGFBQWM7b0JBQzNFLE1BQU15RSxZQUFZVixjQUFjLENBQUMvRCxXQUFXO29CQUM1Q3JILE9BQU84TCxXQUFXLENBQUMsK0JBQStCLEVBQUV6RSxXQUFXLENBQUM7b0JBQ2hFLE1BQU00SyxVQUFVN0IseUJBQXlCO3dCQUN2Q2pKO3dCQUNBOUwsU0FBU3lRLFVBQVVsUyxFQUFFO3dCQUNyQnlOO29CQUNGO29CQUNBLElBQUksQ0FBQzRLLFNBQVM7d0JBQ1p0VyxlQUFleEMsT0FBTyxDQUFDbVksNkJBQTZCLEdBQUc7d0JBQ3ZEO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsNkRBQTZEO0lBQzdELE1BQU0zVyxnQkFBZ0IxQyxZQUFZNlQsQ0FBQUE7UUFDaEMsTUFBTSxFQUNKZ0YsUUFBUSxFQUNULEdBQUc3RixtQkFBbUI5UixPQUFPO1FBQzlCLE1BQU0sRUFDSmdTLFFBQVF4RCxVQUFVLEVBQ2xCeUQsY0FBYyxFQUNmLEdBQUdGLGVBQWUvUixPQUFPO1FBQzFCLElBQUkyUyxVQUFVdFEsV0FBVyxDQUFDL0IsV0FBVyxFQUFFO1lBQ3JDLE1BQU0yTix3QkFBd0JnRSxlQUFlTSxHQUFHLENBQUNJLENBQUFBLFlBQWFBLFVBQVV0USxXQUFXO1lBQ25GLE1BQU0sRUFDSmhDLGdCQUFnQixDQUFDLEVBQ2pCMFksU0FBUyxFQUNUeEssWUFBWSxFQUNiLEdBQUd5SyxnQkFBZ0IvRyxnQkFBZ0JVLFdBQVduRTtZQUMvQzNILE9BQU9rUyxhQUFhLE1BQU0sQ0FBQyxnQ0FBZ0MsRUFBRXBHLFVBQVVsUyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzVFLElBQUlzWSxjQUFjMVksZUFBZTtnQkFDL0IsOEJBQThCO2dCQUM5QixtRUFBbUU7Z0JBQ25FMFgsMkJBQTJCL1gsT0FBTyxDQUFDbUssR0FBRyxDQUFDd0ksVUFBVWxTLEVBQUUsRUFBRXNZO2dCQUNyRCxNQUFNRSxjQUFjQyxtQkFBbUJqSCxnQkFBZ0JVLGVBQWVWLGVBQWU3SyxNQUFNLEdBQUc7Z0JBQzlGLE1BQU1zRyxRQUFRdUwsY0FBY0YsWUFBWTFZLGdCQUFnQkEsZ0JBQWdCMFk7Z0JBQ3hFLE1BQU1ySyxhQUFhTCxvQkFBb0I7b0JBQ3JDWDtvQkFDQVksZUFBZUU7b0JBQ2ZSLGtCQUFrQkM7b0JBQ2xCTTtvQkFDQUM7b0JBQ0FDLFNBQVM7Z0JBQ1g7Z0JBQ0EsSUFBSSxDQUFDeUYsZUFBZTFGLFlBQVlFLGFBQWE7b0JBQzNDd0QsVUFBVXhEO29CQUNWcUQsZUFBZS9SLE9BQU8sQ0FBQ2dTLE1BQU0sR0FBR3REO29CQUNoQyxJQUFJaUosVUFBVTt3QkFDWkEsU0FBU2pKO29CQUNYO29CQUNBcUYsbUJBQW1COUIsZ0JBQWdCdkQsWUFBWW9KLGdDQUFnQzlYLE9BQU87Z0JBQ3hGO1lBQ0Y7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLDZEQUE2RDtJQUM3RCxNQUFNeUIsY0FBYzNDLFlBQVk2VCxDQUFBQTtRQUM5QixNQUFNLEVBQ0pnRixRQUFRLEVBQ1QsR0FBRzdGLG1CQUFtQjlSLE9BQU87UUFDOUIsTUFBTSxFQUNKZ1MsUUFBUXhELFVBQVUsRUFDbEJ5RCxjQUFjLEVBQ2YsR0FBR0YsZUFBZS9SLE9BQU87UUFDMUIsSUFBSTJTLFVBQVV0USxXQUFXLENBQUMvQixXQUFXLEVBQUU7WUFDckMsTUFBTTJOLHdCQUF3QmdFLGVBQWVNLEdBQUcsQ0FBQ0ksQ0FBQUEsWUFBYUEsVUFBVXRRLFdBQVc7WUFDbkYsTUFBTSxFQUNKaEMsZ0JBQWdCLENBQUMsRUFDakIwWSxTQUFTLEVBQ1RuWSxVQUFVLENBQUMsRUFDWDJOLFlBQVksRUFDYixHQUFHeUssZ0JBQWdCL0csZ0JBQWdCVSxXQUFXbkU7WUFDL0MsSUFBSXVLLGNBQWMxWSxlQUFlO2dCQUMvQiw4RUFBOEU7Z0JBQzlFLE1BQU04WSxnQkFBZ0JwQiwyQkFBMkIvWCxPQUFPLENBQUNrSyxHQUFHLENBQUN5SSxVQUFVbFMsRUFBRTtnQkFDekUsTUFBTTJZLFdBQVdELGlCQUFpQixRQUFRQSxpQkFBaUJ2WSxVQUFVdVksZ0JBQWdCdlk7Z0JBQ3JGLE1BQU1xWSxjQUFjQyxtQkFBbUJqSCxnQkFBZ0JVLGVBQWVWLGVBQWU3SyxNQUFNLEdBQUc7Z0JBQzlGLE1BQU1zRyxRQUFRdUwsY0FBY0YsWUFBWUssV0FBV0EsV0FBV0w7Z0JBQzlELE1BQU1ySyxhQUFhTCxvQkFBb0I7b0JBQ3JDWDtvQkFDQVksZUFBZUU7b0JBQ2ZSLGtCQUFrQkM7b0JBQ2xCTTtvQkFDQUM7b0JBQ0FDLFNBQVM7Z0JBQ1g7Z0JBQ0EsSUFBSSxDQUFDeUYsZUFBZTFGLFlBQVlFLGFBQWE7b0JBQzNDd0QsVUFBVXhEO29CQUNWcUQsZUFBZS9SLE9BQU8sQ0FBQ2dTLE1BQU0sR0FBR3REO29CQUNoQyxJQUFJaUosVUFBVTt3QkFDWkEsU0FBU2pKO29CQUNYO29CQUNBcUYsbUJBQW1COUIsZ0JBQWdCdkQsWUFBWW9KLGdDQUFnQzlYLE9BQU87Z0JBQ3hGO1lBQ0Y7UUFDRjtJQUNGLEdBQUcsRUFBRTtJQUVMLDZEQUE2RDtJQUM3RCxNQUFNMEIsZUFBZTVDLFlBQVk2VCxDQUFBQTtRQUMvQixNQUFNLEVBQ0pYLE1BQU0sRUFDTkMsY0FBYyxFQUNmLEdBQUdGLGVBQWUvUixPQUFPO1FBQzFCLE1BQU0sRUFDSitZLFNBQVMsRUFDVixHQUFHQyxnQkFBZ0IvRyxnQkFBZ0JVLFdBQVdYO1FBQy9DbkwsT0FBT2tTLGFBQWEsTUFBTSxDQUFDLGdDQUFnQyxFQUFFcEcsVUFBVWxTLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDNUUsT0FBT3NZO0lBQ1QsR0FBRyxFQUFFO0lBRUwscURBQXFEO0lBQ3JELE1BQU1wWCxnQkFBZ0I3QyxZQUFZLENBQUM2VCxXQUFXcFM7UUFDNUMsTUFBTSxFQUNKMFIsY0FBYyxFQUNmLEdBQUdGLGVBQWUvUixPQUFPO1FBQzFCLE1BQU1rTyxhQUFhZ0wsbUJBQW1CakgsZ0JBQWdCVTtRQUN0RCxPQUFPd0IseUJBQXlCO1lBQzlCNVQ7WUFDQTZUO1lBQ0FwQztZQUNBVyxXQUFXVjtZQUNYL0Q7UUFDRjtJQUNGLEdBQUc7UUFBQ2tHO1FBQVdwQztLQUFPO0lBRXRCLDZEQUE2RDtJQUM3RCxNQUFNblEsbUJBQW1CL0MsWUFBWTZULENBQUFBO1FBQ25DLE1BQU0sRUFDSlgsTUFBTSxFQUNOQyxjQUFjLEVBQ2YsR0FBR0YsZUFBZS9SLE9BQU87UUFDMUIsTUFBTSxFQUNKSyxnQkFBZ0IsQ0FBQyxFQUNqQkMsV0FBVyxFQUNYeVksU0FBUyxFQUNWLEdBQUdDLGdCQUFnQi9HLGdCQUFnQlUsV0FBV1g7UUFDL0MsT0FBTzFSLGdCQUFnQixRQUFReVksY0FBYzFZO0lBQy9DLEdBQUcsRUFBRTtJQUVMLDZEQUE2RDtJQUM3RCxNQUFNZ1osa0JBQWtCdmEsWUFBWTZULENBQUFBO1FBQ2xDLE1BQU0sRUFDSlgsTUFBTSxFQUNOQyxjQUFjLEVBQ2YsR0FBR0YsZUFBZS9SLE9BQU87UUFDMUIsTUFBTSxFQUNKSyxnQkFBZ0IsQ0FBQyxFQUNqQkMsV0FBVyxFQUNYeVksU0FBUyxFQUNWLEdBQUdDLGdCQUFnQi9HLGdCQUFnQlUsV0FBV1g7UUFDL0NuTCxPQUFPa1MsYUFBYSxNQUFNLENBQUMsZ0NBQWdDLEVBQUVwRyxVQUFVbFMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM1RSxPQUFPLENBQUNILGVBQWV5WSxZQUFZMVk7SUFDckMsR0FBRyxFQUFFO0lBQ0wsTUFBTTBCLGdCQUFnQmpELFlBQVk2VCxDQUFBQTtRQUNoQyxNQUFNLEVBQ0pWLGNBQWMsRUFDZixHQUFHRixlQUFlL1IsT0FBTztRQUMxQmlTLGVBQWVySixJQUFJLENBQUMrSjtRQUNwQlYsZUFBZStELElBQUksQ0FBQyxDQUFDc0QsUUFBUUM7WUFDM0IsTUFBTUMsU0FBU0YsT0FBT3RZLEtBQUs7WUFDM0IsTUFBTXlZLFNBQVNGLE9BQU92WSxLQUFLO1lBQzNCLElBQUl3WSxVQUFVLFFBQVFDLFVBQVUsTUFBTTtnQkFDcEMsT0FBTztZQUNULE9BQU8sSUFBSUQsVUFBVSxNQUFNO2dCQUN6QixPQUFPLENBQUM7WUFDVixPQUFPLElBQUlDLFVBQVUsTUFBTTtnQkFDekIsT0FBTztZQUNULE9BQU87Z0JBQ0wsT0FBT0QsU0FBU0M7WUFDbEI7UUFDRjtRQUNBMUgsZUFBZS9SLE9BQU8sQ0FBQ2lZLHFCQUFxQixHQUFHO0lBQ2pELEdBQUcsRUFBRTtJQUNMLE1BQU16Tyx1QkFBdUIxSyxZQUFZNFIsQ0FBQUE7UUFDdkMsT0FBTyxTQUFTZ0osY0FBYzNVLEtBQUs7WUFDakNBLE1BQU04RixjQUFjO1lBQ3BCLE1BQU04RixvQkFBb0JpSCxxQkFBcUI1WCxPQUFPO1lBQ3RELElBQUksQ0FBQzJRLG1CQUFtQjtnQkFDdEIsT0FBTyxJQUFNO1lBQ2Y7WUFDQSxNQUFNLEVBQ0poSCxTQUFTLEVBQ1R5SyxTQUFTLEVBQ1QzVCxJQUFJbUIsT0FBTyxFQUNYZ1MsZ0JBQWdCLEVBQ2hCK0QsUUFBUSxFQUNULEdBQUc3RixtQkFBbUI5UixPQUFPO1lBQzlCLE1BQU0sRUFDSmdTLFFBQVF4RCxVQUFVLEVBQ2xCeUQsY0FBYyxFQUNmLEdBQUdGLGVBQWUvUixPQUFPO1lBQzFCLE1BQU0sRUFDSnNPLGFBQWEsRUFDZCxHQUFHOEYsY0FBYyxRQUFRQSxjQUFjLEtBQUssSUFBSUEsWUFBWSxDQUFDO1lBQzlELE1BQU03RixlQUFla0Msc0JBQXNCN08sU0FBUzhPLGNBQWNDO1lBQ2xFLElBQUlqRCxRQUFRaUcseUJBQXlCNU8sT0FBTzJMLGNBQWMvRyxXQUFXeUssV0FBV1Isa0JBQWtCakQ7WUFDbEcsSUFBSWpELFVBQVUsR0FBRztnQkFDZjtZQUNGO1lBRUEsc0JBQXNCO1lBQ3RCLE1BQU11RixlQUFldEosY0FBYztZQUNuQyxJQUFJbkYsU0FBU21WLEdBQUcsS0FBSyxTQUFTMUcsY0FBYztnQkFDMUN2RixRQUFRLENBQUNBO1lBQ1g7WUFDQSxNQUFNTSxtQkFBbUJpRSxlQUFlTSxHQUFHLENBQUNJLENBQUFBLFlBQWFBLFVBQVV0USxXQUFXO1lBQzlFLE1BQU1xTSxhQUFhTCxvQkFBb0I7Z0JBQ3JDWDtnQkFDQVksZUFBZUEsa0JBQWtCLFFBQVFBLGtCQUFrQixLQUFLLElBQUlBLGdCQUFnQkU7Z0JBQ3BGUjtnQkFDQU87Z0JBQ0FDO2dCQUNBQyxTQUFTM0osVUFBVUMsU0FBUyxhQUFhO1lBQzNDO1lBQ0EsTUFBTTZVLGdCQUFnQixDQUFDMUYsZUFBZTFGLFlBQVlFO1lBRWxELDJGQUEyRjtZQUMzRixvR0FBb0c7WUFDcEcsSUFBSXpKLGFBQWFGLFVBQVVJLGFBQWFKLFFBQVE7Z0JBQzlDLG9GQUFvRjtnQkFDcEYsOENBQThDO2dCQUM5Qyw4REFBOEQ7Z0JBQzlELElBQUlpVCxhQUFhaFksT0FBTyxJQUFJME4sT0FBTztvQkFDakNzSyxhQUFhaFksT0FBTyxHQUFHME47b0JBQ3ZCLElBQUksQ0FBQ2tNLGVBQWU7d0JBQ2xCLDJHQUEyRzt3QkFDM0csZ0NBQWdDO3dCQUNoQyxJQUFJM0csY0FBYzs0QkFDaEI1RywyQkFBMkJxRSxjQUFjaEQsUUFBUSxJQUFJMUosMEJBQTBCRTt3QkFDakYsT0FBTzs0QkFDTG1JLDJCQUEyQnFFLGNBQWNoRCxRQUFRLElBQUl0Six3QkFBd0JFO3dCQUMvRTtvQkFDRixPQUFPO3dCQUNMK0gsMkJBQTJCcUUsY0FBYztvQkFDM0M7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlrSixlQUFlO2dCQUNqQjFILFVBQVV4RDtnQkFDVnFELGVBQWUvUixPQUFPLENBQUNnUyxNQUFNLEdBQUd0RDtnQkFDaEMsSUFBSWlKLFVBQVU7b0JBQ1pBLFNBQVNqSjtnQkFDWDtnQkFDQXFGLG1CQUFtQjlCLGdCQUFnQnZELFlBQVlvSixnQ0FBZ0M5WCxPQUFPO1lBQ3hGO1FBQ0Y7SUFDRixHQUFHLEVBQUU7SUFFTCw2REFBNkQ7SUFDN0QsTUFBTWdDLGNBQWNsRCxZQUFZLENBQUM2VCxXQUFXa0g7UUFDMUMsTUFBTSxFQUNKbEMsUUFBUSxFQUNULEdBQUc3RixtQkFBbUI5UixPQUFPO1FBQzlCLE1BQU0sRUFDSmdTLFFBQVF4RCxVQUFVLEVBQ2xCeUQsY0FBYyxFQUNmLEdBQUdGLGVBQWUvUixPQUFPO1FBQzFCLE1BQU1pTyx3QkFBd0JnRSxlQUFlTSxHQUFHLENBQUNJLENBQUFBLFlBQWFBLFVBQVV0USxXQUFXO1FBQ25GLE1BQU0sRUFDSjBXLFNBQVMsRUFDVHhLLFlBQVksRUFDYixHQUFHeUssZ0JBQWdCL0csZ0JBQWdCVSxXQUFXbkU7UUFDL0MzSCxPQUFPa1MsYUFBYSxNQUFNLENBQUMsZ0NBQWdDLEVBQUVwRyxVQUFVbFMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM1RSxNQUFNd1ksY0FBY0MsbUJBQW1CakgsZ0JBQWdCVSxlQUFlVixlQUFlN0ssTUFBTSxHQUFHO1FBQzlGLE1BQU1zRyxRQUFRdUwsY0FBY0YsWUFBWWMsa0JBQWtCQSxrQkFBa0JkO1FBQzVFLE1BQU1ySyxhQUFhTCxvQkFBb0I7WUFDckNYO1lBQ0FZLGVBQWVFO1lBQ2ZSLGtCQUFrQkM7WUFDbEJNO1lBQ0FDO1lBQ0FDLFNBQVM7UUFDWDtRQUNBLElBQUksQ0FBQ3lGLGVBQWUxRixZQUFZRSxhQUFhO1lBQzNDd0QsVUFBVXhEO1lBQ1ZxRCxlQUFlL1IsT0FBTyxDQUFDZ1MsTUFBTSxHQUFHdEQ7WUFDaEMsSUFBSWlKLFVBQVU7Z0JBQ1pBLFNBQVNqSjtZQUNYO1lBQ0FxRixtQkFBbUI5QixnQkFBZ0J2RCxZQUFZb0osZ0NBQWdDOVgsT0FBTztRQUN4RjtJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU04Qiw2QkFBNkJoRCxZQUFZLENBQUM2VCxXQUFXbUg7UUFDekQsTUFBTSxFQUNKOUgsTUFBTSxFQUNOQyxjQUFjLEVBQ2YsR0FBR0YsZUFBZS9SLE9BQU87UUFDMUIsTUFBTSxFQUNKSyxlQUFlMFosb0JBQW9CLENBQUMsRUFDcEN6WixhQUFhMFosZUFBZSxFQUM3QixHQUFHRjtRQUNKLE1BQU0sRUFDSnpaLGVBQWU0WixvQkFBb0IsQ0FBQyxFQUNwQzNaLGFBQWE0WixlQUFlLEVBQzVCdlosU0FBU3daLGNBQWMsR0FBRyxFQUMxQnZaLFNBQVN3WixjQUFjLENBQUMsRUFDekIsR0FBR3pILFVBQVV0USxXQUFXO1FBQ3pCLE1BQU0sRUFDSjBXLFdBQVdJLGFBQWEsRUFDekIsR0FBR0gsZ0JBQWdCL0csZ0JBQWdCVSxXQUFXWDtRQUMvQyxJQUFJbUgsaUJBQWlCLE1BQU07WUFDekIsaUZBQWlGO1lBQ2pGO1FBQ0Y7UUFDQSxJQUFJYSxtQkFBbUJFLG1CQUFtQmYsa0JBQWtCWSxtQkFBbUI7WUFDN0UsSUFBSUEsc0JBQXNCRSxtQkFBbUI7Z0JBQzNDalksWUFBWTJRLFdBQVdzSDtZQUN6QjtRQUNGLE9BQU8sSUFBSWQsZ0JBQWdCaUIsYUFBYTtZQUN0Q3BZLFlBQVkyUSxXQUFXeUg7UUFDekIsT0FBTyxJQUFJakIsZ0JBQWdCZ0IsYUFBYTtZQUN0Q25ZLFlBQVkyUSxXQUFXd0g7UUFDekI7SUFDRixHQUFHO1FBQUNuWTtLQUFZO0lBQ2hCLE1BQU1xWSxnQkFBZ0J2YixZQUFZLENBQUM0UixjQUFjM0w7UUFDL0MsTUFBTSxFQUNKNEUsU0FBUyxFQUNWLEdBQUdtSSxtQkFBbUI5UixPQUFPO1FBQzlCLE1BQU0sRUFDSmdTLE1BQU0sRUFDUCxHQUFHRCxlQUFlL1IsT0FBTztRQUMxQixJQUFJLENBQUM0WCxxQkFBcUI1WCxPQUFPLEVBQUU7WUFDakM7UUFDRjtRQUNBLE1BQU1vVCxnQkFBZ0JsQyx1QkFBdUJSLGNBQWNrSCxxQkFBcUI1WCxPQUFPO1FBQ3ZGNkcsT0FBT3VNLGVBQWUsQ0FBQyxzQ0FBc0MsRUFBRTFDLGFBQWEsQ0FBQyxDQUFDO1FBQzlFLE1BQU0yQyx3QkFBd0JMLDZCQUE2QnJKLFdBQVc1RTtRQUN0RThTLGFBQWE7WUFDWG5IO1lBQ0FuRixnQkFBZ0I2SCxjQUFjNUgscUJBQXFCO1lBQ25ENkg7WUFDQS9FLGVBQWUwRDtRQUNqQjtJQUNGLEdBQUcsRUFBRTtJQUNMLE1BQU1zSSxlQUFleGIsWUFBWTtRQUMvQitZLGFBQWE7SUFDZixHQUFHLEVBQUU7SUFDTCxNQUFNNVYsa0JBQWtCbkQsWUFBWTZULENBQUFBO1FBQ2xDLE1BQU0sRUFDSlYsY0FBYyxFQUNmLEdBQUdGLGVBQWUvUixPQUFPO1FBQzFCLE1BQU02TixRQUFRcUwsbUJBQW1CakgsZ0JBQWdCVTtRQUNqRCxJQUFJOUUsU0FBUyxHQUFHO1lBQ2RvRSxlQUFlL0csTUFBTSxDQUFDMkMsT0FBTztZQUU3QixTQUFTO1lBQ1QsbUdBQW1HO1lBQ25HLHlHQUF5RztZQUN6RyxpSUFBaUk7WUFDakksT0FBT2lLLGdDQUFnQzlYLE9BQU8sQ0FBQzJTLFVBQVVsUyxFQUFFLENBQUM7WUFDNURzUixlQUFlL1IsT0FBTyxDQUFDaVkscUJBQXFCLEdBQUc7UUFDakQ7SUFDRixHQUFHLEVBQUU7SUFDTCxNQUFNM1csVUFBVW5DLFFBQVEsSUFBTztZQUM3QnFDO1lBQ0FtSTtZQUNBeUs7WUFDQTNTO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0F3WDtZQUNBdlg7WUFDQUM7WUFDQXlIO1lBQ0F4SDtZQUNBcVk7WUFDQUM7WUFDQXJZO1lBQ0EwTyxtQkFBbUJpSCxxQkFBcUI1WCxPQUFPO1FBQ2pELElBQUk7UUFBQ3dCO1FBQWU0UztRQUFXeks7UUFBV2xJO1FBQWFDO1FBQWNDO1FBQWVDO1FBQVNDO1FBQWtCd1g7UUFBaUJ2WDtRQUE0QkM7UUFBZXlIO1FBQXNCeEg7UUFBYXFZO1FBQWVDO1FBQWNyWTtLQUFnQjtJQUMzUCxNQUFNaEIsUUFBUTtRQUNaeUcsU0FBUztRQUNUNlMsZUFBZTVRLGNBQWMsZUFBZSxRQUFRO1FBQ3BEdkQsUUFBUTtRQUNSb08sVUFBVTtRQUNWck8sT0FBTztJQUNUO0lBQ0EsT0FBT3pILGNBQWNjLGtCQUFrQmdiLFFBQVEsRUFBRTtRQUMvQ2hGLE9BQU9sVTtJQUNULEdBQUc1QyxjQUFjMEMsTUFBTTtRQUNyQixHQUFHQyxJQUFJO1FBQ1BuQjtRQUNBQyxXQUFXQztRQUNYSyxJQUFJQztRQUNKK0MsS0FBS21VO1FBQ0wzVyxPQUFPO1lBQ0wsR0FBR0EsS0FBSztZQUNSLEdBQUdDLGNBQWM7UUFDbkI7UUFDQSxnQkFBZ0I7UUFDaEIsb0JBQW9CO1FBQ3BCLDhCQUE4QnlJO1FBQzlCLHVCQUF1Qi9IO0lBQ3pCO0FBQ0Y7QUFDQSxNQUFNNlksYUFBYTViLFdBQVcsQ0FBQzJFLE9BQU9DLE1BQVEvRSxjQUFjZ1osNEJBQTRCO1FBQ3RGLEdBQUdsVSxLQUFLO1FBQ1JoRCxjQUFjaUQ7SUFDaEI7QUFDQWlVLDJCQUEyQmpZLFdBQVcsR0FBRztBQUN6Q2diLFdBQVdoYixXQUFXLEdBQUc7QUFDekIsU0FBU3laLG1CQUFtQmpILGNBQWMsRUFBRVUsU0FBUztJQUNuRCxPQUFPVixlQUFlM0IsU0FBUyxDQUFDb0ssQ0FBQUEsZ0JBQWlCQSxrQkFBa0IvSCxhQUFhK0gsY0FBY2phLEVBQUUsS0FBS2tTLFVBQVVsUyxFQUFFO0FBQ25IO0FBQ0EsU0FBU3VZLGdCQUFnQi9HLGNBQWMsRUFBRVUsU0FBUyxFQUFFWCxNQUFNO0lBQ3hELE1BQU05RCxhQUFhZ0wsbUJBQW1CakgsZ0JBQWdCVTtJQUN0RCxNQUFNc0csY0FBYy9LLGVBQWUrRCxlQUFlN0ssTUFBTSxHQUFHO0lBQzNELE1BQU1tSCxlQUFlMEssY0FBYztRQUFDL0ssYUFBYTtRQUFHQTtLQUFXLEdBQUc7UUFBQ0E7UUFBWUEsYUFBYTtLQUFFO0lBQzlGLE1BQU02SyxZQUFZL0csTUFBTSxDQUFDOUQsV0FBVztJQUNwQyxPQUFPO1FBQ0wsR0FBR3lFLFVBQVV0USxXQUFXO1FBQ3hCMFc7UUFDQXhLO0lBQ0Y7QUFDRjtBQUVBLDJEQUEyRDtBQUUzRCxTQUFTb00sdUNBQXVDLEVBQzlDQyxRQUFRLEVBQ1J4SixRQUFRLEVBQ1JzSSxhQUFhLEVBQ2IvSSxpQkFBaUIsRUFDbEI7SUFDQzNSLFVBQVU7UUFDUixJQUFJNGIsWUFBWWxCLGlCQUFpQixRQUFRL0kscUJBQXFCLE1BQU07WUFDbEU7UUFDRjtRQUNBLE1BQU15QyxnQkFBZ0JsQyx1QkFBdUJFLFVBQVVUO1FBQ3ZELElBQUl5QyxpQkFBaUIsTUFBTTtZQUN6QjtRQUNGO1FBQ0EsTUFBTVosWUFBWXpOLENBQUFBO1lBQ2hCLElBQUlBLE1BQU0wTixnQkFBZ0IsRUFBRTtnQkFDMUI7WUFDRjtZQUNBLE9BQVExTixNQUFNMk4sR0FBRztnQkFDZixLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSDt3QkFDRTNOLE1BQU04RixjQUFjO3dCQUNwQjZPLGNBQWMzVTt3QkFDZDtvQkFDRjtnQkFDRixLQUFLO29CQUNIO3dCQUNFQSxNQUFNOEYsY0FBYzt3QkFDcEIsTUFBTWpKLFVBQVV3UixjQUFjNUMsWUFBWSxDQUFDO3dCQUMzQzNKLE9BQU9qRixTQUFTLENBQUMsK0JBQStCLEVBQUVBLFFBQVEsQ0FBQyxDQUFDO3dCQUM1RCxNQUFNeU8sVUFBVU4sZ0NBQWdDbk8sU0FBUytPO3dCQUN6RCxNQUFNOUMsUUFBUXVDLDRCQUE0QnhPLFNBQVN3UCxVQUFVVDt3QkFDN0Q5SixPQUFPZ0gsVUFBVSxNQUFNLENBQUMsZ0NBQWdDLEVBQUV1RCxTQUFTLENBQUMsQ0FBQzt3QkFDckUsTUFBTXlKLFlBQVk5VixNQUFNOE8sUUFBUSxHQUFHaEcsUUFBUSxJQUFJQSxRQUFRLElBQUl3QyxRQUFRakosTUFBTSxHQUFHLElBQUl5RyxRQUFRLElBQUl3QyxRQUFRakosTUFBTSxHQUFHeUcsUUFBUSxJQUFJO3dCQUN6SCxNQUFNaU4sYUFBYXpLLE9BQU8sQ0FBQ3dLLFVBQVU7d0JBQ3JDQyxXQUFXQyxLQUFLO3dCQUNoQjtvQkFDRjtZQUNKO1FBQ0Y7UUFDQTNILGNBQWN2RyxnQkFBZ0IsQ0FBQyxXQUFXMkY7UUFDMUMsT0FBTztZQUNMWSxjQUFjekcsbUJBQW1CLENBQUMsV0FBVzZGO1FBQy9DO0lBQ0YsR0FBRztRQUFDN0I7UUFBbUJpSztRQUFVeEo7UUFBVXNJO0tBQWM7QUFDM0Q7QUFFQSxTQUFTc0Isa0JBQWtCLEVBQ3pCOWEsV0FBVyxJQUFJLEVBQ2ZDLFdBQVdDLHFCQUFxQixFQUFFLEVBQ2xDd2EsV0FBVyxLQUFLLEVBQ2hCaFIsY0FBYyxFQUNkbkosSUFBSUMsV0FBVyxFQUNmdWEsVUFBVSxFQUNWaGEsT0FBT0MsaUJBQWlCLENBQUMsQ0FBQyxFQUMxQmdhLFdBQVcsQ0FBQyxFQUNaL1osU0FBU0MsT0FBTyxLQUFLLEVBQ3JCLEdBQUdDLE1BQ0o7SUFDQyxNQUFNOFosYUFBYS9iLE9BQU87SUFFMUIsd0RBQXdEO0lBQ3hELE1BQU1nYyxlQUFlaGMsT0FBTztRQUMxQjZiO0lBQ0Y7SUFDQWpjLFVBQVU7UUFDUm9jLGFBQWFwYixPQUFPLENBQUNpYixVQUFVLEdBQUdBO0lBQ3BDO0lBQ0EsTUFBTUksb0JBQW9CdGMsV0FBV1M7SUFDckMsSUFBSTZiLHNCQUFzQixNQUFNO1FBQzlCLE1BQU05WixNQUFNLENBQUMsMkVBQTJFLENBQUM7SUFDM0Y7SUFDQSxNQUFNLEVBQ0pvSSxTQUFTLEVBQ1QvSCxPQUFPLEVBQ1A0SCxzQkFBc0I4UixtQ0FBbUMsRUFDekRqQixhQUFhLEVBQ2JDLFlBQVksRUFDWjNKLGlCQUFpQixFQUNsQixHQUFHMEs7SUFDSixNQUFNNVIsaUJBQWlCN0osWUFBWWM7SUFDbkMsTUFBTSxDQUFDbUQsT0FBTzBYLFNBQVMsR0FBR2xjLFNBQVM7SUFDbkMsTUFBTSxDQUFDbWMsV0FBV0MsYUFBYSxHQUFHcGMsU0FBUztJQUMzQyxNQUFNLENBQUNxYSxlQUFlZ0MsaUJBQWlCLEdBQUdyYyxTQUFTO0lBQ25ELE1BQU15UyxxQkFBcUIxUyxPQUFPO1FBQ2hDeUU7SUFDRjtJQUNBN0UsVUFBVTtRQUNSLElBQUk0YixVQUFVO1lBQ1pjLGlCQUFpQjtRQUNuQixPQUFPO1lBQ0wsTUFBTWhDLGdCQUFnQjRCLG9DQUFvQzdSO1lBQzFEaVMsaUJBQWlCLElBQU1oQztRQUN6QjtJQUNGLEdBQUc7UUFBQ2tCO1FBQVVuUjtRQUFnQjZSO0tBQW9DO0lBQ2xFdGMsVUFBVTtRQUNSLElBQUkyYyx1QkFBdUJDO1FBQzNCLElBQUloQixZQUFZbEIsaUJBQWlCLE1BQU07WUFDckM7UUFDRjtRQUNBLE1BQU1oUSxVQUFVeVIsV0FBV25iLE9BQU87UUFDbEM2RyxPQUFPNkMsU0FBUztRQUNoQixNQUFNRyx3QkFBd0IsQ0FBQ2tELFFBQVFDLFVBQVVqSTtZQUMvQyxJQUFJaUksVUFBVTtnQkFDWixPQUFRRDtvQkFDTixLQUFLO3dCQUNIOzRCQUNFd08sU0FBUzs0QkFDVGxCLGNBQWM1USxnQkFBZ0IxRTs0QkFDOUIsTUFBTSxFQUNKa1csVUFBVSxFQUNYLEdBQUdHLGFBQWFwYixPQUFPOzRCQUN4QixJQUFJaWIsWUFBWTtnQ0FDZEEsV0FBVzs0QkFDYjs0QkFDQTt3QkFDRjtvQkFDRixLQUFLO3dCQUNIOzRCQUNFLE1BQU0sRUFDSnBYLEtBQUssRUFDTixHQUFHaU8sbUJBQW1COVIsT0FBTzs0QkFDOUIsSUFBSTZELFVBQVUsUUFBUTtnQ0FDcEIwWCxTQUFTOzRCQUNYOzRCQUNBN0IsY0FBYzNVOzRCQUNkO3dCQUNGO29CQUNGLEtBQUs7d0JBQ0g7NEJBQ0V3VyxTQUFTOzRCQUNUakI7NEJBQ0EsTUFBTSxFQUNKVyxVQUFVLEVBQ1gsR0FBR0csYUFBYXBiLE9BQU87NEJBQ3hCLElBQUlpYixZQUFZO2dDQUNkQSxXQUFXOzRCQUNiOzRCQUNBO3dCQUNGO2dCQUNKO1lBQ0YsT0FBTztnQkFDTE0sU0FBUztZQUNYO1FBQ0Y7UUFDQSxPQUFPL1IscUJBQXFCQyxnQkFBZ0JDLFNBQVNDLFdBQVc7WUFDOUQsb0NBQW9DO1lBQ3BDbUMsUUFBUSxDQUFDNlAsd0JBQXdCL1IsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFla0MsTUFBTSxNQUFNLFFBQVE2UCwwQkFBMEIsS0FBSyxJQUFJQSx3QkFBd0I7WUFDL0wsMkJBQTJCO1lBQzNCNVAsTUFBTSxDQUFDNlAsdUJBQXVCaFMsbUJBQW1CLFFBQVFBLG1CQUFtQixLQUFLLElBQUksS0FBSyxJQUFJQSxlQUFlbUMsSUFBSSxNQUFNLFFBQVE2UCx5QkFBeUIsS0FBSyxJQUFJQSx1QkFBdUI7UUFDMUwsR0FBRy9SO0lBQ0wsR0FBRztRQUFDRjtRQUFXaVI7UUFBVWhSO1FBQWdCMFI7UUFBcUM3UjtRQUFnQmlRO1FBQWVXO1FBQWVDO0tBQWE7SUFDeklLLHVDQUF1QztRQUNyQ0M7UUFDQXhKLFVBQVUzSDtRQUNWaVE7UUFDQS9JO0lBQ0Y7SUFDQSxNQUFNMVAsUUFBUTtRQUNaNGEsYUFBYTtRQUNiQyxZQUFZO0lBQ2Q7SUFDQSxPQUFPcGQsY0FBYzBDLE1BQU07UUFDekIsR0FBR0MsSUFBSTtRQUNQbkI7UUFDQUMsV0FBV0M7UUFDWEssSUFBSUM7UUFDSnFiLFFBQVEsSUFBTU4sYUFBYTtRQUMzQk8sU0FBUyxJQUFNUCxhQUFhO1FBQzVCaFksS0FBSzBYO1FBQ0xjLE1BQU07UUFDTmhiLE9BQU87WUFDTCxHQUFHQSxLQUFLO1lBQ1IsR0FBR0MsY0FBYztRQUNuQjtRQUNBZ2E7UUFDQSxnQkFBZ0I7UUFDaEIsOEJBQThCdlI7UUFDOUIsdUJBQXVCL0g7UUFDdkIsc0JBQXNCO1FBQ3RCLDZCQUE2QmlDLFVBQVUsU0FBUyxZQUFZMlgsWUFBWSxhQUFhalo7UUFDckYsNEJBQTRCc0I7UUFDNUIsb0NBQW9DLENBQUMrVztRQUNyQywrQkFBK0JuUjtJQUNqQztBQUNGO0FBQ0F1UixrQkFBa0J2YixXQUFXLEdBQUc7QUFFaEMsU0FBU3ljLGdCQUFnQnpiLEVBQUUsRUFBRXVQLFFBQVF4TCxRQUFRO0lBQzNDLE1BQU1rRixVQUFVc0csTUFBTWlCLGFBQWEsQ0FBQyxDQUFDLGdCQUFnQixFQUFFeFEsR0FBRyxFQUFFLENBQUM7SUFDN0QsSUFBSWlKLFNBQVM7UUFDWCxPQUFPQTtJQUNUO0lBQ0EsT0FBTztBQUNUO0FBRUEsU0FBU3lTLHlCQUF5QnZhLE9BQU8sRUFBRW9PLFFBQVF4TCxRQUFRO0lBQ3pELE9BQU95TCxNQUFNQyxJQUFJLENBQUNGLE1BQU1HLGdCQUFnQixDQUFDLENBQUMsa0NBQWtDLEVBQUV2TyxRQUFRLEVBQUUsQ0FBQztBQUMzRjtBQUVBLFNBQVN3YSx5QkFBeUJwVyxPQUFPLEVBQUVDLE9BQU8sRUFBRUMsTUFBTTtJQUN4RCxJQUFJLENBQUNILFdBQVdDLFNBQVNDLFNBQVNDLFNBQVM7UUFDekMsT0FBTztZQUNMYixHQUFHO1lBQ0hFLEdBQUc7WUFDSFksT0FBTztZQUNQQyxRQUFRO1FBQ1Y7SUFDRjtJQUNBLE9BQU87UUFDTGYsR0FBR2lDLEtBQUsrVSxHQUFHLENBQUNyVyxRQUFRWCxDQUFDLEVBQUVZLFFBQVFaLENBQUM7UUFDaENFLEdBQUcrQixLQUFLK1UsR0FBRyxDQUFDclcsUUFBUVQsQ0FBQyxFQUFFVSxRQUFRVixDQUFDO1FBQ2hDWSxPQUFPbUIsS0FBSzhHLEdBQUcsQ0FBQ3BJLFFBQVFYLENBQUMsR0FBR1csUUFBUUcsS0FBSyxFQUFFRixRQUFRWixDQUFDLEdBQUdZLFFBQVFFLEtBQUssSUFBSW1CLEtBQUsrVSxHQUFHLENBQUNyVyxRQUFRWCxDQUFDLEVBQUVZLFFBQVFaLENBQUM7UUFDckdlLFFBQVFrQixLQUFLOEcsR0FBRyxDQUFDcEksUUFBUVQsQ0FBQyxHQUFHUyxRQUFRSSxNQUFNLEVBQUVILFFBQVFWLENBQUMsR0FBR1UsUUFBUUcsTUFBTSxJQUFJa0IsS0FBSytVLEdBQUcsQ0FBQ3JXLFFBQVFULENBQUMsRUFBRVUsUUFBUVYsQ0FBQztJQUMxRztBQUNGO0FBRThRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbXktbmV4dC1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzaXphYmxlLXBhbmVscy9kaXN0L3JlYWN0LXJlc2l6YWJsZS1wYW5lbHMuZGV2ZWxvcG1lbnQubm9kZS5lc20uanM/MTU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8vIFRoaXMgbW9kdWxlIGV4aXN0cyB0byB3b3JrIGFyb3VuZCBXZWJwYWNrIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2svaXNzdWVzLzE0ODE0XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWltcG9ydHNcblxuY29uc3Qge1xuICBjcmVhdGVFbGVtZW50LFxuICBjcmVhdGVDb250ZXh0LFxuICBjcmVhdGVSZWYsXG4gIGZvcndhcmRSZWYsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlUmVmLFxuICB1c2VTdGF0ZVxufSA9IFJlYWN0O1xuXG4vLyBgdG9TdHJpbmcoKWAgcHJldmVudHMgYnVuZGxlcnMgZnJvbSB0cnlpbmcgdG8gYGltcG9ydCB7IHVzZUlkIH0gZnJvbSAncmVhY3QnYFxuY29uc3QgdXNlSWQgPSBSZWFjdFtcInVzZUlkXCIudG9TdHJpbmcoKV07XG5cbmNvbnN0IFBhbmVsR3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcblBhbmVsR3JvdXBDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJQYW5lbEdyb3VwQ29udGV4dFwiO1xuXG5jb25zdCB3cmFwcGVkVXNlSWQgPSB0eXBlb2YgdXNlSWQgPT09IFwiZnVuY3Rpb25cIiA/IHVzZUlkIDogKCkgPT4gbnVsbDtcbmxldCBjb3VudGVyID0gMDtcbmZ1bmN0aW9uIHVzZVVuaXF1ZUlkKGlkRnJvbVBhcmFtcyA9IG51bGwpIHtcbiAgY29uc3QgaWRGcm9tVXNlSWQgPSB3cmFwcGVkVXNlSWQoKTtcbiAgY29uc3QgaWRSZWYgPSB1c2VSZWYoaWRGcm9tUGFyYW1zIHx8IGlkRnJvbVVzZUlkIHx8IG51bGwpO1xuICBpZiAoaWRSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGlkUmVmLmN1cnJlbnQgPSBcIlwiICsgY291bnRlcisrO1xuICB9XG4gIHJldHVybiBpZEZyb21QYXJhbXMgIT09IG51bGwgJiYgaWRGcm9tUGFyYW1zICE9PSB2b2lkIDAgPyBpZEZyb21QYXJhbXMgOiBpZFJlZi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBQYW5lbFdpdGhGb3J3YXJkZWRSZWYoe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVGcm9tUHJvcHMgPSBcIlwiLFxuICBjb2xsYXBzZWRTaXplLFxuICBjb2xsYXBzaWJsZSxcbiAgZGVmYXVsdFNpemUsXG4gIGZvcndhcmRlZFJlZixcbiAgaWQ6IGlkRnJvbVByb3BzLFxuICBtYXhTaXplLFxuICBtaW5TaXplLFxuICBvbkNvbGxhcHNlLFxuICBvbkV4cGFuZCxcbiAgb25SZXNpemUsXG4gIG9yZGVyLFxuICBzdHlsZTogc3R5bGVGcm9tUHJvcHMsXG4gIHRhZ05hbWU6IFR5cGUgPSBcImRpdlwiLFxuICAuLi5yZXN0XG59KSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFBhbmVsR3JvdXBDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFuZWwgY29tcG9uZW50cyBtdXN0IGJlIHJlbmRlcmVkIHdpdGhpbiBhIFBhbmVsR3JvdXAgY29udGFpbmVyYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGNvbGxhcHNlUGFuZWwsXG4gICAgZXhwYW5kUGFuZWwsXG4gICAgZ2V0UGFuZWxTaXplLFxuICAgIGdldFBhbmVsU3R5bGUsXG4gICAgZ3JvdXBJZCxcbiAgICBpc1BhbmVsQ29sbGFwc2VkLFxuICAgIHJlZXZhbHVhdGVQYW5lbENvbnN0cmFpbnRzLFxuICAgIHJlZ2lzdGVyUGFuZWwsXG4gICAgcmVzaXplUGFuZWwsXG4gICAgdW5yZWdpc3RlclBhbmVsXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBwYW5lbElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBwYW5lbERhdGFSZWYgPSB1c2VSZWYoe1xuICAgIGNhbGxiYWNrczoge1xuICAgICAgb25Db2xsYXBzZSxcbiAgICAgIG9uRXhwYW5kLFxuICAgICAgb25SZXNpemVcbiAgICB9LFxuICAgIGNvbnN0cmFpbnRzOiB7XG4gICAgICBjb2xsYXBzZWRTaXplLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBkZWZhdWx0U2l6ZSxcbiAgICAgIG1heFNpemUsXG4gICAgICBtaW5TaXplXG4gICAgfSxcbiAgICBpZDogcGFuZWxJZCxcbiAgICBpZElzRnJvbVByb3BzOiBpZEZyb21Qcm9wcyAhPT0gdW5kZWZpbmVkLFxuICAgIG9yZGVyXG4gIH0pO1xuICBjb25zdCBkZXZXYXJuaW5nc1JlZiA9IHVzZVJlZih7XG4gICAgZGlkTG9nTWlzc2luZ0RlZmF1bHRTaXplV2FybmluZzogZmFsc2VcbiAgfSk7XG5cbiAgLy8gTm9ybWFsbHkgd2Ugd291bGRuJ3QgbG9nIGEgd2FybmluZyBkdXJpbmcgcmVuZGVyLFxuICAvLyBidXQgZWZmZWN0cyBkb24ndCBydW4gb24gdGhlIHNlcnZlciwgc28gd2UgY2FuJ3QgZG8gaXQgdGhlcmVcbiAge1xuICAgIGlmICghZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dNaXNzaW5nRGVmYXVsdFNpemVXYXJuaW5nKSB7XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPT0gbnVsbCkge1xuICAgICAgICBkZXZXYXJuaW5nc1JlZi5jdXJyZW50LmRpZExvZ01pc3NpbmdEZWZhdWx0U2l6ZVdhcm5pbmcgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IFBhbmVsIGRlZmF1bHRTaXplIHByb3AgcmVjb21tZW5kZWQgdG8gYXZvaWQgbGF5b3V0IHNoaWZ0IGFmdGVyIHNlcnZlciByZW5kZXJpbmdgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZShmb3J3YXJkZWRSZWYsICgpID0+ICh7XG4gICAgY29sbGFwc2U6ICgpID0+IHtcbiAgICAgIGNvbGxhcHNlUGFuZWwocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgZXhwYW5kOiAoKSA9PiB7XG4gICAgICBleHBhbmRQYW5lbChwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBnZXRJZCgpIHtcbiAgICAgIHJldHVybiBwYW5lbElkO1xuICAgIH0sXG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgIHJldHVybiBnZXRQYW5lbFNpemUocGFuZWxEYXRhUmVmLmN1cnJlbnQpO1xuICAgIH0sXG4gICAgaXNDb2xsYXBzZWQoKSB7XG4gICAgICByZXR1cm4gaXNQYW5lbENvbGxhcHNlZChwYW5lbERhdGFSZWYuY3VycmVudCk7XG4gICAgfSxcbiAgICBpc0V4cGFuZGVkKCkge1xuICAgICAgcmV0dXJuICFpc1BhbmVsQ29sbGFwc2VkKHBhbmVsRGF0YVJlZi5jdXJyZW50KTtcbiAgICB9LFxuICAgIHJlc2l6ZTogc2l6ZSA9PiB7XG4gICAgICByZXNpemVQYW5lbChwYW5lbERhdGFSZWYuY3VycmVudCwgc2l6ZSk7XG4gICAgfVxuICB9KSwgW2NvbGxhcHNlUGFuZWwsIGV4cGFuZFBhbmVsLCBnZXRQYW5lbFNpemUsIGlzUGFuZWxDb2xsYXBzZWQsIHBhbmVsSWQsIHJlc2l6ZVBhbmVsXSk7XG4gIGNvbnN0IHN0eWxlID0gZ2V0UGFuZWxTdHlsZShwYW5lbERhdGFSZWYuY3VycmVudCwgZGVmYXVsdFNpemUpO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChUeXBlLCB7XG4gICAgLi4ucmVzdCxcbiAgICBjaGlsZHJlbixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyxcbiAgICBpZDogaWRGcm9tUHJvcHMsXG4gICAgc3R5bGU6IHtcbiAgICAgIC4uLnN0eWxlLFxuICAgICAgLi4uc3R5bGVGcm9tUHJvcHNcbiAgICB9LFxuICAgIC8vIENTUyBzZWxlY3RvcnNcbiAgICBcImRhdGEtcGFuZWxcIjogXCJcIixcbiAgICBcImRhdGEtcGFuZWwtY29sbGFwc2libGVcIjogY29sbGFwc2libGUgfHwgdW5kZWZpbmVkLFxuICAgIFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiOiBncm91cElkLFxuICAgIFwiZGF0YS1wYW5lbC1pZFwiOiBwYW5lbElkLFxuICAgIFwiZGF0YS1wYW5lbC1zaXplXCI6IHBhcnNlRmxvYXQoXCJcIiArIHN0eWxlLmZsZXhHcm93KS50b0ZpeGVkKDEpXG4gIH0pO1xufVxuY29uc3QgUGFuZWwgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBjcmVhdGVFbGVtZW50KFBhbmVsV2l0aEZvcndhcmRlZFJlZiwge1xuICAuLi5wcm9wcyxcbiAgZm9yd2FyZGVkUmVmOiByZWZcbn0pKTtcblBhbmVsV2l0aEZvcndhcmRlZFJlZi5kaXNwbGF5TmFtZSA9IFwiUGFuZWxcIjtcblBhbmVsLmRpc3BsYXlOYW1lID0gXCJmb3J3YXJkUmVmKFBhbmVsKVwiO1xuXG5sZXQgY3VycmVudEN1cnNvclN0eWxlID0gbnVsbDtcbmxldCBzdHlsZUVsZW1lbnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q3Vyc29yU3R5bGUoc3RhdGUsIGNvbnN0cmFpbnRGbGFncykge1xuICBpZiAoY29uc3RyYWludEZsYWdzKSB7XG4gICAgY29uc3QgaG9yaXpvbnRhbE1pbiA9IChjb25zdHJhaW50RmxhZ3MgJiBFWENFRURFRF9IT1JJWk9OVEFMX01JTikgIT09IDA7XG4gICAgY29uc3QgaG9yaXpvbnRhbE1heCA9IChjb25zdHJhaW50RmxhZ3MgJiBFWENFRURFRF9IT1JJWk9OVEFMX01BWCkgIT09IDA7XG4gICAgY29uc3QgdmVydGljYWxNaW4gPSAoY29uc3RyYWludEZsYWdzICYgRVhDRUVERURfVkVSVElDQUxfTUlOKSAhPT0gMDtcbiAgICBjb25zdCB2ZXJ0aWNhbE1heCA9IChjb25zdHJhaW50RmxhZ3MgJiBFWENFRURFRF9WRVJUSUNBTF9NQVgpICE9PSAwO1xuICAgIGlmIChob3Jpem9udGFsTWluKSB7XG4gICAgICBpZiAodmVydGljYWxNaW4pIHtcbiAgICAgICAgcmV0dXJuIFwic2UtcmVzaXplXCI7XG4gICAgICB9IGVsc2UgaWYgKHZlcnRpY2FsTWF4KSB7XG4gICAgICAgIHJldHVybiBcIm5lLXJlc2l6ZVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiZS1yZXNpemVcIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvcml6b250YWxNYXgpIHtcbiAgICAgIGlmICh2ZXJ0aWNhbE1pbikge1xuICAgICAgICByZXR1cm4gXCJzdy1yZXNpemVcIjtcbiAgICAgIH0gZWxzZSBpZiAodmVydGljYWxNYXgpIHtcbiAgICAgICAgcmV0dXJuIFwibnctcmVzaXplXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJ3LXJlc2l6ZVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmVydGljYWxNaW4pIHtcbiAgICAgIHJldHVybiBcInMtcmVzaXplXCI7XG4gICAgfSBlbHNlIGlmICh2ZXJ0aWNhbE1heCkge1xuICAgICAgcmV0dXJuIFwibi1yZXNpemVcIjtcbiAgICB9XG4gIH1cbiAgc3dpdGNoIChzdGF0ZSkge1xuICAgIGNhc2UgXCJob3Jpem9udGFsXCI6XG4gICAgICByZXR1cm4gXCJldy1yZXNpemVcIjtcbiAgICBjYXNlIFwiaW50ZXJzZWN0aW9uXCI6XG4gICAgICByZXR1cm4gXCJtb3ZlXCI7XG4gICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICByZXR1cm4gXCJucy1yZXNpemVcIjtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRHbG9iYWxDdXJzb3JTdHlsZSgpIHtcbiAgaWYgKHN0eWxlRWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICBjdXJyZW50Q3Vyc29yU3R5bGUgPSBudWxsO1xuICAgIHN0eWxlRWxlbWVudCA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEdsb2JhbEN1cnNvclN0eWxlKHN0YXRlLCBjb25zdHJhaW50RmxhZ3MpIHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDdXJzb3JTdHlsZShzdGF0ZSwgY29uc3RyYWludEZsYWdzKTtcbiAgaWYgKGN1cnJlbnRDdXJzb3JTdHlsZSA9PT0gc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3VycmVudEN1cnNvclN0eWxlID0gc3R5bGU7XG4gIGlmIChzdHlsZUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICB9XG4gIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBgKntjdXJzb3I6ICR7c3R5bGV9IWltcG9ydGFudDt9YDtcbn1cblxuZnVuY3Rpb24gaXNLZXlEb3duKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC50eXBlID09PSBcImtleWRvd25cIjtcbn1cbmZ1bmN0aW9uIGlzTW91c2VFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQudHlwZS5zdGFydHNXaXRoKFwibW91c2VcIik7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnR5cGUuc3RhcnRzV2l0aChcInRvdWNoXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVFdmVudENvb3JkaW5hdGVzKGV2ZW50KSB7XG4gIGlmIChpc01vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgIGlmICh0b3VjaCAmJiB0b3VjaC5jbGllbnRYICYmIHRvdWNoLmNsaWVudFkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgIHk6IHRvdWNoLmNsaWVudFlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeDogSW5maW5pdHksXG4gICAgeTogSW5maW5pdHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5wdXRUeXBlKCkge1xuICBpZiAodHlwZW9mIG1hdGNoTWVkaWEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBtYXRjaE1lZGlhKFwiKHBvaW50ZXI6Y29hcnNlKVwiKS5tYXRjaGVzID8gXCJjb2Fyc2VcIiA6IFwiZmluZVwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMocmVjdE9uZSwgcmVjdFR3bywgc3RyaWN0KSB7XG4gIGlmIChzdHJpY3QpIHtcbiAgICByZXR1cm4gcmVjdE9uZS54IDwgcmVjdFR3by54ICsgcmVjdFR3by53aWR0aCAmJiByZWN0T25lLnggKyByZWN0T25lLndpZHRoID4gcmVjdFR3by54ICYmIHJlY3RPbmUueSA8IHJlY3RUd28ueSArIHJlY3RUd28uaGVpZ2h0ICYmIHJlY3RPbmUueSArIHJlY3RPbmUuaGVpZ2h0ID4gcmVjdFR3by55O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZWN0T25lLnggPD0gcmVjdFR3by54ICsgcmVjdFR3by53aWR0aCAmJiByZWN0T25lLnggKyByZWN0T25lLndpZHRoID49IHJlY3RUd28ueCAmJiByZWN0T25lLnkgPD0gcmVjdFR3by55ICsgcmVjdFR3by5oZWlnaHQgJiYgcmVjdE9uZS55ICsgcmVjdE9uZS5oZWlnaHQgPj0gcmVjdFR3by55O1xuICB9XG59XG5cbi8vIEZvcmtlZCBmcm9tIE5QTSBzdGFja2luZy1vcmRlckAyLjAuMFxuXG4vKipcbiAqIERldGVybWluZSB3aGljaCBvZiB0d28gbm9kZXMgYXBwZWFycyBpbiBmcm9udCBvZiB0aGUgb3RoZXIg4oCUXG4gKiBpZiBgYWAgaXMgaW4gZnJvbnQsIHJldHVybnMgMSwgb3RoZXJ3aXNlIHJldHVybnMgLTFcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGFcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJcbiAqL1xuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIGlmIChhID09PSBiKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcGFyZSBub2RlIHdpdGggaXRzZWxmXCIpO1xuICBjb25zdCBhbmNlc3RvcnMgPSB7XG4gICAgYTogZ2V0X2FuY2VzdG9ycyhhKSxcbiAgICBiOiBnZXRfYW5jZXN0b3JzKGIpXG4gIH07XG4gIGxldCBjb21tb25fYW5jZXN0b3I7XG5cbiAgLy8gcmVtb3ZlIHNoYXJlZCBhbmNlc3RvcnNcbiAgd2hpbGUgKGFuY2VzdG9ycy5hLmF0KC0xKSA9PT0gYW5jZXN0b3JzLmIuYXQoLTEpKSB7XG4gICAgYSA9IGFuY2VzdG9ycy5hLnBvcCgpO1xuICAgIGIgPSBhbmNlc3RvcnMuYi5wb3AoKTtcbiAgICBjb21tb25fYW5jZXN0b3IgPSBhO1xuICB9XG4gIGFzc2VydChjb21tb25fYW5jZXN0b3IsIFwiU3RhY2tpbmcgb3JkZXIgY2FuIG9ubHkgYmUgY2FsY3VsYXRlZCBmb3IgZWxlbWVudHMgd2l0aCBhIGNvbW1vbiBhbmNlc3RvclwiKTtcbiAgY29uc3Qgel9pbmRleGVzID0ge1xuICAgIGE6IGdldF96X2luZGV4KGZpbmRfc3RhY2tpbmdfY29udGV4dChhbmNlc3RvcnMuYSkpLFxuICAgIGI6IGdldF96X2luZGV4KGZpbmRfc3RhY2tpbmdfY29udGV4dChhbmNlc3RvcnMuYikpXG4gIH07XG4gIGlmICh6X2luZGV4ZXMuYSA9PT0gel9pbmRleGVzLmIpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGNvbW1vbl9hbmNlc3Rvci5jaGlsZE5vZGVzO1xuICAgIGNvbnN0IGZ1cnRoZXN0X2FuY2VzdG9ycyA9IHtcbiAgICAgIGE6IGFuY2VzdG9ycy5hLmF0KC0xKSxcbiAgICAgIGI6IGFuY2VzdG9ycy5iLmF0KC0xKVxuICAgIH07XG4gICAgbGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZCA9PT0gZnVydGhlc3RfYW5jZXN0b3JzLmEpIHJldHVybiAxO1xuICAgICAgaWYgKGNoaWxkID09PSBmdXJ0aGVzdF9hbmNlc3RvcnMuYikgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5zaWduKHpfaW5kZXhlcy5hIC0gel9pbmRleGVzLmIpO1xufVxuY29uc3QgcHJvcHMgPSAvXFxiKD86cG9zaXRpb258ekluZGV4fG9wYWNpdHl8dHJhbnNmb3JtfHdlYmtpdFRyYW5zZm9ybXxtaXhCbGVuZE1vZGV8ZmlsdGVyfHdlYmtpdEZpbHRlcnxpc29sYXRpb24pXFxiLztcblxuLyoqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgKi9cbmZ1bmN0aW9uIGlzX2ZsZXhfaXRlbShub2RlKSB7XG4gIGNvbnN0IGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGdldF9wYXJlbnQobm9kZSkpLmRpc3BsYXk7XG4gIHJldHVybiBkaXNwbGF5ID09PSBcImZsZXhcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1mbGV4XCI7XG59XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlICovXG5mdW5jdGlvbiBjcmVhdGVzX3N0YWNraW5nX2NvbnRleHQobm9kZSkge1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19Qb3NpdGlvbmluZy9VbmRlcnN0YW5kaW5nX3pfaW5kZXgvVGhlX3N0YWNraW5nX2NvbnRleHRcbiAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSBcImZpeGVkXCIpIHJldHVybiB0cnVlO1xuICAvLyBGb3JrZWQgdG8gZml4IHVwc3RyZWFtIGJ1ZyBodHRwczovL2dpdGh1Yi5jb20vUmljaC1IYXJyaXMvc3RhY2tpbmctb3JkZXIvaXNzdWVzLzNcbiAgLy8gaWYgKFxuICAvLyAgIChzdHlsZS56SW5kZXggIT09IFwiYXV0b1wiICYmIHN0eWxlLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiKSB8fFxuICAvLyAgIGlzX2ZsZXhfaXRlbShub2RlKVxuICAvLyApXG4gIGlmIChzdHlsZS56SW5kZXggIT09IFwiYXV0b1wiICYmIChzdHlsZS5wb3NpdGlvbiAhPT0gXCJzdGF0aWNcIiB8fCBpc19mbGV4X2l0ZW0obm9kZSkpKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKCtzdHlsZS5vcGFjaXR5IDwgMSkgcmV0dXJuIHRydWU7XG4gIGlmIChcInRyYW5zZm9ybVwiIGluIHN0eWxlICYmIHN0eWxlLnRyYW5zZm9ybSAhPT0gXCJub25lXCIpIHJldHVybiB0cnVlO1xuICBpZiAoXCJ3ZWJraXRUcmFuc2Zvcm1cIiBpbiBzdHlsZSAmJiBzdHlsZS53ZWJraXRUcmFuc2Zvcm0gIT09IFwibm9uZVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFwibWl4QmxlbmRNb2RlXCIgaW4gc3R5bGUgJiYgc3R5bGUubWl4QmxlbmRNb2RlICE9PSBcIm5vcm1hbFwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFwiZmlsdGVyXCIgaW4gc3R5bGUgJiYgc3R5bGUuZmlsdGVyICE9PSBcIm5vbmVcIikgcmV0dXJuIHRydWU7XG4gIGlmIChcIndlYmtpdEZpbHRlclwiIGluIHN0eWxlICYmIHN0eWxlLndlYmtpdEZpbHRlciAhPT0gXCJub25lXCIpIHJldHVybiB0cnVlO1xuICBpZiAoXCJpc29sYXRpb25cIiBpbiBzdHlsZSAmJiBzdHlsZS5pc29sYXRpb24gPT09IFwiaXNvbGF0ZVwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHByb3BzLnRlc3Qoc3R5bGUud2lsbENoYW5nZSkpIHJldHVybiB0cnVlO1xuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIGlmIChzdHlsZS53ZWJraXRPdmVyZmxvd1Njcm9sbGluZyA9PT0gXCJ0b3VjaFwiKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiogQHBhcmFtIHtIVE1MRWxlbWVudFtdfSBub2RlcyAqL1xuZnVuY3Rpb24gZmluZF9zdGFja2luZ19jb250ZXh0KG5vZGVzKSB7XG4gIGxldCBpID0gbm9kZXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGFzc2VydChub2RlLCBcIk1pc3Npbmcgbm9kZVwiKTtcbiAgICBpZiAoY3JlYXRlc19zdGFja2luZ19jb250ZXh0KG5vZGUpKSByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgKi9cbmZ1bmN0aW9uIGdldF96X2luZGV4KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgTnVtYmVyKGdldENvbXB1dGVkU3R5bGUobm9kZSkuekluZGV4KSB8fCAwO1xufVxuXG4vKiogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSAqL1xuZnVuY3Rpb24gZ2V0X2FuY2VzdG9ycyhub2RlKSB7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICAgIG5vZGUgPSBnZXRfcGFyZW50KG5vZGUpO1xuICB9XG4gIHJldHVybiBhbmNlc3RvcnM7IC8vIFsgbm9kZSwgLi4uIDxib2R5PiwgPGh0bWw+LCBkb2N1bWVudCBdXG59XG5cbi8qKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlICovXG5mdW5jdGlvbiBnZXRfcGFyZW50KG5vZGUpIHtcbiAgdmFyIF9ub2RlJHBhcmVudE5vZGU7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuICgoX25vZGUkcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX25vZGUkcGFyZW50Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkcGFyZW50Tm9kZS5ob3N0KSB8fCBub2RlLnBhcmVudE5vZGU7XG59XG5cbmNvbnN0IEVYQ0VFREVEX0hPUklaT05UQUxfTUlOID0gMGIwMDAxO1xuY29uc3QgRVhDRUVERURfSE9SSVpPTlRBTF9NQVggPSAwYjAwMTA7XG5jb25zdCBFWENFRURFRF9WRVJUSUNBTF9NSU4gPSAwYjAxMDA7XG5jb25zdCBFWENFRURFRF9WRVJUSUNBTF9NQVggPSAwYjEwMDA7XG5jb25zdCBpc0NvYXJzZVBvaW50ZXIgPSBnZXRJbnB1dFR5cGUoKSA9PT0gXCJjb2Fyc2VcIjtcbmxldCBpbnRlcnNlY3RpbmdIYW5kbGVzID0gW107XG5sZXQgaXNQb2ludGVyRG93biA9IGZhbHNlO1xubGV0IG93bmVyRG9jdW1lbnRDb3VudHMgPSBuZXcgTWFwKCk7XG5sZXQgcGFuZWxDb25zdHJhaW50RmxhZ3MgPSBuZXcgTWFwKCk7XG5jb25zdCByZWdpc3RlcmVkUmVzaXplSGFuZGxlcnMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiByZWdpc3RlclJlc2l6ZUhhbmRsZShyZXNpemVIYW5kbGVJZCwgZWxlbWVudCwgZGlyZWN0aW9uLCBoaXRBcmVhTWFyZ2lucywgc2V0UmVzaXplSGFuZGxlclN0YXRlKSB7XG4gIHZhciBfb3duZXJEb2N1bWVudENvdW50cyQ7XG4gIGNvbnN0IHtcbiAgICBvd25lckRvY3VtZW50XG4gIH0gPSBlbGVtZW50O1xuICBjb25zdCBkYXRhID0ge1xuICAgIGRpcmVjdGlvbixcbiAgICBlbGVtZW50LFxuICAgIGhpdEFyZWFNYXJnaW5zLFxuICAgIHNldFJlc2l6ZUhhbmRsZXJTdGF0ZVxuICB9O1xuICBjb25zdCBjb3VudCA9IChfb3duZXJEb2N1bWVudENvdW50cyQgPSBvd25lckRvY3VtZW50Q291bnRzLmdldChvd25lckRvY3VtZW50KSkgIT09IG51bGwgJiYgX293bmVyRG9jdW1lbnRDb3VudHMkICE9PSB2b2lkIDAgPyBfb3duZXJEb2N1bWVudENvdW50cyQgOiAwO1xuICBvd25lckRvY3VtZW50Q291bnRzLnNldChvd25lckRvY3VtZW50LCBjb3VudCArIDEpO1xuICByZWdpc3RlcmVkUmVzaXplSGFuZGxlcnMuYWRkKGRhdGEpO1xuICB1cGRhdGVMaXN0ZW5lcnMoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVucmVnaXN0ZXJSZXNpemVIYW5kbGUoKSB7XG4gICAgdmFyIF9vd25lckRvY3VtZW50Q291bnRzJDI7XG4gICAgcGFuZWxDb25zdHJhaW50RmxhZ3MuZGVsZXRlKHJlc2l6ZUhhbmRsZUlkKTtcbiAgICByZWdpc3RlcmVkUmVzaXplSGFuZGxlcnMuZGVsZXRlKGRhdGEpO1xuICAgIGNvbnN0IGNvdW50ID0gKF9vd25lckRvY3VtZW50Q291bnRzJDIgPSBvd25lckRvY3VtZW50Q291bnRzLmdldChvd25lckRvY3VtZW50KSkgIT09IG51bGwgJiYgX293bmVyRG9jdW1lbnRDb3VudHMkMiAhPT0gdm9pZCAwID8gX293bmVyRG9jdW1lbnRDb3VudHMkMiA6IDE7XG4gICAgb3duZXJEb2N1bWVudENvdW50cy5zZXQob3duZXJEb2N1bWVudCwgY291bnQgLSAxKTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMoKTtcbiAgICBpZiAoY291bnQgPT09IDEpIHtcbiAgICAgIG93bmVyRG9jdW1lbnRDb3VudHMuZGVsZXRlKG93bmVyRG9jdW1lbnQpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKGV2ZW50KSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXRcbiAgfSA9IGV2ZW50O1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBnZXRSZXNpemVFdmVudENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgaXNQb2ludGVyRG93biA9IHRydWU7XG4gIHJlY2FsY3VsYXRlSW50ZXJzZWN0aW5nSGFuZGxlcyh7XG4gICAgdGFyZ2V0LFxuICAgIHgsXG4gICAgeVxuICB9KTtcbiAgdXBkYXRlTGlzdGVuZXJzKCk7XG4gIGlmIChpbnRlcnNlY3RpbmdIYW5kbGVzLmxlbmd0aCA+IDApIHtcbiAgICB1cGRhdGVSZXNpemVIYW5kbGVyU3RhdGVzKFwiZG93blwiLCBldmVudCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeVxuICB9ID0gZ2V0UmVzaXplRXZlbnRDb29yZGluYXRlcyhldmVudCk7XG4gIGlmICghaXNQb2ludGVyRG93bikge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcblxuICAgIC8vIFJlY2FsY3VsYXRlIGludGVyc2VjdGluZyBoYW5kbGVzIHdoZW5ldmVyIHRoZSBwb2ludGVyIG1vdmVzLCBleGNlcHQgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwcmVzc2VkXG4gICAgLy8gYXQgdGhhdCBwb2ludCwgdGhlIGhhbmRsZXMgbWF5IG5vdCBtb3ZlIHdpdGggdGhlIHBvaW50ZXIgKGRlcGVuZGluZyBvbiBjb25zdHJhaW50cylcbiAgICAvLyBidXQgdGhlIHNhbWUgc2V0IG9mIGFjdGl2ZSBoYW5kbGVzIHNob3VsZCBiZSBsb2NrZWQgdW50aWwgdGhlIHBvaW50ZXIgaXMgcmVsZWFzZWRcbiAgICByZWNhbGN1bGF0ZUludGVyc2VjdGluZ0hhbmRsZXMoe1xuICAgICAgdGFyZ2V0LFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVSZXNpemVIYW5kbGVyU3RhdGVzKFwibW92ZVwiLCBldmVudCk7XG5cbiAgLy8gVXBkYXRlIGN1cnNvciBiYXNlZCBvbiByZXR1cm4gdmFsdWUocykgZnJvbSBhY3RpdmUgaGFuZGxlc1xuICB1cGRhdGVDdXJzb3IoKTtcbiAgaWYgKGludGVyc2VjdGluZ0hhbmRsZXMubGVuZ3RoID4gMCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJVcChldmVudCkge1xuICBjb25zdCB7XG4gICAgdGFyZ2V0XG4gIH0gPSBldmVudDtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeVxuICB9ID0gZ2V0UmVzaXplRXZlbnRDb29yZGluYXRlcyhldmVudCk7XG4gIHBhbmVsQ29uc3RyYWludEZsYWdzLmNsZWFyKCk7XG4gIGlzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgaWYgKGludGVyc2VjdGluZ0hhbmRsZXMubGVuZ3RoID4gMCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgdXBkYXRlUmVzaXplSGFuZGxlclN0YXRlcyhcInVwXCIsIGV2ZW50KTtcbiAgcmVjYWxjdWxhdGVJbnRlcnNlY3RpbmdIYW5kbGVzKHtcbiAgICB0YXJnZXQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xuICB1cGRhdGVDdXJzb3IoKTtcbiAgdXBkYXRlTGlzdGVuZXJzKCk7XG59XG5mdW5jdGlvbiByZWNhbGN1bGF0ZUludGVyc2VjdGluZ0hhbmRsZXMoe1xuICB0YXJnZXQsXG4gIHgsXG4gIHlcbn0pIHtcbiAgaW50ZXJzZWN0aW5nSGFuZGxlcy5zcGxpY2UoMCk7XG4gIGxldCB0YXJnZXRFbGVtZW50ID0gbnVsbDtcbiAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgdGFyZ2V0RWxlbWVudCA9IHRhcmdldDtcbiAgfVxuICByZWdpc3RlcmVkUmVzaXplSGFuZGxlcnMuZm9yRWFjaChkYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50OiBkcmFnSGFuZGxlRWxlbWVudCxcbiAgICAgIGhpdEFyZWFNYXJnaW5zXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgZHJhZ0hhbmRsZVJlY3QgPSBkcmFnSGFuZGxlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB7XG4gICAgICBib3R0b20sXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICB0b3BcbiAgICB9ID0gZHJhZ0hhbmRsZVJlY3Q7XG4gICAgY29uc3QgbWFyZ2luID0gaXNDb2Fyc2VQb2ludGVyID8gaGl0QXJlYU1hcmdpbnMuY29hcnNlIDogaGl0QXJlYU1hcmdpbnMuZmluZTtcbiAgICBjb25zdCBldmVudEludGVyc2VjdHMgPSB4ID49IGxlZnQgLSBtYXJnaW4gJiYgeCA8PSByaWdodCArIG1hcmdpbiAmJiB5ID49IHRvcCAtIG1hcmdpbiAmJiB5IDw9IGJvdHRvbSArIG1hcmdpbjtcbiAgICBpZiAoZXZlbnRJbnRlcnNlY3RzKSB7XG4gICAgICAvLyBUUklDS1lcbiAgICAgIC8vIFdlIGxpc3RlbiBmb3IgcG9pbnRlcnMgZXZlbnRzIGF0IHRoZSByb290IGluIG9yZGVyIHRvIHN1cHBvcnQgaGl0IGFyZWEgbWFyZ2luc1xuICAgICAgLy8gKGRldGVybWluaW5nIHdoZW4gdGhlIHBvaW50ZXIgaXMgY2xvc2UgZW5vdWdoIHRvIGFuIGVsZW1lbnQgdG8gYmUgY29uc2lkZXJlZCBhIFwiaGl0XCIpXG4gICAgICAvLyBDbGlja2luZyBvbiBhbiBlbGVtZW50IFwiYWJvdmVcIiBhIGhhbmRsZSAoZS5nLiBhIG1vZGFsKSBzaG91bGQgcHJldmVudCBhIGhpdCB0aG91Z2hcbiAgICAgIC8vIHNvIGF0IHRoaXMgcG9pbnQgd2UgbmVlZCB0byBjb21wYXJlIHN0YWNraW5nIG9yZGVyIG9mIGEgcG90ZW50aWFsbHkgaW50ZXJzZWN0aW5nIGRyYWcgaGFuZGxlLFxuICAgICAgLy8gYW5kIHRoZSBlbGVtZW50IHRoYXQgd2FzIGFjdHVhbGx5IGNsaWNrZWQvdG91Y2hlZFxuICAgICAgaWYgKHRhcmdldEVsZW1lbnQgIT09IG51bGwgJiYgZHJhZ0hhbmRsZUVsZW1lbnQgIT09IHRhcmdldEVsZW1lbnQgJiYgIWRyYWdIYW5kbGVFbGVtZW50LmNvbnRhaW5zKHRhcmdldEVsZW1lbnQpICYmICF0YXJnZXRFbGVtZW50LmNvbnRhaW5zKGRyYWdIYW5kbGVFbGVtZW50KSAmJlxuICAgICAgLy8gQ2FsY3VsYXRpbmcgc3RhY2tpbmcgb3JkZXIgaGFzIGEgY29zdCwgc28gd2Ugc2hvdWxkIGF2b2lkIGl0IGlmIHBvc3NpYmxlXG4gICAgICAvLyBUaGF0IGlzIHdoeSB3ZSBvbmx5IGNoZWNrIHBvdGVudGlhbGx5IGludGVyc2VjdGluZyBoYW5kbGVzLFxuICAgICAgLy8gYW5kIHdoeSB3ZSBza2lwIGlmIHRoZSBldmVudCB0YXJnZXQgaXMgd2l0aGluIHRoZSBoYW5kbGUncyBET01cbiAgICAgIGNvbXBhcmUodGFyZ2V0RWxlbWVudCwgZHJhZ0hhbmRsZUVsZW1lbnQpID4gMCkge1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGFib3ZlIHRoZSBkcmFnIGhhbmRsZSwgdGhlbiB3ZSBhbHNvIG5lZWQgdG8gY29uZmlybSB0aGV5IG92ZXJsYXBcbiAgICAgICAgLy8gSWYgdGhleSBhcmUgYmVzaWRlIGVhY2ggb3RoZXIgKGUuZy4gYSBwYW5lbCBhbmQgaXRzIGRyYWcgaGFuZGxlKSB0aGVuIHRoZSBoYW5kbGUgaXMgc3RpbGwgaW50ZXJhY3RpdmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSXQncyBub3QgZW5vdWdoIHRvIGNvbXBhcmUgb25seSB0aGUgdGFyZ2V0XG4gICAgICAgIC8vIFRoZSB0YXJnZXQgbWlnaHQgYmUgYSBzbWFsbCBlbGVtZW50IGluc2lkZSBvZiBhIGxhcmdlciBjb250YWluZXJcbiAgICAgICAgLy8gKEZvciBleGFtcGxlLCBhIFNQQU4gb3IgYSBESVYgaW5zaWRlIG9mIGEgbGFyZ2VyIG1vZGFsIGRpYWxvZylcbiAgICAgICAgbGV0IGN1cnJlbnRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgbGV0IGRpZEludGVyc2VjdCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQuY29udGFpbnMoZHJhZ0hhbmRsZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGludGVyc2VjdHMoY3VycmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRyYWdIYW5kbGVSZWN0LCB0cnVlKSkge1xuICAgICAgICAgICAgZGlkSW50ZXJzZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGN1cnJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpZEludGVyc2VjdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW50ZXJzZWN0aW5nSGFuZGxlcy5wdXNoKGRhdGEpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXBvcnRDb25zdHJhaW50c1Zpb2xhdGlvbihyZXNpemVIYW5kbGVJZCwgZmxhZykge1xuICBwYW5lbENvbnN0cmFpbnRGbGFncy5zZXQocmVzaXplSGFuZGxlSWQsIGZsYWcpO1xufVxuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yKCkge1xuICBsZXQgaW50ZXJzZWN0c0hvcml6b250YWwgPSBmYWxzZTtcbiAgbGV0IGludGVyc2VjdHNWZXJ0aWNhbCA9IGZhbHNlO1xuICBpbnRlcnNlY3RpbmdIYW5kbGVzLmZvckVhY2goZGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGlyZWN0aW9uXG4gICAgfSA9IGRhdGE7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIGludGVyc2VjdHNIb3Jpem9udGFsID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJzZWN0c1ZlcnRpY2FsID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICBsZXQgY29uc3RyYWludEZsYWdzID0gMDtcbiAgcGFuZWxDb25zdHJhaW50RmxhZ3MuZm9yRWFjaChmbGFnID0+IHtcbiAgICBjb25zdHJhaW50RmxhZ3MgfD0gZmxhZztcbiAgfSk7XG4gIGlmIChpbnRlcnNlY3RzSG9yaXpvbnRhbCAmJiBpbnRlcnNlY3RzVmVydGljYWwpIHtcbiAgICBzZXRHbG9iYWxDdXJzb3JTdHlsZShcImludGVyc2VjdGlvblwiLCBjb25zdHJhaW50RmxhZ3MpO1xuICB9IGVsc2UgaWYgKGludGVyc2VjdHNIb3Jpem9udGFsKSB7XG4gICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUoXCJob3Jpem9udGFsXCIsIGNvbnN0cmFpbnRGbGFncyk7XG4gIH0gZWxzZSBpZiAoaW50ZXJzZWN0c1ZlcnRpY2FsKSB7XG4gICAgc2V0R2xvYmFsQ3Vyc29yU3R5bGUoXCJ2ZXJ0aWNhbFwiLCBjb25zdHJhaW50RmxhZ3MpO1xuICB9IGVsc2Uge1xuICAgIHJlc2V0R2xvYmFsQ3Vyc29yU3R5bGUoKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzKCkge1xuICBvd25lckRvY3VtZW50Q291bnRzLmZvckVhY2goKF8sIG93bmVyRG9jdW1lbnQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBib2R5XG4gICAgfSA9IG93bmVyRG9jdW1lbnQ7XG4gICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgICBib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSk7XG4gICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICBib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgfSk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBoYW5kbGVQb2ludGVyVXApO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIGhhbmRsZVBvaW50ZXJVcCk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgaWYgKHJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycy5zaXplID4gMCkge1xuICAgIGlmIChpc1BvaW50ZXJEb3duKSB7XG4gICAgICBpZiAoaW50ZXJzZWN0aW5nSGFuZGxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG93bmVyRG9jdW1lbnRDb3VudHMuZm9yRWFjaCgoY291bnQsIG93bmVyRG9jdW1lbnQpID0+IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBib2R5XG4gICAgICAgICAgfSA9IG93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgaGFuZGxlUG9pbnRlclVwKTtcbiAgICAgICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSwge1xuICAgICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBoYW5kbGVQb2ludGVyVXApO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBoYW5kbGVQb2ludGVyVXApO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBoYW5kbGVQb2ludGVyVXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25lckRvY3VtZW50Q291bnRzLmZvckVhY2goKGNvdW50LCBvd25lckRvY3VtZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBib2R5XG4gICAgICAgIH0gPSBvd25lckRvY3VtZW50O1xuICAgICAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBoYW5kbGVQb2ludGVyTW92ZSwge1xuICAgICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVSZXNpemVIYW5kbGVyU3RhdGVzKGFjdGlvbiwgZXZlbnQpIHtcbiAgcmVnaXN0ZXJlZFJlc2l6ZUhhbmRsZXJzLmZvckVhY2goZGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgc2V0UmVzaXplSGFuZGxlclN0YXRlXG4gICAgfSA9IGRhdGE7XG4gICAgY29uc3QgaXNBY3RpdmUgPSBpbnRlcnNlY3RpbmdIYW5kbGVzLmluY2x1ZGVzKGRhdGEpO1xuICAgIHNldFJlc2l6ZUhhbmRsZXJTdGF0ZShhY3Rpb24sIGlzQWN0aXZlLCBldmVudCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NlcnQoZXhwZWN0ZWRDb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKCFleHBlY3RlZENvbmRpdGlvbikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cblxuY29uc3QgUFJFQ0lTSU9OID0gMTA7XG5cbmZ1bmN0aW9uIGZ1enp5Q29tcGFyZU51bWJlcnMoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMgPSBQUkVDSVNJT04pIHtcbiAgYWN0dWFsID0gcGFyc2VGbG9hdChhY3R1YWwudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICBleHBlY3RlZCA9IHBhcnNlRmxvYXQoZXhwZWN0ZWQudG9GaXhlZChmcmFjdGlvbkRpZ2l0cykpO1xuICBjb25zdCBkZWx0YSA9IGFjdHVhbCAtIGV4cGVjdGVkO1xuICBpZiAoZGVsdGEgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVsdGEgPiAwID8gMSA6IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZ1enp5TnVtYmVyc0VxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZyYWN0aW9uRGlnaXRzKSB7XG4gIHJldHVybiBmdXp6eUNvbXBhcmVOdW1iZXJzKGFjdHVhbCwgZXhwZWN0ZWQsIGZyYWN0aW9uRGlnaXRzKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gZnV6enlMYXlvdXRzRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZnJhY3Rpb25EaWdpdHMpIHtcbiAgaWYgKGFjdHVhbC5sZW5ndGggIT09IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYWN0dWFsLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGFjdHVhbFNpemUgPSBhY3R1YWxbaW5kZXhdO1xuICAgIGNvbnN0IGV4cGVjdGVkU2l6ZSA9IGV4cGVjdGVkW2luZGV4XTtcbiAgICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKGFjdHVhbFNpemUsIGV4cGVjdGVkU2l6ZSwgZnJhY3Rpb25EaWdpdHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBQYW5lbCBzaXplIG11c3QgYmUgaW4gcGVyY2VudGFnZXM7IHBpeGVsIHZhbHVlcyBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZFxuZnVuY3Rpb24gcmVzaXplUGFuZWwoe1xuICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gIHBhbmVsSW5kZXgsXG4gIHNpemVcbn0pIHtcbiAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsQ29uc3RyYWludHNBcnJheVtwYW5lbEluZGV4XTtcbiAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMgIT0gbnVsbCwgYFBhbmVsIGNvbnN0cmFpbnRzIG5vdCBmb3VuZCBmb3IgaW5kZXggJHtwYW5lbEluZGV4fWApO1xuICBsZXQge1xuICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgIGNvbGxhcHNpYmxlLFxuICAgIG1heFNpemUgPSAxMDAsXG4gICAgbWluU2l6ZSA9IDBcbiAgfSA9IHBhbmVsQ29uc3RyYWludHM7XG4gIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKHNpemUsIG1pblNpemUpIDwgMCkge1xuICAgIGlmIChjb2xsYXBzaWJsZSkge1xuICAgICAgLy8gQ29sbGFwc2libGUgcGFuZWxzIHNob3VsZCBzbmFwIGNsb3NlZCBvciBvcGVuIG9ubHkgb25jZSB0aGV5IGNyb3NzIHRoZSBoYWxmd2F5IHBvaW50IGJldHdlZW4gY29sbGFwc2VkIGFuZCBtaW4gc2l6ZS5cbiAgICAgIGNvbnN0IGhhbGZ3YXlQb2ludCA9IChjb2xsYXBzZWRTaXplICsgbWluU2l6ZSkgLyAyO1xuICAgICAgaWYgKGZ1enp5Q29tcGFyZU51bWJlcnMoc2l6ZSwgaGFsZndheVBvaW50KSA8IDApIHtcbiAgICAgICAgc2l6ZSA9IGNvbGxhcHNlZFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gbWluU2l6ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IG1pblNpemU7XG4gICAgfVxuICB9XG4gIHNpemUgPSBNYXRoLm1pbihtYXhTaXplLCBzaXplKTtcbiAgc2l6ZSA9IHBhcnNlRmxvYXQoc2l6ZS50b0ZpeGVkKFBSRUNJU0lPTikpO1xuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gQWxsIHVuaXRzIG11c3QgYmUgaW4gcGVyY2VudGFnZXM7IHBpeGVsIHZhbHVlcyBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZFxuZnVuY3Rpb24gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gIGRlbHRhLFxuICBpbml0aWFsTGF5b3V0LFxuICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gIHBpdm90SW5kaWNlcyxcbiAgcHJldkxheW91dCxcbiAgdHJpZ2dlclxufSkge1xuICBpZiAoZnV6enlOdW1iZXJzRXF1YWwoZGVsdGEsIDApKSB7XG4gICAgcmV0dXJuIGluaXRpYWxMYXlvdXQ7XG4gIH1cbiAgY29uc3QgbmV4dExheW91dCA9IFsuLi5pbml0aWFsTGF5b3V0XTtcbiAgY29uc3QgW2ZpcnN0UGl2b3RJbmRleCwgc2Vjb25kUGl2b3RJbmRleF0gPSBwaXZvdEluZGljZXM7XG4gIGFzc2VydChmaXJzdFBpdm90SW5kZXggIT0gbnVsbCwgXCJJbnZhbGlkIGZpcnN0IHBpdm90IGluZGV4XCIpO1xuICBhc3NlcnQoc2Vjb25kUGl2b3RJbmRleCAhPSBudWxsLCBcIkludmFsaWQgc2Vjb25kIHBpdm90IGluZGV4XCIpO1xuICBsZXQgZGVsdGFBcHBsaWVkID0gMDtcblxuICAvLyBjb25zdCBERUJVRyA9IFtdO1xuICAvLyBERUJVRy5wdXNoKGBhZGp1c3RMYXlvdXRCeURlbHRhKClgKTtcbiAgLy8gREVCVUcucHVzaChgICBpbml0aWFsTGF5b3V0OiAke2luaXRpYWxMYXlvdXQuam9pbihcIiwgXCIpfWApO1xuICAvLyBERUJVRy5wdXNoKGAgIHByZXZMYXlvdXQ6ICR7cHJldkxheW91dC5qb2luKFwiLCBcIil9YCk7XG4gIC8vIERFQlVHLnB1c2goYCAgZGVsdGE6ICR7ZGVsdGF9YCk7XG4gIC8vIERFQlVHLnB1c2goYCAgcGl2b3RJbmRpY2VzOiAke3Bpdm90SW5kaWNlcy5qb2luKFwiLCBcIil9YCk7XG4gIC8vIERFQlVHLnB1c2goYCAgdHJpZ2dlcjogJHt0cmlnZ2VyfWApO1xuICAvLyBERUJVRy5wdXNoKFwiXCIpO1xuXG4gIC8vIEEgcmVzaXppbmcgcGFuZWwgYWZmZWN0cyB0aGUgcGFuZWxzIGJlZm9yZSBvciBhZnRlciBpdC5cbiAgLy9cbiAgLy8gQSBuZWdhdGl2ZSBkZWx0YSBtZWFucyB0aGUgcGFuZWwocykgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHJlc2l6ZSBoYW5kbGUgc2hvdWxkIGdyb3cvZXhwYW5kIGJ5IGRlY3JlYXNpbmcgaXRzIG9mZnNldC5cbiAgLy8gT3RoZXIgcGFuZWxzIG1heSBhbHNvIG5lZWQgdG8gc2hyaW5rL2NvbnRyYWN0IChhbmQgc2hpZnQpIHRvIG1ha2Ugcm9vbSwgZGVwZW5kaW5nIG9uIHRoZSBtaW4gd2VpZ2h0cy5cbiAgLy9cbiAgLy8gQSBwb3NpdGl2ZSBkZWx0YSBtZWFucyB0aGUgcGFuZWwocykgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSByZXNpemUgaGFuZGxlIHNob3VsZCBcImV4cGFuZFwiLlxuICAvLyBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBzaHJpbmtpbmcvY29udHJhY3RpbmcgKGFuZCBzaGlmdGluZykgb25lIG9yIG1vcmUgb2YgdGhlIHBhbmVscyBhZnRlciB0aGUgcmVzaXplIGhhbmRsZS5cblxuICB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIHJlc2l6ZSB0cmlnZ2VyZWQgYnkgYSBrZXlib2FyZCBldmVudCwgb3VyIGxvZ2ljIGZvciBleHBhbmRpbmcvY29sbGFwc2luZyBpcyBkaWZmZXJlbnQuXG4gICAgLy8gV2Ugbm8gbG9uZ2VyIGNoZWNrIHRoZSBoYWxmd2F5IHRocmVzaG9sZCBiZWNhdXNlIHRoaXMgbWF5IHByZXZlbnQgdGhlIHBhbmVsIGZyb20gZXhwYW5kaW5nIGF0IGFsbC5cbiAgICBpZiAodHJpZ2dlciA9PT0gXCJrZXlib2FyZFwiKSB7XG4gICAgICB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBleHBhbmQgYSBjb2xsYXBzZWQgcGFuZWxcbiAgICAgICAgY29uc3QgaW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMsIGBQYW5lbCBjb25zdHJhaW50cyBub3QgZm91bmQgZm9yIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgICAgICBjb2xsYXBzaWJsZSxcbiAgICAgICAgICBtaW5TaXplID0gMFxuICAgICAgICB9ID0gcGFuZWxDb25zdHJhaW50cztcblxuICAgICAgICAvLyBERUJVRy5wdXNoKGBlZGdlIGNhc2UgY2hlY2sgMTogJHtpbmRleH1gKTtcbiAgICAgICAgLy8gREVCVUcucHVzaChgICAtPiBjb2xsYXBzaWJsZT8gJHtjb2xsYXBzaWJsZX1gKTtcbiAgICAgICAgaWYgKGNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgY29uc3QgcHJldlNpemUgPSBpbml0aWFsTGF5b3V0W2luZGV4XTtcbiAgICAgICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCwgYFByZXZpb3VzIGxheW91dCBub3QgZm91bmQgZm9yIHBhbmVsIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgICAgaWYgKGZ1enp5TnVtYmVyc0VxdWFsKHByZXZTaXplLCBjb2xsYXBzZWRTaXplKSkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxEZWx0YSA9IG1pblNpemUgLSBwcmV2U2l6ZTtcbiAgICAgICAgICAgIC8vIERFQlVHLnB1c2goYCAgLT4gZXhwYW5kIGRlbHRhOiAke2xvY2FsRGVsdGF9YCk7XG5cbiAgICAgICAgICAgIGlmIChmdXp6eUNvbXBhcmVOdW1iZXJzKGxvY2FsRGVsdGEsIE1hdGguYWJzKGRlbHRhKSkgPiAwKSB7XG4gICAgICAgICAgICAgIGRlbHRhID0gZGVsdGEgPCAwID8gMCAtIGxvY2FsRGVsdGEgOiBsb2NhbERlbHRhO1xuICAgICAgICAgICAgICAvLyBERUJVRy5wdXNoKGAgIC0+IGRlbHRhOiAke2RlbHRhfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBhIHBhbmVsIGF0IGl0cyBtaW5pbXVtIHNpemVcbiAgICAgICAgY29uc3QgaW5kZXggPSBkZWx0YSA8IDAgPyBmaXJzdFBpdm90SW5kZXggOiBzZWNvbmRQaXZvdEluZGV4O1xuICAgICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W2luZGV4XTtcbiAgICAgICAgYXNzZXJ0KHBhbmVsQ29uc3RyYWludHMsIGBObyBwYW5lbCBjb25zdHJhaW50cyBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICAgIGNvbGxhcHNpYmxlLFxuICAgICAgICAgIG1pblNpemUgPSAwXG4gICAgICAgIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuXG4gICAgICAgIC8vIERFQlVHLnB1c2goYGVkZ2UgY2FzZSBjaGVjayAyOiAke2luZGV4fWApO1xuICAgICAgICAvLyBERUJVRy5wdXNoKGAgIC0+IGNvbGxhcHNpYmxlPyAke2NvbGxhcHNpYmxlfWApO1xuICAgICAgICBpZiAoY29sbGFwc2libGUpIHtcbiAgICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IGluaXRpYWxMYXlvdXRbaW5kZXhdO1xuICAgICAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgUHJldmlvdXMgbGF5b3V0IG5vdCBmb3VuZCBmb3IgcGFuZWwgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgICAgICBpZiAoZnV6enlOdW1iZXJzRXF1YWwocHJldlNpemUsIG1pblNpemUpKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbERlbHRhID0gcHJldlNpemUgLSBjb2xsYXBzZWRTaXplO1xuICAgICAgICAgICAgLy8gREVCVUcucHVzaChgICAtPiBleHBhbmQgZGVsdGE6ICR7bG9jYWxEZWx0YX1gKTtcblxuICAgICAgICAgICAgaWYgKGZ1enp5Q29tcGFyZU51bWJlcnMobG9jYWxEZWx0YSwgTWF0aC5hYnMoZGVsdGEpKSA+IDApIHtcbiAgICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSA8IDAgPyAwIC0gbG9jYWxEZWx0YSA6IGxvY2FsRGVsdGE7XG4gICAgICAgICAgICAgIC8vIERFQlVHLnB1c2goYCAgLT4gZGVsdGE6ICR7ZGVsdGF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIERFQlVHLnB1c2goXCJcIik7XG4gIH1cblxuICB7XG4gICAgLy8gUHJlLWNhbGN1bGF0ZSBtYXggYXZhaWxhYmxlIGRlbHRhIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gb2Ygb3VyIHBpdm90LlxuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgbWF4aW11bSBhbW91bnQgd2UncmUgYWxsb3dlZCB0byBleHBhbmQvY29udHJhY3QgdGhlIHBhbmVscyBpbiB0aGUgcHJpbWFyeSBkaXJlY3Rpb24uXG4gICAgLy8gSWYgdGhpcyBhbW91bnQgaXMgbGVzcyB0aGFuIHRoZSByZXF1ZXN0ZWQgZGVsdGEsIGFkanVzdCB0aGUgcmVxdWVzdGVkIGRlbHRhLlxuICAgIC8vIElmIHRoaXMgYW1vdW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVxdWVzdGVkIGRlbHRhLCB0aGF0J3MgdXNlZnVsIGluZm9ybWF0aW9uIHRvb+KAk1xuICAgIC8vIGFzIGFuIGV4cGFuZGluZyBwYW5lbCBtaWdodCBjaGFuZ2UgZnJvbSBjb2xsYXBzZWQgdG8gbWluIHNpemUuXG5cbiAgICBjb25zdCBpbmNyZW1lbnQgPSBkZWx0YSA8IDAgPyAxIDogLTE7XG4gICAgbGV0IGluZGV4ID0gZGVsdGEgPCAwID8gc2Vjb25kUGl2b3RJbmRleCA6IGZpcnN0UGl2b3RJbmRleDtcbiAgICBsZXQgbWF4QXZhaWxhYmxlRGVsdGEgPSAwO1xuXG4gICAgLy8gREVCVUcucHVzaChcInByZSBjYWxjLi4uXCIpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCBwcmV2U2l6ZSA9IGluaXRpYWxMYXlvdXRbaW5kZXhdO1xuICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwsIGBQcmV2aW91cyBsYXlvdXQgbm90IGZvdW5kIGZvciBwYW5lbCBpbmRleCAke2luZGV4fWApO1xuICAgICAgY29uc3QgbWF4U2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgICAgcGFuZWxJbmRleDogaW5kZXgsXG4gICAgICAgIHNpemU6IDEwMFxuICAgICAgfSk7XG4gICAgICBjb25zdCBkZWx0YSA9IG1heFNhZmVTaXplIC0gcHJldlNpemU7XG4gICAgICAvLyBERUJVRy5wdXNoKGAgICR7aW5kZXh9OiAke3ByZXZTaXplfSAtPiAke21heFNhZmVTaXplfWApO1xuXG4gICAgICBtYXhBdmFpbGFibGVEZWx0YSArPSBkZWx0YTtcbiAgICAgIGluZGV4ICs9IGluY3JlbWVudDtcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gcGFuZWxDb25zdHJhaW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBERUJVRy5wdXNoKGAgIC0+IG1heCBhdmFpbGFibGUgZGVsdGE6ICR7bWF4QXZhaWxhYmxlRGVsdGF9YCk7XG4gICAgY29uc3QgbWluQWJzRGVsdGEgPSBNYXRoLm1pbihNYXRoLmFicyhkZWx0YSksIE1hdGguYWJzKG1heEF2YWlsYWJsZURlbHRhKSk7XG4gICAgZGVsdGEgPSBkZWx0YSA8IDAgPyAwIC0gbWluQWJzRGVsdGEgOiBtaW5BYnNEZWx0YTtcbiAgICAvLyBERUJVRy5wdXNoKGAgIC0+IGFkanVzdGVkIGRlbHRhOiAke2RlbHRhfWApO1xuICAgIC8vIERFQlVHLnB1c2goXCJcIik7XG4gIH1cblxuICB7XG4gICAgLy8gRGVsdGEgYWRkZWQgdG8gYSBwYW5lbCBuZWVkcyB0byBiZSBzdWJ0cmFjdGVkIGZyb20gb3RoZXIgcGFuZWxzICh3aXRoaW4gdGhlIGNvbnN0cmFpbnRzIHRoYXQgdGhvc2UgcGFuZWxzIGFsbG93KS5cblxuICAgIGNvbnN0IHBpdm90SW5kZXggPSBkZWx0YSA8IDAgPyBmaXJzdFBpdm90SW5kZXggOiBzZWNvbmRQaXZvdEluZGV4O1xuICAgIGxldCBpbmRleCA9IHBpdm90SW5kZXg7XG4gICAgd2hpbGUgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwYW5lbENvbnN0cmFpbnRzQXJyYXkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZWx0YVJlbWFpbmluZyA9IE1hdGguYWJzKGRlbHRhKSAtIE1hdGguYWJzKGRlbHRhQXBwbGllZCk7XG4gICAgICBjb25zdCBwcmV2U2l6ZSA9IGluaXRpYWxMYXlvdXRbaW5kZXhdO1xuICAgICAgYXNzZXJ0KHByZXZTaXplICE9IG51bGwsIGBQcmV2aW91cyBsYXlvdXQgbm90IGZvdW5kIGZvciBwYW5lbCBpbmRleCAke2luZGV4fWApO1xuICAgICAgY29uc3QgdW5zYWZlU2l6ZSA9IHByZXZTaXplIC0gZGVsdGFSZW1haW5pbmc7XG4gICAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgICAgfSk7XG4gICAgICBpZiAoIWZ1enp5TnVtYmVyc0VxdWFsKHByZXZTaXplLCBzYWZlU2l6ZSkpIHtcbiAgICAgICAgZGVsdGFBcHBsaWVkICs9IHByZXZTaXplIC0gc2FmZVNpemU7XG4gICAgICAgIG5leHRMYXlvdXRbaW5kZXhdID0gc2FmZVNpemU7XG4gICAgICAgIGlmIChkZWx0YUFwcGxpZWQudG9QcmVjaXNpb24oMykubG9jYWxlQ29tcGFyZShNYXRoLmFicyhkZWx0YSkudG9QcmVjaXNpb24oMyksIHVuZGVmaW5lZCwge1xuICAgICAgICAgIG51bWVyaWM6IHRydWVcbiAgICAgICAgfSkgPj0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGVsdGEgPCAwKSB7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBERUJVRy5wdXNoKGBhZnRlciAxOiAke25leHRMYXlvdXQuam9pbihcIiwgXCIpfWApO1xuICAvLyBERUJVRy5wdXNoKGAgIGRlbHRhQXBwbGllZDogJHtkZWx0YUFwcGxpZWR9YCk7XG4gIC8vIERFQlVHLnB1c2goXCJcIik7XG5cbiAgLy8gSWYgd2Ugd2VyZSB1bmFibGUgdG8gcmVzaXplIGFueSBvZiB0aGUgcGFuZWxzIHBhbmVscywgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgLy8gVGhpcyB3aWxsIGVzc2VudGlhbGx5IGJhaWxvdXQgYW5kIGlnbm9yZSBlLmcuIGRyYWdzIHBhc3QgYSBwYW5lbCdzIGJvdW5kYXJpZXNcbiAgaWYgKGZ1enp5TGF5b3V0c0VxdWFsKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgLy8gREVCVUcucHVzaChgYmFpbG91dCB0byBwcmV2aW91cyBsYXlvdXQ6ICR7cHJldkxheW91dC5qb2luKFwiLCBcIil9YCk7XG4gICAgLy8gY29uc29sZS5sb2coREVCVUcuam9pbihcIlxcblwiKSk7XG5cbiAgICByZXR1cm4gcHJldkxheW91dDtcbiAgfVxuICB7XG4gICAgLy8gTm93IGRpc3RyaWJ1dGUgdGhlIGFwcGxpZWQgZGVsdGEgdG8gdGhlIHBhbmVscyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uXG4gICAgY29uc3QgcGl2b3RJbmRleCA9IGRlbHRhIDwgMCA/IHNlY29uZFBpdm90SW5kZXggOiBmaXJzdFBpdm90SW5kZXg7XG4gICAgY29uc3QgcHJldlNpemUgPSBpbml0aWFsTGF5b3V0W3Bpdm90SW5kZXhdO1xuICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgUHJldmlvdXMgbGF5b3V0IG5vdCBmb3VuZCBmb3IgcGFuZWwgaW5kZXggJHtwaXZvdEluZGV4fWApO1xuICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSArIGRlbHRhQXBwbGllZDtcbiAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgIHBhbmVsSW5kZXg6IHBpdm90SW5kZXgsXG4gICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgfSk7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBpdm90IHBhbmVsIGJlZm9yZSwgYnV0IG9ubHkgYnkgdGhlIGFtb3VudCB0aGF0IHN1cnJvdW5kaW5nIHBhbmVscyB3ZXJlIGFibGUgdG8gc2hyaW5rL2NvbnRyYWN0LlxuICAgIG5leHRMYXlvdXRbcGl2b3RJbmRleF0gPSBzYWZlU2l6ZTtcblxuICAgIC8vIEVkZ2UgY2FzZSB3aGVyZSBleHBhbmRpbmcgb3IgY29udHJhY3Rpbmcgb25lIHBhbmVsIGNhdXNlZCBhbm90aGVyIG9uZSB0byBjaGFuZ2UgY29sbGFwc2VkIHN0YXRlXG4gICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChzYWZlU2l6ZSwgdW5zYWZlU2l6ZSkpIHtcbiAgICAgIGxldCBkZWx0YVJlbWFpbmluZyA9IHVuc2FmZVNpemUgLSBzYWZlU2l6ZTtcbiAgICAgIGNvbnN0IHBpdm90SW5kZXggPSBkZWx0YSA8IDAgPyBzZWNvbmRQaXZvdEluZGV4IDogZmlyc3RQaXZvdEluZGV4O1xuICAgICAgbGV0IGluZGV4ID0gcGl2b3RJbmRleDtcbiAgICAgIHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDwgcGFuZWxDb25zdHJhaW50c0FycmF5Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgICAgICBhc3NlcnQocHJldlNpemUgIT0gbnVsbCwgYFByZXZpb3VzIGxheW91dCBub3QgZm91bmQgZm9yIHBhbmVsIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBwcmV2U2l6ZSArIGRlbHRhUmVtYWluaW5nO1xuICAgICAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbENvbnN0cmFpbnRzQXJyYXksXG4gICAgICAgICAgcGFuZWxJbmRleDogaW5kZXgsXG4gICAgICAgICAgc2l6ZTogdW5zYWZlU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChwcmV2U2l6ZSwgc2FmZVNpemUpKSB7XG4gICAgICAgICAgZGVsdGFSZW1haW5pbmcgLT0gc2FmZVNpemUgLSBwcmV2U2l6ZTtcbiAgICAgICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChkZWx0YVJlbWFpbmluZywgMCkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEgPiAwKSB7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIERFQlVHLnB1c2goYGFmdGVyIDI6ICR7bmV4dExheW91dC5qb2luKFwiLCBcIil9YCk7XG4gIC8vIERFQlVHLnB1c2goYCAgZGVsdGFBcHBsaWVkOiAke2RlbHRhQXBwbGllZH1gKTtcbiAgLy8gREVCVUcucHVzaChcIlwiKTtcblxuICBjb25zdCB0b3RhbFNpemUgPSBuZXh0TGF5b3V0LnJlZHVjZSgodG90YWwsIHNpemUpID0+IHNpemUgKyB0b3RhbCwgMCk7XG4gIC8vIERFQlVHLnB1c2goYHRvdGFsIHNpemU6ICR7dG90YWxTaXplfWApO1xuXG4gIC8vIElmIG91ciBuZXcgbGF5b3V0IGRvZXNuJ3QgYWRkIHVwIHRvIDEwMCUsIHRoYXQgbWVhbnMgdGhlIHJlcXVlc3RlZCBkZWx0YSBjYW4ndCBiZSBhcHBsaWVkXG4gIC8vIEluIHRoYXQgY2FzZSwgZmFsbCBiYWNrIHRvIG91ciBtb3N0IHJlY2VudCB2YWxpZCBsYXlvdXRcbiAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbCh0b3RhbFNpemUsIDEwMCkpIHtcbiAgICAvLyBERUJVRy5wdXNoKGBiYWlsb3V0IHRvIHByZXZpb3VzIGxheW91dDogJHtwcmV2TGF5b3V0LmpvaW4oXCIsIFwiKX1gKTtcbiAgICAvLyBjb25zb2xlLmxvZyhERUJVRy5qb2luKFwiXFxuXCIpKTtcblxuICAgIHJldHVybiBwcmV2TGF5b3V0O1xuICB9XG5cbiAgLy8gY29uc29sZS5sb2coREVCVUcuam9pbihcIlxcblwiKSk7XG4gIHJldHVybiBuZXh0TGF5b3V0O1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVFbGVtZW50c0Zvckdyb3VwKGdyb3VwSWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oc2NvcGUucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtcGFuZWwtcmVzaXplLWhhbmRsZS1pZF1bZGF0YS1wYW5lbC1ncm91cC1pZD1cIiR7Z3JvdXBJZH1cIl1gKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRJbmRleChncm91cElkLCBpZCwgc2NvcGUgPSBkb2N1bWVudCkge1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBzY29wZSk7XG4gIGNvbnN0IGluZGV4ID0gaGFuZGxlcy5maW5kSW5kZXgoaGFuZGxlID0+IGhhbmRsZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIikgPT09IGlkKTtcbiAgcmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRldGVybWluZVBpdm90SW5kaWNlcyhncm91cElkLCBkcmFnSGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KSB7XG4gIGNvbnN0IGluZGV4ID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudEluZGV4KGdyb3VwSWQsIGRyYWdIYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICByZXR1cm4gaW5kZXggIT0gbnVsbCA/IFtpbmRleCwgaW5kZXggKyAxXSA6IFstMSwgLTFdO1xufVxuXG5mdW5jdGlvbiBnZXRQYW5lbEdyb3VwRWxlbWVudChpZCwgcm9vdEVsZW1lbnQgPSBkb2N1bWVudCkge1xuICB2YXIgX2RhdGFzZXQ7XG4gIC8vSWYgdGhlIHJvb3QgZWxlbWVudCBpcyB0aGUgUGFuZWxHcm91cFxuICBpZiAocm9vdEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiAocm9vdEVsZW1lbnQgPT09IG51bGwgfHwgcm9vdEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZGF0YXNldCA9IHJvb3RFbGVtZW50LmRhdGFzZXQpID09PSBudWxsIHx8IF9kYXRhc2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZGF0YXNldC5wYW5lbEdyb3VwSWQpID09IGlkKSB7XG4gICAgcmV0dXJuIHJvb3RFbGVtZW50O1xuICB9XG5cbiAgLy9FbHNlIHF1ZXJ5IGNoaWxkcmVuXG4gIGNvbnN0IGVsZW1lbnQgPSByb290RWxlbWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1ncm91cF1bZGF0YS1wYW5lbC1ncm91cC1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQoaWQsIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgY29uc3QgZWxlbWVudCA9IHNjb3BlLnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWQ9XCIke2lkfVwiXWApO1xuICBpZiAoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxzQXJyYXksIHNjb3BlID0gZG9jdW1lbnQpIHtcbiAgdmFyIF9wYW5lbHNBcnJheSRpbmRleCRpZCwgX3BhbmVsc0FycmF5JGluZGV4LCBfcGFuZWxzQXJyYXkkaWQsIF9wYW5lbHNBcnJheTtcbiAgY29uc3QgaGFuZGxlID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudChoYW5kbGVJZCwgc2NvcGUpO1xuICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBzY29wZSk7XG4gIGNvbnN0IGluZGV4ID0gaGFuZGxlID8gaGFuZGxlcy5pbmRleE9mKGhhbmRsZSkgOiAtMTtcbiAgY29uc3QgaWRCZWZvcmUgPSAoX3BhbmVsc0FycmF5JGluZGV4JGlkID0gKF9wYW5lbHNBcnJheSRpbmRleCA9IHBhbmVsc0FycmF5W2luZGV4XSkgPT09IG51bGwgfHwgX3BhbmVsc0FycmF5JGluZGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGFuZWxzQXJyYXkkaW5kZXguaWQpICE9PSBudWxsICYmIF9wYW5lbHNBcnJheSRpbmRleCRpZCAhPT0gdm9pZCAwID8gX3BhbmVsc0FycmF5JGluZGV4JGlkIDogbnVsbDtcbiAgY29uc3QgaWRBZnRlciA9IChfcGFuZWxzQXJyYXkkaWQgPSAoX3BhbmVsc0FycmF5ID0gcGFuZWxzQXJyYXlbaW5kZXggKyAxXSkgPT09IG51bGwgfHwgX3BhbmVsc0FycmF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGFuZWxzQXJyYXkuaWQpICE9PSBudWxsICYmIF9wYW5lbHNBcnJheSRpZCAhPT0gdm9pZCAwID8gX3BhbmVsc0FycmF5JGlkIDogbnVsbDtcbiAgcmV0dXJuIFtpZEJlZm9yZSwgaWRBZnRlcl07XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvQVJJQS9hcGcvcGF0dGVybnMvd2luZG93c3BsaXR0ZXIvXG5cbmZ1bmN0aW9uIHVzZVdpbmRvd1NwbGl0dGVyUGFuZWxHcm91cEJlaGF2aW9yKHtcbiAgY29tbWl0dGVkVmFsdWVzUmVmLFxuICBlYWdlclZhbHVlc1JlZixcbiAgZ3JvdXBJZCxcbiAgbGF5b3V0LFxuICBwYW5lbERhdGFBcnJheSxcbiAgcGFuZWxHcm91cEVsZW1lbnQsXG4gIHNldExheW91dFxufSkge1xuICB1c2VSZWYoe1xuICAgIGRpZFdhcm5BYm91dE1pc3NpbmdSZXNpemVIYW5kbGU6IGZhbHNlXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcGFuZWxHcm91cEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWFnZXJWYWx1ZXMgPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGFzc2VydChlYWdlclZhbHVlcywgYEVhZ2VyIHZhbHVlcyBub3QgZm91bmRgKTtcbiAgICBjb25zdCB7XG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlcztcbiAgICBjb25zdCBncm91cEVsZW1lbnQgPSBnZXRQYW5lbEdyb3VwRWxlbWVudChncm91cElkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgYXNzZXJ0KGdyb3VwRWxlbWVudCAhPSBudWxsLCBgTm8gZ3JvdXAgZm91bmQgZm9yIGlkIFwiJHtncm91cElkfVwiYCk7XG4gICAgY29uc3QgaGFuZGxlcyA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRzRm9yR3JvdXAoZ3JvdXBJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgIGFzc2VydChoYW5kbGVzLCBgTm8gcmVzaXplIGhhbmRsZXMgZm91bmQgZm9yIGdyb3VwIGlkIFwiJHtncm91cElkfVwiYCk7XG4gICAgY29uc3QgY2xlYW51cEZ1bmN0aW9ucyA9IGhhbmRsZXMubWFwKGhhbmRsZSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVJZCA9IGhhbmRsZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIik7XG4gICAgICBhc3NlcnQoaGFuZGxlSWQsIGBSZXNpemUgaGFuZGxlIGVsZW1lbnQgaGFzIG5vIGhhbmRsZSBpZCBhdHRyaWJ1dGVgKTtcbiAgICAgIGNvbnN0IFtpZEJlZm9yZSwgaWRBZnRlcl0gPSBnZXRSZXNpemVIYW5kbGVQYW5lbElkcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxEYXRhQXJyYXksIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICAgIGlmIChpZEJlZm9yZSA9PSBudWxsIHx8IGlkQWZ0ZXIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFuZWxEYXRhQXJyYXkuZmluZEluZGV4KHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuaWQgPT09IGlkQmVmb3JlKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lbERhdGEgPSBwYW5lbERhdGFBcnJheVtpbmRleF07XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHBhbmVsRGF0YSwgYE5vIHBhbmVsIGRhdGEgZm91bmQgZm9yIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGxheW91dFtpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgICAgY29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICAgICAgICAgICAgICBjb2xsYXBzaWJsZSxcbiAgICAgICAgICAgICAgICAgIG1pblNpemUgPSAwXG4gICAgICAgICAgICAgICAgfSA9IHBhbmVsRGF0YS5jb25zdHJhaW50cztcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSAhPSBudWxsICYmIGNvbGxhcHNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBuZXh0TGF5b3V0ID0gYWRqdXN0TGF5b3V0QnlEZWx0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhOiBmdXp6eU51bWJlcnNFcXVhbChzaXplLCBjb2xsYXBzZWRTaXplKSA/IG1pblNpemUgLSBjb2xsYXBzZWRTaXplIDogY29sbGFwc2VkU2l6ZSAtIHNpemUsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxMYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpLFxuICAgICAgICAgICAgICAgICAgICBwaXZvdEluZGljZXM6IGRldGVybWluZVBpdm90SW5kaWNlcyhncm91cElkLCBoYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpLFxuICAgICAgICAgICAgICAgICAgICBwcmV2TGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IFwia2V5Ym9hcmRcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5b3V0ICE9PSBuZXh0TGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldExheW91dChuZXh0TGF5b3V0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGhhbmRsZS5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cEZ1bmN0aW9ucy5mb3JFYWNoKGNsZWFudXBGdW5jdGlvbiA9PiBjbGVhbnVwRnVuY3Rpb24oKSk7XG4gICAgfTtcbiAgfSwgW3BhbmVsR3JvdXBFbGVtZW50LCBjb21taXR0ZWRWYWx1ZXNSZWYsIGVhZ2VyVmFsdWVzUmVmLCBncm91cElkLCBsYXlvdXQsIHBhbmVsRGF0YUFycmF5LCBzZXRMYXlvdXRdKTtcbn1cblxuZnVuY3Rpb24gYXJlRXF1YWwoYXJyYXlBLCBhcnJheUIpIHtcbiAgaWYgKGFycmF5QS5sZW5ndGggIT09IGFycmF5Qi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGFycmF5QS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoYXJyYXlBW2luZGV4XSAhPT0gYXJyYXlCW2luZGV4XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVzaXplRXZlbnRDdXJzb3JQb3NpdGlvbihkaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGRpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCI7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IGdldFJlc2l6ZUV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpO1xuICByZXR1cm4gaXNIb3Jpem9udGFsID8geCA6IHk7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZURyYWdPZmZzZXRQZXJjZW50YWdlKGV2ZW50LCBkcmFnSGFuZGxlSWQsIGRpcmVjdGlvbiwgaW5pdGlhbERyYWdTdGF0ZSwgcGFuZWxHcm91cEVsZW1lbnQpIHtcbiAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgY29uc3QgaGFuZGxlRWxlbWVudCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQoZHJhZ0hhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gIGFzc2VydChoYW5kbGVFbGVtZW50LCBgTm8gcmVzaXplIGhhbmRsZSBlbGVtZW50IGZvdW5kIGZvciBpZCBcIiR7ZHJhZ0hhbmRsZUlkfVwiYCk7XG4gIGNvbnN0IGdyb3VwSWQgPSBoYW5kbGVFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIik7XG4gIGFzc2VydChncm91cElkLCBgUmVzaXplIGhhbmRsZSBlbGVtZW50IGhhcyBubyBncm91cCBpZCBhdHRyaWJ1dGVgKTtcbiAgbGV0IHtcbiAgICBpbml0aWFsQ3Vyc29yUG9zaXRpb25cbiAgfSA9IGluaXRpYWxEcmFnU3RhdGU7XG4gIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gZ2V0UmVzaXplRXZlbnRDdXJzb3JQb3NpdGlvbihkaXJlY3Rpb24sIGV2ZW50KTtcbiAgY29uc3QgZ3JvdXBFbGVtZW50ID0gZ2V0UGFuZWxHcm91cEVsZW1lbnQoZ3JvdXBJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICBhc3NlcnQoZ3JvdXBFbGVtZW50LCBgTm8gZ3JvdXAgZWxlbWVudCBmb3VuZCBmb3IgaWQgXCIke2dyb3VwSWR9XCJgKTtcbiAgY29uc3QgZ3JvdXBSZWN0ID0gZ3JvdXBFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBncm91cFNpemVJblBpeGVscyA9IGlzSG9yaXpvbnRhbCA/IGdyb3VwUmVjdC53aWR0aCA6IGdyb3VwUmVjdC5oZWlnaHQ7XG4gIGNvbnN0IG9mZnNldFBpeGVscyA9IGN1cnNvclBvc2l0aW9uIC0gaW5pdGlhbEN1cnNvclBvc2l0aW9uO1xuICBjb25zdCBvZmZzZXRQZXJjZW50YWdlID0gb2Zmc2V0UGl4ZWxzIC8gZ3JvdXBTaXplSW5QaXhlbHMgKiAxMDA7XG4gIHJldHVybiBvZmZzZXRQZXJjZW50YWdlO1xufVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9tb3ZlbWVudFhcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhUGVyY2VudGFnZShldmVudCwgZHJhZ0hhbmRsZUlkLCBkaXJlY3Rpb24sIGluaXRpYWxEcmFnU3RhdGUsIGtleWJvYXJkUmVzaXplQnksIHBhbmVsR3JvdXBFbGVtZW50KSB7XG4gIGlmIChpc0tleURvd24oZXZlbnQpKSB7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgICBsZXQgZGVsdGEgPSAwO1xuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgZGVsdGEgPSAxMDA7XG4gICAgfSBlbHNlIGlmIChrZXlib2FyZFJlc2l6ZUJ5ICE9IG51bGwpIHtcbiAgICAgIGRlbHRhID0ga2V5Ym9hcmRSZXNpemVCeTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsdGEgPSAxMDtcbiAgICB9XG4gICAgbGV0IG1vdmVtZW50ID0gMDtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSBcIkFycm93RG93blwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IDAgOiBkZWx0YTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgIG1vdmVtZW50ID0gaXNIb3Jpem9udGFsID8gLWRlbHRhIDogMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dSaWdodFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IGRlbHRhIDogMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICBtb3ZlbWVudCA9IGlzSG9yaXpvbnRhbCA/IDAgOiAtZGVsdGE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBtb3ZlbWVudCA9IDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICBtb3ZlbWVudCA9IC0xMDA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbW92ZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGluaXRpYWxEcmFnU3RhdGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBjYWxjdWxhdGVEcmFnT2Zmc2V0UGVyY2VudGFnZShldmVudCwgZHJhZ0hhbmRsZUlkLCBkaXJlY3Rpb24sIGluaXRpYWxEcmFnU3RhdGUsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgfVxufVxuXG4vLyBMYXlvdXQgc2hvdWxkIGJlIHByZS1jb252ZXJ0ZWQgaW50byBwZXJjZW50YWdlc1xuZnVuY3Rpb24gY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsc0FycmF5LCBsYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXApIHtcbiAgbGF5b3V0LmZvckVhY2goKHNpemUsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcGFuZWxEYXRhID0gcGFuZWxzQXJyYXlbaW5kZXhdO1xuICAgIGFzc2VydChwYW5lbERhdGEsIGBQYW5lbCBkYXRhIG5vdCBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFja3MsXG4gICAgICBjb25zdHJhaW50cyxcbiAgICAgIGlkOiBwYW5lbElkXG4gICAgfSA9IHBhbmVsRGF0YTtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlXG4gICAgfSA9IGNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IGxhc3ROb3RpZmllZFNpemUgPSBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwW3BhbmVsSWRdO1xuICAgIGlmIChsYXN0Tm90aWZpZWRTaXplID09IG51bGwgfHwgc2l6ZSAhPT0gbGFzdE5vdGlmaWVkU2l6ZSkge1xuICAgICAgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFtwYW5lbElkXSA9IHNpemU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uQ29sbGFwc2UsXG4gICAgICAgIG9uRXhwYW5kLFxuICAgICAgICBvblJlc2l6ZVxuICAgICAgfSA9IGNhbGxiYWNrcztcbiAgICAgIGlmIChvblJlc2l6ZSkge1xuICAgICAgICBvblJlc2l6ZShzaXplLCBsYXN0Tm90aWZpZWRTaXplKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2xsYXBzaWJsZSAmJiAob25Db2xsYXBzZSB8fCBvbkV4cGFuZCkpIHtcbiAgICAgICAgaWYgKG9uRXhwYW5kICYmIChsYXN0Tm90aWZpZWRTaXplID09IG51bGwgfHwgbGFzdE5vdGlmaWVkU2l6ZSA9PT0gY29sbGFwc2VkU2l6ZSkgJiYgc2l6ZSAhPT0gY29sbGFwc2VkU2l6ZSkge1xuICAgICAgICAgIG9uRXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ29sbGFwc2UgJiYgKGxhc3ROb3RpZmllZFNpemUgPT0gbnVsbCB8fCBsYXN0Tm90aWZpZWRTaXplICE9PSBjb2xsYXBzZWRTaXplKSAmJiBzaXplID09PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgICAgb25Db2xsYXBzZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUxheW91dHMoYSwgYikge1xuICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGFbaW5kZXhdICE9IGJbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIFRoaXMgbWV0aG9kIHJldHVybnMgYSBudW1iZXIgYmV0d2VlbiAxIGFuZCAxMDAgcmVwcmVzZW50aW5nXG5cbi8vIHRoZSAlIG9mIHRoZSBncm91cCdzIG92ZXJhbGwgc3BhY2UgdGhpcyBwYW5lbCBzaG91bGQgb2NjdXB5LlxuZnVuY3Rpb24gY29tcHV0ZVBhbmVsRmxleEJveFN0eWxlKHtcbiAgZGVmYXVsdFNpemUsXG4gIGRyYWdTdGF0ZSxcbiAgbGF5b3V0LFxuICBwYW5lbERhdGEsXG4gIHBhbmVsSW5kZXgsXG4gIHByZWNpc2lvbiA9IDNcbn0pIHtcbiAgY29uc3Qgc2l6ZSA9IGxheW91dFtwYW5lbEluZGV4XTtcbiAgbGV0IGZsZXhHcm93O1xuICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgLy8gSW5pdGlhbCByZW5kZXIgKGJlZm9yZSBwYW5lbHMgaGF2ZSByZWdpc3RlcmVkIHRoZW1zZWx2ZXMpXG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCBzZXJ2ZXIgcmVuZGVyaW5nLCBmYWxsIGJhY2sgdG8gZGVmYXVsdCBzaXplIGlmIHByb3ZpZGVkXG4gICAgZmxleEdyb3cgPSBkZWZhdWx0U2l6ZSAhPSB1bmRlZmluZWQgPyBkZWZhdWx0U2l6ZS50b1ByZWNpc2lvbihwcmVjaXNpb24pIDogXCIxXCI7XG4gIH0gZWxzZSBpZiAocGFuZWxEYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogU2luZ2xlIHBhbmVsIGdyb3VwIHNob3VsZCBhbHdheXMgZmlsbCBmdWxsIHdpZHRoL2hlaWdodFxuICAgIGZsZXhHcm93ID0gXCIxXCI7XG4gIH0gZWxzZSB7XG4gICAgZmxleEdyb3cgPSBzaXplLnRvUHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmbGV4QmFzaXM6IDAsXG4gICAgZmxleEdyb3csXG4gICAgZmxleFNocmluazogMSxcbiAgICAvLyBXaXRob3V0IHRoaXMsIFBhbmVsIHNpemVzIG1heSBiZSB1bmludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiBieSB0aGVpciBjb250ZW50XG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgLy8gRGlzYWJsZSBwb2ludGVyIGV2ZW50cyBpbnNpZGUgb2YgYSBwYW5lbCBkdXJpbmcgcmVzaXplXG4gICAgLy8gVGhpcyBhdm9pZCBlZGdlIGNhc2VzIGxpa2UgbmVzdGVkIGlmcmFtZXNcbiAgICBwb2ludGVyRXZlbnRzOiBkcmFnU3RhdGUgIT09IG51bGwgPyBcIm5vbmVcIiA6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShjYWxsYmFjaywgZHVyYXRpb25NcyA9IDEwKSB7XG4gIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICBsZXQgY2FsbGFibGUgPSAoLi4uYXJncykgPT4ge1xuICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNhbGxiYWNrKC4uLmFyZ3MpO1xuICAgIH0sIGR1cmF0aW9uTXMpO1xuICB9O1xuICByZXR1cm4gY2FsbGFibGU7XG59XG5cbi8vIFBhbmVsR3JvdXAgbWlnaHQgYmUgcmVuZGVyaW5nIGluIGEgc2VydmVyLXNpZGUgZW52aXJvbm1lbnQgd2hlcmUgbG9jYWxTdG9yYWdlIGlzIG5vdCBhdmFpbGFibGVcbi8vIG9yIG9uIGEgYnJvd3NlciB3aXRoIGNvb2tpZXMvc3RvcmFnZSBkaXNhYmxlZC5cbi8vIEluIGVpdGhlciBjYXNlLCB0aGlzIGZ1bmN0aW9uIGF2b2lkcyBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIHVudGlsIG5lZWRlZCxcbi8vIGFuZCBhdm9pZHMgdGhyb3dpbmcgdXNlci12aXNpYmxlIGVycm9ycy5cbmZ1bmN0aW9uIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShzdG9yYWdlT2JqZWN0KSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8vIEJ5cGFzcyB0aGlzIGNoZWNrIGZvciBmdXR1cmUgY2FsbHNcbiAgICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICB9O1xuICAgICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG5hbWUsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxvY2FsU3RvcmFnZSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnRcIik7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHN0b3JhZ2VPYmplY3QuZ2V0SXRlbSA9ICgpID0+IG51bGw7XG4gICAgc3RvcmFnZU9iamVjdC5zZXRJdGVtID0gKCkgPT4ge307XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGFuZWxHcm91cEtleShhdXRvU2F2ZUlkKSB7XG4gIHJldHVybiBgcmVhY3QtcmVzaXphYmxlLXBhbmVsczoke2F1dG9TYXZlSWR9YDtcbn1cblxuLy8gTm90ZSB0aGF0IFBhbmVsIGlkcyBtaWdodCBiZSB1c2VyLXByb3ZpZGVkIChzdGFibGUpIG9yIHVzZUlkIGdlbmVyYXRlZCAobm9uLWRldGVybWluaXN0aWMpXG4vLyBzbyB0aGV5IHNob3VsZCBub3QgYmUgdXNlZCBhcyBwYXJ0IG9mIHRoZSBzZXJpYWxpemF0aW9uIGtleS5cbi8vIFVzaW5nIHRoZSBtaW4vbWF4IHNpemUgYXR0cmlidXRlcyBzaG91bGQgd29yayB3ZWxsIGVub3VnaCBhcyBhIGJhY2t1cC5cbi8vIFByZS1zb3J0aW5nIGJ5IG1pblNpemUgYWxsb3dzIHJlbWVtYmVyaW5nIGxheW91dHMgZXZlbiBpZiBwYW5lbHMgYXJlIHJlLW9yZGVyZWQvZHJhZ2dlZC5cbmZ1bmN0aW9uIGdldFBhbmVsS2V5KHBhbmVscykge1xuICByZXR1cm4gcGFuZWxzLm1hcChwYW5lbCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY29uc3RyYWludHMsXG4gICAgICBpZCxcbiAgICAgIGlkSXNGcm9tUHJvcHMsXG4gICAgICBvcmRlclxuICAgIH0gPSBwYW5lbDtcbiAgICBpZiAoaWRJc0Zyb21Qcm9wcykge1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3JkZXIgPyBgJHtvcmRlcn06JHtKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cyl9YCA6IEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKTtcbiAgICB9XG4gIH0pLnNvcnQoKGEsIGIpID0+IGEubG9jYWxlQ29tcGFyZShiKSkuam9pbihcIixcIik7XG59XG5mdW5jdGlvbiBsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZShhdXRvU2F2ZUlkLCBzdG9yYWdlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcGFuZWxHcm91cEtleSA9IGdldFBhbmVsR3JvdXBLZXkoYXV0b1NhdmVJZCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHN0b3JhZ2UuZ2V0SXRlbShwYW5lbEdyb3VwS2V5KTtcbiAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZShzZXJpYWxpemVkKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyc2VkID09PSBcIm9iamVjdFwiICYmIHBhcnNlZCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge31cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzYXZlUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHBhbmVscywgcGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlLCBzaXplcywgc3RvcmFnZSkge1xuICB2YXIgX2xvYWRTZXJpYWxpemVkUGFuZWxHMjtcbiAgY29uc3QgcGFuZWxHcm91cEtleSA9IGdldFBhbmVsR3JvdXBLZXkoYXV0b1NhdmVJZCk7XG4gIGNvbnN0IHBhbmVsS2V5ID0gZ2V0UGFuZWxLZXkocGFuZWxzKTtcbiAgY29uc3Qgc3RhdGUgPSAoX2xvYWRTZXJpYWxpemVkUGFuZWxHMiA9IGxvYWRTZXJpYWxpemVkUGFuZWxHcm91cFN0YXRlKGF1dG9TYXZlSWQsIHN0b3JhZ2UpKSAhPT0gbnVsbCAmJiBfbG9hZFNlcmlhbGl6ZWRQYW5lbEcyICE9PSB2b2lkIDAgPyBfbG9hZFNlcmlhbGl6ZWRQYW5lbEcyIDoge307XG4gIHN0YXRlW3BhbmVsS2V5XSA9IHtcbiAgICBleHBhbmRUb1NpemVzOiBPYmplY3QuZnJvbUVudHJpZXMocGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlLmVudHJpZXMoKSksXG4gICAgbGF5b3V0OiBzaXplc1xuICB9O1xuICB0cnkge1xuICAgIHN0b3JhZ2Uuc2V0SXRlbShwYW5lbEdyb3VwS2V5LCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFuZWxDb25zdHJhaW50cyh7XG4gIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgcGFuZWxJZCxcbiAgcGFuZWxJbmRleFxufSkge1xuICB7XG4gICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzID0gcGFuZWxDb25zdHJhaW50c0FycmF5W3BhbmVsSW5kZXhdO1xuICAgIGFzc2VydChwYW5lbENvbnN0cmFpbnRzLCBgTm8gcGFuZWwgY29uc3RyYWludHMgZm91bmQgZm9yIGluZGV4ICR7cGFuZWxJbmRleH1gKTtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplID0gMCxcbiAgICAgIGNvbGxhcHNpYmxlID0gZmFsc2UsXG4gICAgICBkZWZhdWx0U2l6ZSxcbiAgICAgIG1heFNpemUgPSAxMDAsXG4gICAgICBtaW5TaXplID0gMFxuICAgIH0gPSBwYW5lbENvbnN0cmFpbnRzO1xuICAgIGlmIChtaW5TaXplID4gbWF4U2l6ZSkge1xuICAgICAgd2FybmluZ3MucHVzaChgbWluIHNpemUgKCR7bWluU2l6ZX0lKSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggc2l6ZSAoJHttYXhTaXplfSUpYCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2l6ZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPCAwKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gMFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoZGVmYXVsdFNpemUgPCBtaW5TaXplICYmICghY29sbGFwc2libGUgfHwgZGVmYXVsdFNpemUgIT09IGNvbGxhcHNlZFNpemUpKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goXCJkZWZhdWx0IHNpemUgc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gbWluIHNpemVcIik7XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNpemUgPiAxMDApIHtcbiAgICAgICAgd2FybmluZ3MucHVzaChcImRlZmF1bHQgc2l6ZSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMDBcIik7XG4gICAgICB9IGVsc2UgaWYgKGRlZmF1bHRTaXplID4gbWF4U2l6ZSkge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKFwiZGVmYXVsdCBzaXplIHNob3VsZCBub3QgYmUgZ3JlYXRlciB0aGFuIG1heCBzaXplXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sbGFwc2VkU2l6ZSA+IG1pblNpemUpIHtcbiAgICAgIHdhcm5pbmdzLnB1c2goXCJjb2xsYXBzZWQgc2l6ZSBzaG91bGQgbm90IGJlIGdyZWF0ZXIgdGhhbiBtaW4gc2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKHdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwYW5lbElkICE9IG51bGwgPyBgUGFuZWwgXCIke3BhbmVsSWR9XCJgIDogXCJQYW5lbFwiO1xuICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IGhhcyBhbiBpbnZhbGlkIGNvbmZpZ3VyYXRpb246XFxuXFxuJHt3YXJuaW5ncy5qb2luKFwiXFxuXCIpfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gQWxsIHVuaXRzIG11c3QgYmUgaW4gcGVyY2VudGFnZXM7IHBpeGVsIHZhbHVlcyBzaG91bGQgYmUgcHJlLWNvbnZlcnRlZFxuZnVuY3Rpb24gdmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0KHtcbiAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICBwYW5lbENvbnN0cmFpbnRzXG59KSB7XG4gIGNvbnN0IG5leHRMYXlvdXQgPSBbLi4ucHJldkxheW91dF07XG4gIGNvbnN0IG5leHRMYXlvdXRUb3RhbFNpemUgPSBuZXh0TGF5b3V0LnJlZHVjZSgoYWNjdW11bGF0ZWQsIGN1cnJlbnQpID0+IGFjY3VtdWxhdGVkICsgY3VycmVudCwgMCk7XG5cbiAgLy8gVmFsaWRhdGUgbGF5b3V0IGV4cGVjdGF0aW9uc1xuICBpZiAobmV4dExheW91dC5sZW5ndGggIT09IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoKSB7XG4gICAgdGhyb3cgRXJyb3IoYEludmFsaWQgJHtwYW5lbENvbnN0cmFpbnRzLmxlbmd0aH0gcGFuZWwgbGF5b3V0OiAke25leHRMYXlvdXQubWFwKHNpemUgPT4gYCR7c2l6ZX0lYCkuam9pbihcIiwgXCIpfWApO1xuICB9IGVsc2UgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChuZXh0TGF5b3V0VG90YWxTaXplLCAxMDApKSB7XG4gICAgLy8gVGhpcyBpcyBub3QgaWRlYWwgc28gd2Ugc2hvdWxkIHdhcm4gYWJvdXQgaXQsIGJ1dCBpdCBtYXkgYmUgcmVjb3ZlcmFibGUgaW4gc29tZSBjYXNlc1xuICAgIC8vIChlc3BlY2lhbGx5IGlmIHRoZSBhbW91bnQgaXMgc21hbGwpXG4gICAge1xuICAgICAgY29uc29sZS53YXJuKGBXQVJOSU5HOiBJbnZhbGlkIGxheW91dCB0b3RhbCBzaXplOiAke25leHRMYXlvdXQubWFwKHNpemUgPT4gYCR7c2l6ZX0lYCkuam9pbihcIiwgXCIpfS4gTGF5b3V0IG5vcm1hbGl6YXRpb24gd2lsbCBiZSBhcHBsaWVkLmApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFuZWxDb25zdHJhaW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHVuc2FmZVNpemUgPSBuZXh0TGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydCh1bnNhZmVTaXplICE9IG51bGwsIGBObyBsYXlvdXQgZGF0YSBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICAgIGNvbnN0IHNhZmVTaXplID0gMTAwIC8gbmV4dExheW91dFRvdGFsU2l6ZSAqIHVuc2FmZVNpemU7XG4gICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgIH1cbiAgfVxuICBsZXQgcmVtYWluaW5nU2l6ZSA9IDA7XG5cbiAgLy8gRmlyc3QgcGFzczogVmFsaWRhdGUgdGhlIHByb3Bvc2VkIGxheW91dCBnaXZlbiBlYWNoIHBhbmVsJ3MgY29uc3RyYWludHNcbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBhbmVsQ29uc3RyYWludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgdW5zYWZlU2l6ZSA9IG5leHRMYXlvdXRbaW5kZXhdO1xuICAgIGFzc2VydCh1bnNhZmVTaXplICE9IG51bGwsIGBObyBsYXlvdXQgZGF0YSBmb3VuZCBmb3IgaW5kZXggJHtpbmRleH1gKTtcbiAgICBjb25zdCBzYWZlU2l6ZSA9IHJlc2l6ZVBhbmVsKHtcbiAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICBwYW5lbEluZGV4OiBpbmRleCxcbiAgICAgIHNpemU6IHVuc2FmZVNpemVcbiAgICB9KTtcbiAgICBpZiAodW5zYWZlU2l6ZSAhPSBzYWZlU2l6ZSkge1xuICAgICAgcmVtYWluaW5nU2l6ZSArPSB1bnNhZmVTaXplIC0gc2FmZVNpemU7XG4gICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZXJlIGlzIGFkZGl0aW9uYWwsIGxlZnQgb3ZlciBzcGFjZSwgYXNzaWduIGl0IHRvIGFueSBwYW5lbChzKSB0aGF0IHBlcm1pdHMgaXRcbiAgLy8gKEl0J3Mgbm90IHdvcnRoIHRha2luZyBtdWx0aXBsZSBhZGRpdGlvbmFsIHBhc3NlcyB0byBldmVubHkgZGlzdHJpYnV0ZSlcbiAgaWYgKCFmdXp6eU51bWJlcnNFcXVhbChyZW1haW5pbmdTaXplLCAwKSkge1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwYW5lbENvbnN0cmFpbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgcHJldlNpemUgPSBuZXh0TGF5b3V0W2luZGV4XTtcbiAgICAgIGFzc2VydChwcmV2U2l6ZSAhPSBudWxsLCBgTm8gbGF5b3V0IGRhdGEgZm91bmQgZm9yIGluZGV4ICR7aW5kZXh9YCk7XG4gICAgICBjb25zdCB1bnNhZmVTaXplID0gcHJldlNpemUgKyByZW1haW5pbmdTaXplO1xuICAgICAgY29uc3Qgc2FmZVNpemUgPSByZXNpemVQYW5lbCh7XG4gICAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICAgIHBhbmVsSW5kZXg6IGluZGV4LFxuICAgICAgICBzaXplOiB1bnNhZmVTaXplXG4gICAgICB9KTtcbiAgICAgIGlmIChwcmV2U2l6ZSAhPT0gc2FmZVNpemUpIHtcbiAgICAgICAgcmVtYWluaW5nU2l6ZSAtPSBzYWZlU2l6ZSAtIHByZXZTaXplO1xuICAgICAgICBuZXh0TGF5b3V0W2luZGV4XSA9IHNhZmVTaXplO1xuXG4gICAgICAgIC8vIE9uY2Ugd2UndmUgdXNlZCB1cCB0aGUgcmVtYWluZGVyLCBiYWlsXG4gICAgICAgIGlmIChmdXp6eU51bWJlcnNFcXVhbChyZW1haW5pbmdTaXplLCAwKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0TGF5b3V0O1xufVxuXG5jb25zdCBMT0NBTF9TVE9SQUdFX0RFQk9VTkNFX0lOVEVSVkFMID0gMTAwO1xuY29uc3QgZGVmYXVsdFN0b3JhZ2UgPSB7XG4gIGdldEl0ZW06IG5hbWUgPT4ge1xuICAgIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShkZWZhdWx0U3RvcmFnZSk7XG4gICAgcmV0dXJuIGRlZmF1bHRTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gIH0sXG4gIHNldEl0ZW06IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIGluaXRpYWxpemVEZWZhdWx0U3RvcmFnZShkZWZhdWx0U3RvcmFnZSk7XG4gICAgZGVmYXVsdFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gIH1cbn07XG5jb25zdCBkZWJvdW5jZU1hcCA9IHt9O1xuZnVuY3Rpb24gUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYoe1xuICBhdXRvU2F2ZUlkID0gbnVsbCxcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgZGlyZWN0aW9uLFxuICBmb3J3YXJkZWRSZWYsXG4gIGlkOiBpZEZyb21Qcm9wcyA9IG51bGwsXG4gIG9uTGF5b3V0ID0gbnVsbCxcbiAga2V5Ym9hcmRSZXNpemVCeSA9IG51bGwsXG4gIHN0b3JhZ2UgPSBkZWZhdWx0U3RvcmFnZSxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzLFxuICB0YWdOYW1lOiBUeXBlID0gXCJkaXZcIixcbiAgLi4ucmVzdFxufSkge1xuICBjb25zdCBncm91cElkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBwYW5lbEdyb3VwRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2RyYWdTdGF0ZSwgc2V0RHJhZ1N0YXRlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbbGF5b3V0LCBzZXRMYXlvdXRdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmID0gdXNlUmVmKHt9KTtcbiAgY29uc3QgcGFuZWxTaXplQmVmb3JlQ29sbGFwc2VSZWYgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgcHJldkRlbHRhUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBjb21taXR0ZWRWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIGF1dG9TYXZlSWQsXG4gICAgZGlyZWN0aW9uLFxuICAgIGRyYWdTdGF0ZSxcbiAgICBpZDogZ3JvdXBJZCxcbiAgICBrZXlib2FyZFJlc2l6ZUJ5LFxuICAgIG9uTGF5b3V0LFxuICAgIHN0b3JhZ2VcbiAgfSk7XG4gIGNvbnN0IGVhZ2VyVmFsdWVzUmVmID0gdXNlUmVmKHtcbiAgICBsYXlvdXQsXG4gICAgcGFuZWxEYXRhQXJyYXk6IFtdLFxuICAgIHBhbmVsRGF0YUFycmF5Q2hhbmdlZDogZmFsc2VcbiAgfSk7XG4gIGNvbnN0IGRldldhcm5pbmdzUmVmID0gdXNlUmVmKHtcbiAgICBkaWRMb2dJZEFuZE9yZGVyV2FybmluZzogZmFsc2UsXG4gICAgZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmc6IGZhbHNlLFxuICAgIHByZXZQYW5lbElkczogW11cbiAgfSk7XG4gIHVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiAoe1xuICAgIGdldElkOiAoKSA9PiBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudC5pZCxcbiAgICBnZXRMYXlvdXQ6ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0XG4gICAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSxcbiAgICBzZXRMYXlvdXQ6IHVuc2FmZUxheW91dCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9uTGF5b3V0XG4gICAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgICAgY29uc3Qgc2FmZUxheW91dCA9IHZhbGlkYXRlUGFuZWxHcm91cExheW91dCh7XG4gICAgICAgIGxheW91dDogdW5zYWZlTGF5b3V0LFxuICAgICAgICBwYW5lbENvbnN0cmFpbnRzOiBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cylcbiAgICAgIH0pO1xuICAgICAgaWYgKCFhcmVFcXVhbChwcmV2TGF5b3V0LCBzYWZlTGF5b3V0KSkge1xuICAgICAgICBzZXRMYXlvdXQoc2FmZUxheW91dCk7XG4gICAgICAgIGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQubGF5b3V0ID0gc2FmZUxheW91dDtcbiAgICAgICAgaWYgKG9uTGF5b3V0KSB7XG4gICAgICAgICAgb25MYXlvdXQoc2FmZUxheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsRGF0YUFycmF5LCBzYWZlTGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtdKTtcbiAgdXNlV2luZG93U3BsaXR0ZXJQYW5lbEdyb3VwQmVoYXZpb3Ioe1xuICAgIGNvbW1pdHRlZFZhbHVlc1JlZixcbiAgICBlYWdlclZhbHVlc1JlZixcbiAgICBncm91cElkLFxuICAgIGxheW91dCxcbiAgICBwYW5lbERhdGFBcnJheTogZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5wYW5lbERhdGFBcnJheSxcbiAgICBzZXRMYXlvdXQsXG4gICAgcGFuZWxHcm91cEVsZW1lbnQ6IHBhbmVsR3JvdXBFbGVtZW50UmVmLmN1cnJlbnRcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcblxuICAgIC8vIElmIHRoaXMgcGFuZWwgaGFzIGJlZW4gY29uZmlndXJlZCB0byBwZXJzaXN0IHNpemluZyBpbmZvcm1hdGlvbiwgc2F2ZSBzaXplcyB0byBsb2NhbCBzdG9yYWdlLlxuICAgIGlmIChhdXRvU2F2ZUlkKSB7XG4gICAgICBpZiAobGF5b3V0Lmxlbmd0aCA9PT0gMCB8fCBsYXlvdXQubGVuZ3RoICE9PSBwYW5lbERhdGFBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGRlYm91bmNlZFNhdmUgPSBkZWJvdW5jZU1hcFthdXRvU2F2ZUlkXTtcblxuICAgICAgLy8gTGltaXQgdGhlIGZyZXF1ZW5jeSBvZiBsb2NhbFN0b3JhZ2UgdXBkYXRlcy5cbiAgICAgIGlmIChkZWJvdW5jZWRTYXZlID09IG51bGwpIHtcbiAgICAgICAgZGVib3VuY2VkU2F2ZSA9IGRlYm91bmNlKHNhdmVQYW5lbEdyb3VwU3RhdGUsIExPQ0FMX1NUT1JBR0VfREVCT1VOQ0VfSU5URVJWQUwpO1xuICAgICAgICBkZWJvdW5jZU1hcFthdXRvU2F2ZUlkXSA9IGRlYm91bmNlZFNhdmU7XG4gICAgICB9XG5cbiAgICAgIC8vIENsb25lIG11dGFibGUgZGF0YSBiZWZvcmUgcGFzc2luZyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLFxuICAgICAgLy8gZWxzZSB3ZSBydW4gdGhlIHJpc2sgb2Ygc2F2aW5nIGFuIGluY29ycmVjdCBjb21iaW5hdGlvbiBvZiBtdXRhYmxlIGFuZCBpbW11dGFibGUgdmFsdWVzIHRvIHN0YXRlLlxuICAgICAgY29uc3QgY2xvbmVkUGFuZWxEYXRhQXJyYXkgPSBbLi4ucGFuZWxEYXRhQXJyYXldO1xuICAgICAgY29uc3QgY2xvbmVkUGFuZWxTaXplc0JlZm9yZUNvbGxhcHNlID0gbmV3IE1hcChwYW5lbFNpemVCZWZvcmVDb2xsYXBzZVJlZi5jdXJyZW50KTtcbiAgICAgIGRlYm91bmNlZFNhdmUoYXV0b1NhdmVJZCwgY2xvbmVkUGFuZWxEYXRhQXJyYXksIGNsb25lZFBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSwgbGF5b3V0LCBzdG9yYWdlKTtcbiAgICB9XG4gIH0sIFthdXRvU2F2ZUlkLCBsYXlvdXQsIHN0b3JhZ2VdKTtcblxuICAvLyBERVYgd2FybmluZ3NcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGlkTG9nSWRBbmRPcmRlcldhcm5pbmcsXG4gICAgICAgIGRpZExvZ1BhbmVsQ29uc3RyYWludHNXYXJuaW5nLFxuICAgICAgICBwcmV2UGFuZWxJZHNcbiAgICAgIH0gPSBkZXZXYXJuaW5nc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFkaWRMb2dJZEFuZE9yZGVyV2FybmluZykge1xuICAgICAgICBjb25zdCBwYW5lbElkcyA9IHBhbmVsRGF0YUFycmF5Lm1hcCgoe1xuICAgICAgICAgIGlkXG4gICAgICAgIH0pID0+IGlkKTtcbiAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5wcmV2UGFuZWxJZHMgPSBwYW5lbElkcztcbiAgICAgICAgY29uc3QgcGFuZWxzSGF2ZUNoYW5nZWQgPSBwcmV2UGFuZWxJZHMubGVuZ3RoID4gMCAmJiAhYXJlRXF1YWwocHJldlBhbmVsSWRzLCBwYW5lbElkcyk7XG4gICAgICAgIGlmIChwYW5lbHNIYXZlQ2hhbmdlZCkge1xuICAgICAgICAgIGlmIChwYW5lbERhdGFBcnJheS5maW5kKCh7XG4gICAgICAgICAgICBpZElzRnJvbVByb3BzLFxuICAgICAgICAgICAgb3JkZXJcbiAgICAgICAgICB9KSA9PiAhaWRJc0Zyb21Qcm9wcyB8fCBvcmRlciA9PSBudWxsKSkge1xuICAgICAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dJZEFuZE9yZGVyV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdBUk5JTkc6IFBhbmVsIGlkIGFuZCBvcmRlciBwcm9wcyByZWNvbW1lbmRlZCB3aGVuIHBhbmVscyBhcmUgZHluYW1pY2FsbHkgcmVuZGVyZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghZGlkTG9nUGFuZWxDb25zdHJhaW50c1dhcm5pbmcpIHtcbiAgICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgICAgZm9yIChsZXQgcGFuZWxJbmRleCA9IDA7IHBhbmVsSW5kZXggPCBwYW5lbENvbnN0cmFpbnRzLmxlbmd0aDsgcGFuZWxJbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgcGFuZWxEYXRhID0gcGFuZWxEYXRhQXJyYXlbcGFuZWxJbmRleF07XG4gICAgICAgICAgYXNzZXJ0KHBhbmVsRGF0YSwgYFBhbmVsIGRhdGEgbm90IGZvdW5kIGZvciBpbmRleCAke3BhbmVsSW5kZXh9YCk7XG4gICAgICAgICAgY29uc3QgaXNWYWxpZCA9IHZhbGlkYXRlUGFuZWxDb25zdHJhaW50cyh7XG4gICAgICAgICAgICBwYW5lbENvbnN0cmFpbnRzLFxuICAgICAgICAgICAgcGFuZWxJZDogcGFuZWxEYXRhLmlkLFxuICAgICAgICAgICAgcGFuZWxJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgZGV2V2FybmluZ3NSZWYuY3VycmVudC5kaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgY29sbGFwc2VQYW5lbCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb25MYXlvdXRcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBpZiAocGFuZWxEYXRhLmNvbnN0cmFpbnRzLmNvbGxhcHNpYmxlKSB7XG4gICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzQXJyYXkgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICBwYW5lbFNpemUsXG4gICAgICAgIHBpdm90SW5kaWNlc1xuICAgICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBwcmV2TGF5b3V0KTtcbiAgICAgIGFzc2VydChwYW5lbFNpemUgIT0gbnVsbCwgYFBhbmVsIHNpemUgbm90IGZvdW5kIGZvciBwYW5lbCBcIiR7cGFuZWxEYXRhLmlkfVwiYCk7XG4gICAgICBpZiAocGFuZWxTaXplICE9PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgIC8vIFN0b3JlIHNpemUgYmVmb3JlIGNvbGxhcHNlO1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBzaXplIHRoYXQgZ2V0cyByZXN0b3JlZCBpZiB0aGUgZXhwYW5kKCkgQVBJIGlzIHVzZWQuXG4gICAgICAgIHBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlUmVmLmN1cnJlbnQuc2V0KHBhbmVsRGF0YS5pZCwgcGFuZWxTaXplKTtcbiAgICAgICAgY29uc3QgaXNMYXN0UGFuZWwgPSBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSkgPT09IHBhbmVsRGF0YUFycmF5Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gaXNMYXN0UGFuZWwgPyBwYW5lbFNpemUgLSBjb2xsYXBzZWRTaXplIDogY29sbGFwc2VkU2l6ZSAtIHBhbmVsU2l6ZTtcbiAgICAgICAgY29uc3QgbmV4dExheW91dCA9IGFkanVzdExheW91dEJ5RGVsdGEoe1xuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIGluaXRpYWxMYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgICAgICBwcmV2TGF5b3V0LFxuICAgICAgICAgIHRyaWdnZXI6IFwiaW1wZXJhdGl2ZS1hcGlcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjb21wYXJlTGF5b3V0cyhwcmV2TGF5b3V0LCBuZXh0TGF5b3V0KSkge1xuICAgICAgICAgIHNldExheW91dChuZXh0TGF5b3V0KTtcbiAgICAgICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICAgICAgaWYgKG9uTGF5b3V0KSB7XG4gICAgICAgICAgICBvbkxheW91dChuZXh0TGF5b3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsRGF0YUFycmF5LCBuZXh0TGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCBleHBhbmRQYW5lbCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb25MYXlvdXRcbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBpZiAocGFuZWxEYXRhLmNvbnN0cmFpbnRzLmNvbGxhcHNpYmxlKSB7XG4gICAgICBjb25zdCBwYW5lbENvbnN0cmFpbnRzQXJyYXkgPSBwYW5lbERhdGFBcnJheS5tYXAocGFuZWxEYXRhID0+IHBhbmVsRGF0YS5jb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgICBwYW5lbFNpemUsXG4gICAgICAgIG1pblNpemUgPSAwLFxuICAgICAgICBwaXZvdEluZGljZXNcbiAgICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgcHJldkxheW91dCk7XG4gICAgICBpZiAocGFuZWxTaXplID09PSBjb2xsYXBzZWRTaXplKSB7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhpcyBwYW5lbCB0byB0aGUgc2l6ZSBpdCB3YXMgYmVmb3JlIGl0IHdhcyBjb2xsYXBzZWQsIGlmIHBvc3NpYmxlLlxuICAgICAgICBjb25zdCBwcmV2UGFuZWxTaXplID0gcGFuZWxTaXplQmVmb3JlQ29sbGFwc2VSZWYuY3VycmVudC5nZXQocGFuZWxEYXRhLmlkKTtcbiAgICAgICAgY29uc3QgYmFzZVNpemUgPSBwcmV2UGFuZWxTaXplICE9IG51bGwgJiYgcHJldlBhbmVsU2l6ZSA+PSBtaW5TaXplID8gcHJldlBhbmVsU2l6ZSA6IG1pblNpemU7XG4gICAgICAgIGNvbnN0IGlzTGFzdFBhbmVsID0gZmluZFBhbmVsRGF0YUluZGV4KHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEpID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gcGFuZWxTaXplIC0gYmFzZVNpemUgOiBiYXNlU2l6ZSAtIHBhbmVsU2l6ZTtcbiAgICAgICAgY29uc3QgbmV4dExheW91dCA9IGFkanVzdExheW91dEJ5RGVsdGEoe1xuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIGluaXRpYWxMYXlvdXQ6IHByZXZMYXlvdXQsXG4gICAgICAgICAgcGFuZWxDb25zdHJhaW50czogcGFuZWxDb25zdHJhaW50c0FycmF5LFxuICAgICAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgICAgICBwcmV2TGF5b3V0LFxuICAgICAgICAgIHRyaWdnZXI6IFwiaW1wZXJhdGl2ZS1hcGlcIlxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFjb21wYXJlTGF5b3V0cyhwcmV2TGF5b3V0LCBuZXh0TGF5b3V0KSkge1xuICAgICAgICAgIHNldExheW91dChuZXh0TGF5b3V0KTtcbiAgICAgICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICAgICAgaWYgKG9uTGF5b3V0KSB7XG4gICAgICAgICAgICBvbkxheW91dChuZXh0TGF5b3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbFBhbmVsQ2FsbGJhY2tzKHBhbmVsRGF0YUFycmF5LCBuZXh0TGF5b3V0LCBwYW5lbElkVG9MYXN0Tm90aWZpZWRTaXplTWFwUmVmLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCBnZXRQYW5lbFNpemUgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxTaXplXG4gICAgfSA9IHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpO1xuICAgIGFzc2VydChwYW5lbFNpemUgIT0gbnVsbCwgYFBhbmVsIHNpemUgbm90IGZvdW5kIGZvciBwYW5lbCBcIiR7cGFuZWxEYXRhLmlkfVwiYCk7XG4gICAgcmV0dXJuIHBhbmVsU2l6ZTtcbiAgfSwgW10pO1xuXG4gIC8vIFRoaXMgQVBJIHNob3VsZCBuZXZlciByZWFkIGZyb20gY29tbWl0dGVkVmFsdWVzUmVmXG4gIGNvbnN0IGdldFBhbmVsU3R5bGUgPSB1c2VDYWxsYmFjaygocGFuZWxEYXRhLCBkZWZhdWx0U2l6ZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFuZWxJbmRleCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKTtcbiAgICByZXR1cm4gY29tcHV0ZVBhbmVsRmxleEJveFN0eWxlKHtcbiAgICAgIGRlZmF1bHRTaXplLFxuICAgICAgZHJhZ1N0YXRlLFxuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhOiBwYW5lbERhdGFBcnJheSxcbiAgICAgIHBhbmVsSW5kZXhcbiAgICB9KTtcbiAgfSwgW2RyYWdTdGF0ZSwgbGF5b3V0XSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCBpc1BhbmVsQ29sbGFwc2VkID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBwYW5lbFNpemVcbiAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCk7XG4gICAgcmV0dXJuIGNvbGxhcHNpYmxlID09PSB0cnVlICYmIHBhbmVsU2l6ZSA9PT0gY29sbGFwc2VkU2l6ZTtcbiAgfSwgW10pO1xuXG4gIC8vIEV4dGVybmFsIEFQSXMgYXJlIHNhZmUgdG8gbWVtb2l6ZSB2aWEgY29tbWl0dGVkIHZhbHVlcyByZWZcbiAgY29uc3QgaXNQYW5lbEV4cGFuZGVkID0gdXNlQ2FsbGJhY2socGFuZWxEYXRhID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBsYXlvdXQsXG4gICAgICBwYW5lbERhdGFBcnJheVxuICAgIH0gPSBlYWdlclZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbGxhcHNlZFNpemUgPSAwLFxuICAgICAgY29sbGFwc2libGUsXG4gICAgICBwYW5lbFNpemVcbiAgICB9ID0gcGFuZWxEYXRhSGVscGVyKHBhbmVsRGF0YUFycmF5LCBwYW5lbERhdGEsIGxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsLCBgUGFuZWwgc2l6ZSBub3QgZm91bmQgZm9yIHBhbmVsIFwiJHtwYW5lbERhdGEuaWR9XCJgKTtcbiAgICByZXR1cm4gIWNvbGxhcHNpYmxlIHx8IHBhbmVsU2l6ZSA+IGNvbGxhcHNlZFNpemU7XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVnaXN0ZXJQYW5lbCA9IHVzZUNhbGxiYWNrKHBhbmVsRGF0YSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBwYW5lbERhdGFBcnJheS5wdXNoKHBhbmVsRGF0YSk7XG4gICAgcGFuZWxEYXRhQXJyYXkuc29ydCgocGFuZWxBLCBwYW5lbEIpID0+IHtcbiAgICAgIGNvbnN0IG9yZGVyQSA9IHBhbmVsQS5vcmRlcjtcbiAgICAgIGNvbnN0IG9yZGVyQiA9IHBhbmVsQi5vcmRlcjtcbiAgICAgIGlmIChvcmRlckEgPT0gbnVsbCAmJiBvcmRlckIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSBpZiAob3JkZXJBID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChvcmRlckIgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcmRlckEgLSBvcmRlckI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5wYW5lbERhdGFBcnJheUNoYW5nZWQgPSB0cnVlO1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZ2lzdGVyUmVzaXplSGFuZGxlID0gdXNlQ2FsbGJhY2soZHJhZ0hhbmRsZUlkID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVzaXplSGFuZGxlcihldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IHBhbmVsR3JvdXBFbGVtZW50ID0gcGFuZWxHcm91cEVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAgIGlmICghcGFuZWxHcm91cEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgZHJhZ1N0YXRlLFxuICAgICAgICBpZDogZ3JvdXBJZCxcbiAgICAgICAga2V5Ym9hcmRSZXNpemVCeSxcbiAgICAgICAgb25MYXlvdXRcbiAgICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGF5b3V0OiBwcmV2TGF5b3V0LFxuICAgICAgICBwYW5lbERhdGFBcnJheVxuICAgICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGluaXRpYWxMYXlvdXRcbiAgICAgIH0gPSBkcmFnU3RhdGUgIT09IG51bGwgJiYgZHJhZ1N0YXRlICE9PSB2b2lkIDAgPyBkcmFnU3RhdGUgOiB7fTtcbiAgICAgIGNvbnN0IHBpdm90SW5kaWNlcyA9IGRldGVybWluZVBpdm90SW5kaWNlcyhncm91cElkLCBkcmFnSGFuZGxlSWQsIHBhbmVsR3JvdXBFbGVtZW50KTtcbiAgICAgIGxldCBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhUGVyY2VudGFnZShldmVudCwgZHJhZ0hhbmRsZUlkLCBkaXJlY3Rpb24sIGRyYWdTdGF0ZSwga2V5Ym9hcmRSZXNpemVCeSwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gU3VwcG9ydCBSVEwgbGF5b3V0c1xuICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIjtcbiAgICAgIGlmIChkb2N1bWVudC5kaXIgPT09IFwicnRsXCIgJiYgaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFuZWxDb25zdHJhaW50cyA9IHBhbmVsRGF0YUFycmF5Lm1hcChwYW5lbERhdGEgPT4gcGFuZWxEYXRhLmNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIGluaXRpYWxMYXlvdXQ6IGluaXRpYWxMYXlvdXQgIT09IG51bGwgJiYgaW5pdGlhbExheW91dCAhPT0gdm9pZCAwID8gaW5pdGlhbExheW91dCA6IHByZXZMYXlvdXQsXG4gICAgICAgIHBhbmVsQ29uc3RyYWludHMsXG4gICAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgICAgcHJldkxheW91dCxcbiAgICAgICAgdHJpZ2dlcjogaXNLZXlEb3duKGV2ZW50KSA/IFwia2V5Ym9hcmRcIiA6IFwibW91c2Utb3ItdG91Y2hcIlxuICAgICAgfSk7XG4gICAgICBjb25zdCBsYXlvdXRDaGFuZ2VkID0gIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpO1xuXG4gICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgY3Vyc29yIGZvciBsYXlvdXQgY2hhbmdlcyB0cmlnZ2VyZWQgYnkgdG91Y2gvbW91c2UgZXZlbnRzIChub3Qga2V5Ym9hcmQpXG4gICAgICAvLyBVcGRhdGUgdGhlIGN1cnNvciBldmVuIGlmIHRoZSBsYXlvdXQgaGFzbid0IGNoYW5nZWQgKHdlIG1heSBuZWVkIHRvIHNob3cgYW4gaW52YWxpZCBjdXJzb3Igc3RhdGUpXG4gICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIC8vIFdhdGNoIGZvciBtdWx0aXBsZSBzdWJzZXF1ZW50IGRlbHRhczsgdGhpcyBtaWdodCBvY2N1ciBmb3IgdGlueSBjdXJzb3IgbW92ZW1lbnRzLlxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIFBhbmVsIHNpemVzIG1pZ2h0IG5vdCBjaGFuZ2XigJNcbiAgICAgICAgLy8gYnV0IHVwZGF0aW5nIGN1cnNvciBpbiB0aGlzIHNjZW5hcmlvIHdvdWxkIGNhdXNlIGEgZmxpY2tlci5cbiAgICAgICAgaWYgKHByZXZEZWx0YVJlZi5jdXJyZW50ICE9IGRlbHRhKSB7XG4gICAgICAgICAgcHJldkRlbHRhUmVmLmN1cnJlbnQgPSBkZWx0YTtcbiAgICAgICAgICBpZiAoIWxheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwb2ludGVyIGhhcyBtb3ZlZCB0b28gZmFyIHRvIHJlc2l6ZSB0aGUgcGFuZWwgYW55IGZ1cnRoZXIsIG5vdGUgdGhpcyBzbyB3ZSBjYW4gdXBkYXRlIHRoZSBjdXJzb3IuXG4gICAgICAgICAgICAvLyBUaGlzIG1pbWljcyBWUyBDb2RlIGJlaGF2aW9yLlxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICByZXBvcnRDb25zdHJhaW50c1Zpb2xhdGlvbihkcmFnSGFuZGxlSWQsIGRlbHRhIDwgMCA/IEVYQ0VFREVEX0hPUklaT05UQUxfTUlOIDogRVhDRUVERURfSE9SSVpPTlRBTF9NQVgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwb3J0Q29uc3RyYWludHNWaW9sYXRpb24oZHJhZ0hhbmRsZUlkLCBkZWx0YSA8IDAgPyBFWENFRURFRF9WRVJUSUNBTF9NSU4gOiBFWENFRURFRF9WRVJUSUNBTF9NQVgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXBvcnRDb25zdHJhaW50c1Zpb2xhdGlvbihkcmFnSGFuZGxlSWQsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxheW91dENoYW5nZWQpIHtcbiAgICAgICAgc2V0TGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICAgIGlmIChvbkxheW91dCkge1xuICAgICAgICAgIG9uTGF5b3V0KG5leHRMYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxQYW5lbENhbGxiYWNrcyhwYW5lbERhdGFBcnJheSwgbmV4dExheW91dCwgcGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gRXh0ZXJuYWwgQVBJcyBhcmUgc2FmZSB0byBtZW1vaXplIHZpYSBjb21taXR0ZWQgdmFsdWVzIHJlZlxuICBjb25zdCByZXNpemVQYW5lbCA9IHVzZUNhbGxiYWNrKChwYW5lbERhdGEsIHVuc2FmZVBhbmVsU2l6ZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTGF5b3V0XG4gICAgfSA9IGNvbW1pdHRlZFZhbHVlc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IHtcbiAgICAgIGxheW91dDogcHJldkxheW91dCxcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgcGFuZWxDb25zdHJhaW50c0FycmF5ID0gcGFuZWxEYXRhQXJyYXkubWFwKHBhbmVsRGF0YSA9PiBwYW5lbERhdGEuY29uc3RyYWludHMpO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsU2l6ZSxcbiAgICAgIHBpdm90SW5kaWNlc1xuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgcHJldkxheW91dCk7XG4gICAgYXNzZXJ0KHBhbmVsU2l6ZSAhPSBudWxsLCBgUGFuZWwgc2l6ZSBub3QgZm91bmQgZm9yIHBhbmVsIFwiJHtwYW5lbERhdGEuaWR9XCJgKTtcbiAgICBjb25zdCBpc0xhc3RQYW5lbCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSA9PT0gcGFuZWxEYXRhQXJyYXkubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBkZWx0YSA9IGlzTGFzdFBhbmVsID8gcGFuZWxTaXplIC0gdW5zYWZlUGFuZWxTaXplIDogdW5zYWZlUGFuZWxTaXplIC0gcGFuZWxTaXplO1xuICAgIGNvbnN0IG5leHRMYXlvdXQgPSBhZGp1c3RMYXlvdXRCeURlbHRhKHtcbiAgICAgIGRlbHRhLFxuICAgICAgaW5pdGlhbExheW91dDogcHJldkxheW91dCxcbiAgICAgIHBhbmVsQ29uc3RyYWludHM6IHBhbmVsQ29uc3RyYWludHNBcnJheSxcbiAgICAgIHBpdm90SW5kaWNlcyxcbiAgICAgIHByZXZMYXlvdXQsXG4gICAgICB0cmlnZ2VyOiBcImltcGVyYXRpdmUtYXBpXCJcbiAgICB9KTtcbiAgICBpZiAoIWNvbXBhcmVMYXlvdXRzKHByZXZMYXlvdXQsIG5leHRMYXlvdXQpKSB7XG4gICAgICBzZXRMYXlvdXQobmV4dExheW91dCk7XG4gICAgICBlYWdlclZhbHVlc1JlZi5jdXJyZW50LmxheW91dCA9IG5leHRMYXlvdXQ7XG4gICAgICBpZiAob25MYXlvdXQpIHtcbiAgICAgICAgb25MYXlvdXQobmV4dExheW91dCk7XG4gICAgICB9XG4gICAgICBjYWxsUGFuZWxDYWxsYmFja3MocGFuZWxEYXRhQXJyYXksIG5leHRMYXlvdXQsIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudCk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlZXZhbHVhdGVQYW5lbENvbnN0cmFpbnRzID0gdXNlQ2FsbGJhY2soKHBhbmVsRGF0YSwgcHJldkNvbnN0cmFpbnRzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0LFxuICAgICAgcGFuZWxEYXRhQXJyYXlcbiAgICB9ID0gZWFnZXJWYWx1ZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplOiBwcmV2Q29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZTogcHJldkNvbGxhcHNpYmxlXG4gICAgfSA9IHByZXZDb25zdHJhaW50cztcbiAgICBjb25zdCB7XG4gICAgICBjb2xsYXBzZWRTaXplOiBuZXh0Q29sbGFwc2VkU2l6ZSA9IDAsXG4gICAgICBjb2xsYXBzaWJsZTogbmV4dENvbGxhcHNpYmxlLFxuICAgICAgbWF4U2l6ZTogbmV4dE1heFNpemUgPSAxMDAsXG4gICAgICBtaW5TaXplOiBuZXh0TWluU2l6ZSA9IDBcbiAgICB9ID0gcGFuZWxEYXRhLmNvbnN0cmFpbnRzO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsU2l6ZTogcHJldlBhbmVsU2l6ZVxuICAgIH0gPSBwYW5lbERhdGFIZWxwZXIocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSwgbGF5b3V0KTtcbiAgICBpZiAocHJldlBhbmVsU2l6ZSA9PSBudWxsKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHBhbmVscyBpbiB0aGlzIGdyb3VwIGhhdmUgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCByZW5kZXJcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByZXZDb2xsYXBzaWJsZSAmJiBuZXh0Q29sbGFwc2libGUgJiYgcHJldlBhbmVsU2l6ZSA9PT0gcHJldkNvbGxhcHNlZFNpemUpIHtcbiAgICAgIGlmIChwcmV2Q29sbGFwc2VkU2l6ZSAhPT0gbmV4dENvbGxhcHNlZFNpemUpIHtcbiAgICAgICAgcmVzaXplUGFuZWwocGFuZWxEYXRhLCBuZXh0Q29sbGFwc2VkU2l6ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcmV2UGFuZWxTaXplIDwgbmV4dE1pblNpemUpIHtcbiAgICAgIHJlc2l6ZVBhbmVsKHBhbmVsRGF0YSwgbmV4dE1pblNpemUpO1xuICAgIH0gZWxzZSBpZiAocHJldlBhbmVsU2l6ZSA+IG5leHRNYXhTaXplKSB7XG4gICAgICByZXNpemVQYW5lbChwYW5lbERhdGEsIG5leHRNYXhTaXplKTtcbiAgICB9XG4gIH0sIFtyZXNpemVQYW5lbF0pO1xuICBjb25zdCBzdGFydERyYWdnaW5nID0gdXNlQ2FsbGJhY2soKGRyYWdIYW5kbGVJZCwgZXZlbnQpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBkaXJlY3Rpb25cbiAgICB9ID0gY29tbWl0dGVkVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgbGF5b3V0XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFwYW5lbEdyb3VwRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGRyYWdIYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnRSZWYuY3VycmVudCk7XG4gICAgYXNzZXJ0KGhhbmRsZUVsZW1lbnQsIGBEcmFnIGhhbmRsZSBlbGVtZW50IG5vdCBmb3VuZCBmb3IgaWQgXCIke2RyYWdIYW5kbGVJZH1cImApO1xuICAgIGNvbnN0IGluaXRpYWxDdXJzb3JQb3NpdGlvbiA9IGdldFJlc2l6ZUV2ZW50Q3Vyc29yUG9zaXRpb24oZGlyZWN0aW9uLCBldmVudCk7XG4gICAgc2V0RHJhZ1N0YXRlKHtcbiAgICAgIGRyYWdIYW5kbGVJZCxcbiAgICAgIGRyYWdIYW5kbGVSZWN0OiBoYW5kbGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgaW5pdGlhbEN1cnNvclBvc2l0aW9uLFxuICAgICAgaW5pdGlhbExheW91dDogbGF5b3V0XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc3RvcERyYWdnaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldERyYWdTdGF0ZShudWxsKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyUGFuZWwgPSB1c2VDYWxsYmFjayhwYW5lbERhdGEgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhbmVsRGF0YUFycmF5XG4gICAgfSA9IGVhZ2VyVmFsdWVzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgaW5kZXggPSBmaW5kUGFuZWxEYXRhSW5kZXgocGFuZWxEYXRhQXJyYXksIHBhbmVsRGF0YSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHBhbmVsRGF0YUFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgIC8vIFRSSUNLWVxuICAgICAgLy8gV2hlbiBhIHBhbmVsIGlzIHJlbW92ZWQgZnJvbSB0aGUgZ3JvdXAsIHdlIHNob3VsZCBkZWxldGUgdGhlIG1vc3QgcmVjZW50IHByZXYtc2l6ZSBlbnRyeSBmb3IgaXQuXG4gICAgICAvLyBJZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGVuIGEgY29uZGl0aW9uYWxseSByZW5kZXJlZCBwYW5lbCBtaWdodCBub3QgY2FsbCBvblJlc2l6ZSB3aGVuIGl0J3MgcmUtbW91bnRlZC5cbiAgICAgIC8vIFN0cmljdCBlZmZlY3RzIG1vZGUgbWFrZXMgdGhpcyB0cmlja3kgdGhvdWdoIGJlY2F1c2UgYWxsIHBhbmVscyB3aWxsIGJlIHJlZ2lzdGVyZWQsIHVucmVnaXN0ZXJlZCwgdGhlbiByZS1yZWdpc3RlcmVkIG9uIG1vdW50LlxuICAgICAgZGVsZXRlIHBhbmVsSWRUb0xhc3ROb3RpZmllZFNpemVNYXBSZWYuY3VycmVudFtwYW5lbERhdGEuaWRdO1xuICAgICAgZWFnZXJWYWx1ZXNSZWYuY3VycmVudC5wYW5lbERhdGFBcnJheUNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBjb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGNvbGxhcHNlUGFuZWwsXG4gICAgZGlyZWN0aW9uLFxuICAgIGRyYWdTdGF0ZSxcbiAgICBleHBhbmRQYW5lbCxcbiAgICBnZXRQYW5lbFNpemUsXG4gICAgZ2V0UGFuZWxTdHlsZSxcbiAgICBncm91cElkLFxuICAgIGlzUGFuZWxDb2xsYXBzZWQsXG4gICAgaXNQYW5lbEV4cGFuZGVkLFxuICAgIHJlZXZhbHVhdGVQYW5lbENvbnN0cmFpbnRzLFxuICAgIHJlZ2lzdGVyUGFuZWwsXG4gICAgcmVnaXN0ZXJSZXNpemVIYW5kbGUsXG4gICAgcmVzaXplUGFuZWwsXG4gICAgc3RhcnREcmFnZ2luZyxcbiAgICBzdG9wRHJhZ2dpbmcsXG4gICAgdW5yZWdpc3RlclBhbmVsLFxuICAgIHBhbmVsR3JvdXBFbGVtZW50OiBwYW5lbEdyb3VwRWxlbWVudFJlZi5jdXJyZW50XG4gIH0pLCBbY29sbGFwc2VQYW5lbCwgZHJhZ1N0YXRlLCBkaXJlY3Rpb24sIGV4cGFuZFBhbmVsLCBnZXRQYW5lbFNpemUsIGdldFBhbmVsU3R5bGUsIGdyb3VwSWQsIGlzUGFuZWxDb2xsYXBzZWQsIGlzUGFuZWxFeHBhbmRlZCwgcmVldmFsdWF0ZVBhbmVsQ29uc3RyYWludHMsIHJlZ2lzdGVyUGFuZWwsIHJlZ2lzdGVyUmVzaXplSGFuZGxlLCByZXNpemVQYW5lbCwgc3RhcnREcmFnZ2luZywgc3RvcERyYWdnaW5nLCB1bnJlZ2lzdGVyUGFuZWxdKTtcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgZmxleERpcmVjdGlvbjogZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwicm93XCIgOiBcImNvbHVtblwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiXG4gIH07XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFBhbmVsR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRcbiAgfSwgY3JlYXRlRWxlbWVudChUeXBlLCB7XG4gICAgLi4ucmVzdCxcbiAgICBjaGlsZHJlbixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZUZyb21Qcm9wcyxcbiAgICBpZDogaWRGcm9tUHJvcHMsXG4gICAgcmVmOiBwYW5lbEdyb3VwRWxlbWVudFJlZixcbiAgICBzdHlsZToge1xuICAgICAgLi4uc3R5bGUsXG4gICAgICAuLi5zdHlsZUZyb21Qcm9wc1xuICAgIH0sXG4gICAgLy8gQ1NTIHNlbGVjdG9yc1xuICAgIFwiZGF0YS1wYW5lbC1ncm91cFwiOiBcIlwiLFxuICAgIFwiZGF0YS1wYW5lbC1ncm91cC1kaXJlY3Rpb25cIjogZGlyZWN0aW9uLFxuICAgIFwiZGF0YS1wYW5lbC1ncm91cC1pZFwiOiBncm91cElkXG4gIH0pKTtcbn1cbmNvbnN0IFBhbmVsR3JvdXAgPSBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiBjcmVhdGVFbGVtZW50KFBhbmVsR3JvdXBXaXRoRm9yd2FyZGVkUmVmLCB7XG4gIC4uLnByb3BzLFxuICBmb3J3YXJkZWRSZWY6IHJlZlxufSkpO1xuUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYuZGlzcGxheU5hbWUgPSBcIlBhbmVsR3JvdXBcIjtcblBhbmVsR3JvdXAuZGlzcGxheU5hbWUgPSBcImZvcndhcmRSZWYoUGFuZWxHcm91cClcIjtcbmZ1bmN0aW9uIGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKSB7XG4gIHJldHVybiBwYW5lbERhdGFBcnJheS5maW5kSW5kZXgocHJldlBhbmVsRGF0YSA9PiBwcmV2UGFuZWxEYXRhID09PSBwYW5lbERhdGEgfHwgcHJldlBhbmVsRGF0YS5pZCA9PT0gcGFuZWxEYXRhLmlkKTtcbn1cbmZ1bmN0aW9uIHBhbmVsRGF0YUhlbHBlcihwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhLCBsYXlvdXQpIHtcbiAgY29uc3QgcGFuZWxJbmRleCA9IGZpbmRQYW5lbERhdGFJbmRleChwYW5lbERhdGFBcnJheSwgcGFuZWxEYXRhKTtcbiAgY29uc3QgaXNMYXN0UGFuZWwgPSBwYW5lbEluZGV4ID09PSBwYW5lbERhdGFBcnJheS5sZW5ndGggLSAxO1xuICBjb25zdCBwaXZvdEluZGljZXMgPSBpc0xhc3RQYW5lbCA/IFtwYW5lbEluZGV4IC0gMSwgcGFuZWxJbmRleF0gOiBbcGFuZWxJbmRleCwgcGFuZWxJbmRleCArIDFdO1xuICBjb25zdCBwYW5lbFNpemUgPSBsYXlvdXRbcGFuZWxJbmRleF07XG4gIHJldHVybiB7XG4gICAgLi4ucGFuZWxEYXRhLmNvbnN0cmFpbnRzLFxuICAgIHBhbmVsU2l6ZSxcbiAgICBwaXZvdEluZGljZXNcbiAgfTtcbn1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1dBSS9BUklBL2FwZy9wYXR0ZXJucy93aW5kb3dzcGxpdHRlci9cblxuZnVuY3Rpb24gdXNlV2luZG93U3BsaXR0ZXJSZXNpemVIYW5kbGVyQmVoYXZpb3Ioe1xuICBkaXNhYmxlZCxcbiAgaGFuZGxlSWQsXG4gIHJlc2l6ZUhhbmRsZXIsXG4gIHBhbmVsR3JvdXBFbGVtZW50XG59KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHJlc2l6ZUhhbmRsZXIgPT0gbnVsbCB8fCBwYW5lbEdyb3VwRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZUVsZW1lbnQgPSBnZXRSZXNpemVIYW5kbGVFbGVtZW50KGhhbmRsZUlkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgaWYgKGhhbmRsZUVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvbktleURvd24gPSBldmVudCA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjpcbiAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgY2FzZSBcIkVuZFwiOlxuICAgICAgICBjYXNlIFwiSG9tZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIkY2XCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwSWQgPSBoYW5kbGVFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtcGFuZWwtZ3JvdXAtaWRcIik7XG4gICAgICAgICAgICBhc3NlcnQoZ3JvdXBJZCwgYE5vIGdyb3VwIGVsZW1lbnQgZm91bmQgZm9yIGlkIFwiJHtncm91cElkfVwiYCk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVzID0gZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cChncm91cElkLCBwYW5lbEdyb3VwRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRJbmRleChncm91cElkLCBoYW5kbGVJZCwgcGFuZWxHcm91cEVsZW1lbnQpO1xuICAgICAgICAgICAgYXNzZXJ0KGluZGV4ICE9PSBudWxsLCBgTm8gcmVzaXplIGVsZW1lbnQgZm91bmQgZm9yIGlkIFwiJHtoYW5kbGVJZH1cImApO1xuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gZXZlbnQuc2hpZnRLZXkgPyBpbmRleCA+IDAgPyBpbmRleCAtIDEgOiBoYW5kbGVzLmxlbmd0aCAtIDEgOiBpbmRleCArIDEgPCBoYW5kbGVzLmxlbmd0aCA/IGluZGV4ICsgMSA6IDA7XG4gICAgICAgICAgICBjb25zdCBuZXh0SGFuZGxlID0gaGFuZGxlc1tuZXh0SW5kZXhdO1xuICAgICAgICAgICAgbmV4dEhhbmRsZS5mb2N1cygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBoYW5kbGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5RG93bik7XG4gICAgfTtcbiAgfSwgW3BhbmVsR3JvdXBFbGVtZW50LCBkaXNhYmxlZCwgaGFuZGxlSWQsIHJlc2l6ZUhhbmRsZXJdKTtcbn1cblxuZnVuY3Rpb24gUGFuZWxSZXNpemVIYW5kbGUoe1xuICBjaGlsZHJlbiA9IG51bGwsXG4gIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzID0gXCJcIixcbiAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgaGl0QXJlYU1hcmdpbnMsXG4gIGlkOiBpZEZyb21Qcm9wcyxcbiAgb25EcmFnZ2luZyxcbiAgc3R5bGU6IHN0eWxlRnJvbVByb3BzID0ge30sXG4gIHRhYkluZGV4ID0gMCxcbiAgdGFnTmFtZTogVHlwZSA9IFwiZGl2XCIsXG4gIC4uLnJlc3Rcbn0pIHtcbiAgY29uc3QgZWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcblxuICAvLyBVc2UgYSByZWYgdG8gZ3VhcmQgYWdhaW5zdCB1c2VycyBwYXNzaW5nIGlubGluZSBwcm9wc1xuICBjb25zdCBjYWxsYmFja3NSZWYgPSB1c2VSZWYoe1xuICAgIG9uRHJhZ2dpbmdcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY2FsbGJhY2tzUmVmLmN1cnJlbnQub25EcmFnZ2luZyA9IG9uRHJhZ2dpbmc7XG4gIH0pO1xuICBjb25zdCBwYW5lbEdyb3VwQ29udGV4dCA9IHVzZUNvbnRleHQoUGFuZWxHcm91cENvbnRleHQpO1xuICBpZiAocGFuZWxHcm91cENvbnRleHQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFuZWxSZXNpemVIYW5kbGUgY29tcG9uZW50cyBtdXN0IGJlIHJlbmRlcmVkIHdpdGhpbiBhIFBhbmVsR3JvdXAgY29udGFpbmVyYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIGRpcmVjdGlvbixcbiAgICBncm91cElkLFxuICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlOiByZWdpc3RlclJlc2l6ZUhhbmRsZVdpdGhQYXJlbnRHcm91cCxcbiAgICBzdGFydERyYWdnaW5nLFxuICAgIHN0b3BEcmFnZ2luZyxcbiAgICBwYW5lbEdyb3VwRWxlbWVudFxuICB9ID0gcGFuZWxHcm91cENvbnRleHQ7XG4gIGNvbnN0IHJlc2l6ZUhhbmRsZUlkID0gdXNlVW5pcXVlSWQoaWRGcm9tUHJvcHMpO1xuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKFwiaW5hY3RpdmVcIik7XG4gIGNvbnN0IFtpc0ZvY3VzZWQsIHNldElzRm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtyZXNpemVIYW5kbGVyLCBzZXRSZXNpemVIYW5kbGVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBjb21taXR0ZWRWYWx1ZXNSZWYgPSB1c2VSZWYoe1xuICAgIHN0YXRlXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgc2V0UmVzaXplSGFuZGxlcihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVzaXplSGFuZGxlciA9IHJlZ2lzdGVyUmVzaXplSGFuZGxlV2l0aFBhcmVudEdyb3VwKHJlc2l6ZUhhbmRsZUlkKTtcbiAgICAgIHNldFJlc2l6ZUhhbmRsZXIoKCkgPT4gcmVzaXplSGFuZGxlcik7XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIHJlc2l6ZUhhbmRsZUlkLCByZWdpc3RlclJlc2l6ZUhhbmRsZVdpdGhQYXJlbnRHcm91cF0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBfaGl0QXJlYU1hcmdpbnMkY29hcnMsIF9oaXRBcmVhTWFyZ2lucyRmaW5lO1xuICAgIGlmIChkaXNhYmxlZCB8fCByZXNpemVIYW5kbGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRSZWYuY3VycmVudDtcbiAgICBhc3NlcnQoZWxlbWVudCwgXCJFbGVtZW50IHJlZiBub3QgYXR0YWNoZWRcIik7XG4gICAgY29uc3Qgc2V0UmVzaXplSGFuZGxlclN0YXRlID0gKGFjdGlvbiwgaXNBY3RpdmUsIGV2ZW50KSA9PiB7XG4gICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZXRTdGF0ZShcImRyYWdcIik7XG4gICAgICAgICAgICAgIHN0YXJ0RHJhZ2dpbmcocmVzaXplSGFuZGxlSWQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgICAgICAgICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm1vdmVcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHN0YXRlXG4gICAgICAgICAgICAgIH0gPSBjb21taXR0ZWRWYWx1ZXNSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlICE9PSBcImRyYWdcIikge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlKFwiaG92ZXJcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzaXplSGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBzZXRTdGF0ZShcImhvdmVyXCIpO1xuICAgICAgICAgICAgICBzdG9wRHJhZ2dpbmcoKTtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmdcbiAgICAgICAgICAgICAgfSA9IGNhbGxiYWNrc1JlZi5jdXJyZW50O1xuICAgICAgICAgICAgICBpZiAob25EcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIG9uRHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRTdGF0ZShcImluYWN0aXZlXCIpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJlZ2lzdGVyUmVzaXplSGFuZGxlKHJlc2l6ZUhhbmRsZUlkLCBlbGVtZW50LCBkaXJlY3Rpb24sIHtcbiAgICAgIC8vIENvYXJzZSBpbnB1dHMgKGUuZy4gZmluZ2VyL3RvdWNoKVxuICAgICAgY29hcnNlOiAoX2hpdEFyZWFNYXJnaW5zJGNvYXJzID0gaGl0QXJlYU1hcmdpbnMgPT09IG51bGwgfHwgaGl0QXJlYU1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhpdEFyZWFNYXJnaW5zLmNvYXJzZSkgIT09IG51bGwgJiYgX2hpdEFyZWFNYXJnaW5zJGNvYXJzICE9PSB2b2lkIDAgPyBfaGl0QXJlYU1hcmdpbnMkY29hcnMgOiAxNSxcbiAgICAgIC8vIEZpbmUgaW5wdXRzIChlLmcuIG1vdXNlKVxuICAgICAgZmluZTogKF9oaXRBcmVhTWFyZ2lucyRmaW5lID0gaGl0QXJlYU1hcmdpbnMgPT09IG51bGwgfHwgaGl0QXJlYU1hcmdpbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhpdEFyZWFNYXJnaW5zLmZpbmUpICE9PSBudWxsICYmIF9oaXRBcmVhTWFyZ2lucyRmaW5lICE9PSB2b2lkIDAgPyBfaGl0QXJlYU1hcmdpbnMkZmluZSA6IDVcbiAgICB9LCBzZXRSZXNpemVIYW5kbGVyU3RhdGUpO1xuICB9LCBbZGlyZWN0aW9uLCBkaXNhYmxlZCwgaGl0QXJlYU1hcmdpbnMsIHJlZ2lzdGVyUmVzaXplSGFuZGxlV2l0aFBhcmVudEdyb3VwLCByZXNpemVIYW5kbGVJZCwgcmVzaXplSGFuZGxlciwgc3RhcnREcmFnZ2luZywgc3RvcERyYWdnaW5nXSk7XG4gIHVzZVdpbmRvd1NwbGl0dGVyUmVzaXplSGFuZGxlckJlaGF2aW9yKHtcbiAgICBkaXNhYmxlZCxcbiAgICBoYW5kbGVJZDogcmVzaXplSGFuZGxlSWQsXG4gICAgcmVzaXplSGFuZGxlcixcbiAgICBwYW5lbEdyb3VwRWxlbWVudFxuICB9KTtcbiAgY29uc3Qgc3R5bGUgPSB7XG4gICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gIH07XG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFR5cGUsIHtcbiAgICAuLi5yZXN0LFxuICAgIGNoaWxkcmVuLFxuICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lRnJvbVByb3BzLFxuICAgIGlkOiBpZEZyb21Qcm9wcyxcbiAgICBvbkJsdXI6ICgpID0+IHNldElzRm9jdXNlZChmYWxzZSksXG4gICAgb25Gb2N1czogKCkgPT4gc2V0SXNGb2N1c2VkKHRydWUpLFxuICAgIHJlZjogZWxlbWVudFJlZixcbiAgICByb2xlOiBcInNlcGFyYXRvclwiLFxuICAgIHN0eWxlOiB7XG4gICAgICAuLi5zdHlsZSxcbiAgICAgIC4uLnN0eWxlRnJvbVByb3BzXG4gICAgfSxcbiAgICB0YWJJbmRleCxcbiAgICAvLyBDU1Mgc2VsZWN0b3JzXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWRpcmVjdGlvblwiOiBkaXJlY3Rpb24sXG4gICAgXCJkYXRhLXBhbmVsLWdyb3VwLWlkXCI6IGdyb3VwSWQsXG4gICAgXCJkYXRhLXJlc2l6ZS1oYW5kbGVcIjogXCJcIixcbiAgICBcImRhdGEtcmVzaXplLWhhbmRsZS1hY3RpdmVcIjogc3RhdGUgPT09IFwiZHJhZ1wiID8gXCJwb2ludGVyXCIgOiBpc0ZvY3VzZWQgPyBcImtleWJvYXJkXCIgOiB1bmRlZmluZWQsXG4gICAgXCJkYXRhLXJlc2l6ZS1oYW5kbGUtc3RhdGVcIjogc3RhdGUsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtZW5hYmxlZFwiOiAhZGlzYWJsZWQsXG4gICAgXCJkYXRhLXBhbmVsLXJlc2l6ZS1oYW5kbGUtaWRcIjogcmVzaXplSGFuZGxlSWRcbiAgfSk7XG59XG5QYW5lbFJlc2l6ZUhhbmRsZS5kaXNwbGF5TmFtZSA9IFwiUGFuZWxSZXNpemVIYW5kbGVcIjtcblxuZnVuY3Rpb24gZ2V0UGFuZWxFbGVtZW50KGlkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBzY29wZS5xdWVyeVNlbGVjdG9yKGBbZGF0YS1wYW5lbC1pZD1cIiR7aWR9XCJdYCk7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFBhbmVsRWxlbWVudHNGb3JHcm91cChncm91cElkLCBzY29wZSA9IGRvY3VtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHNjb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoYFtkYXRhLXBhbmVsXVtkYXRhLXBhbmVsLWdyb3VwLWlkPVwiJHtncm91cElkfVwiXWApKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW5nUmVjdGFuZ2xlKHJlY3RPbmUsIHJlY3RUd28sIHN0cmljdCkge1xuICBpZiAoIWludGVyc2VjdHMocmVjdE9uZSwgcmVjdFR3bywgc3RyaWN0KSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IE1hdGgubWF4KHJlY3RPbmUueCwgcmVjdFR3by54KSxcbiAgICB5OiBNYXRoLm1heChyZWN0T25lLnksIHJlY3RUd28ueSksXG4gICAgd2lkdGg6IE1hdGgubWluKHJlY3RPbmUueCArIHJlY3RPbmUud2lkdGgsIHJlY3RUd28ueCArIHJlY3RUd28ud2lkdGgpIC0gTWF0aC5tYXgocmVjdE9uZS54LCByZWN0VHdvLngpLFxuICAgIGhlaWdodDogTWF0aC5taW4ocmVjdE9uZS55ICsgcmVjdE9uZS5oZWlnaHQsIHJlY3RUd28ueSArIHJlY3RUd28uaGVpZ2h0KSAtIE1hdGgubWF4KHJlY3RPbmUueSwgcmVjdFR3by55KVxuICB9O1xufVxuXG5leHBvcnQgeyBQYW5lbCwgUGFuZWxHcm91cCwgUGFuZWxSZXNpemVIYW5kbGUsIGFzc2VydCwgZ2V0SW50ZXJzZWN0aW5nUmVjdGFuZ2xlLCBnZXRQYW5lbEVsZW1lbnQsIGdldFBhbmVsRWxlbWVudHNGb3JHcm91cCwgZ2V0UGFuZWxHcm91cEVsZW1lbnQsIGdldFJlc2l6ZUhhbmRsZUVsZW1lbnQsIGdldFJlc2l6ZUhhbmRsZUVsZW1lbnRJbmRleCwgZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cCwgZ2V0UmVzaXplSGFuZGxlUGFuZWxJZHMsIGludGVyc2VjdHMgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUVsZW1lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUmVmIiwiZm9yd2FyZFJlZiIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsInVzZUVmZmVjdCIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VJZCIsInRvU3RyaW5nIiwiUGFuZWxHcm91cENvbnRleHQiLCJkaXNwbGF5TmFtZSIsIndyYXBwZWRVc2VJZCIsImNvdW50ZXIiLCJ1c2VVbmlxdWVJZCIsImlkRnJvbVBhcmFtcyIsImlkRnJvbVVzZUlkIiwiaWRSZWYiLCJjdXJyZW50IiwiUGFuZWxXaXRoRm9yd2FyZGVkUmVmIiwiY2hpbGRyZW4iLCJjbGFzc05hbWUiLCJjbGFzc05hbWVGcm9tUHJvcHMiLCJjb2xsYXBzZWRTaXplIiwiY29sbGFwc2libGUiLCJkZWZhdWx0U2l6ZSIsImZvcndhcmRlZFJlZiIsImlkIiwiaWRGcm9tUHJvcHMiLCJtYXhTaXplIiwibWluU2l6ZSIsIm9uQ29sbGFwc2UiLCJvbkV4cGFuZCIsIm9uUmVzaXplIiwib3JkZXIiLCJzdHlsZSIsInN0eWxlRnJvbVByb3BzIiwidGFnTmFtZSIsIlR5cGUiLCJyZXN0IiwiY29udGV4dCIsIkVycm9yIiwiY29sbGFwc2VQYW5lbCIsImV4cGFuZFBhbmVsIiwiZ2V0UGFuZWxTaXplIiwiZ2V0UGFuZWxTdHlsZSIsImdyb3VwSWQiLCJpc1BhbmVsQ29sbGFwc2VkIiwicmVldmFsdWF0ZVBhbmVsQ29uc3RyYWludHMiLCJyZWdpc3RlclBhbmVsIiwicmVzaXplUGFuZWwiLCJ1bnJlZ2lzdGVyUGFuZWwiLCJwYW5lbElkIiwicGFuZWxEYXRhUmVmIiwiY2FsbGJhY2tzIiwiY29uc3RyYWludHMiLCJpZElzRnJvbVByb3BzIiwidW5kZWZpbmVkIiwiZGV2V2FybmluZ3NSZWYiLCJkaWRMb2dNaXNzaW5nRGVmYXVsdFNpemVXYXJuaW5nIiwiY29uc29sZSIsIndhcm4iLCJjb2xsYXBzZSIsImV4cGFuZCIsImdldElkIiwiZ2V0U2l6ZSIsImlzQ29sbGFwc2VkIiwiaXNFeHBhbmRlZCIsInJlc2l6ZSIsInNpemUiLCJwYXJzZUZsb2F0IiwiZmxleEdyb3ciLCJ0b0ZpeGVkIiwiUGFuZWwiLCJwcm9wcyIsInJlZiIsImN1cnJlbnRDdXJzb3JTdHlsZSIsInN0eWxlRWxlbWVudCIsImdldEN1cnNvclN0eWxlIiwic3RhdGUiLCJjb25zdHJhaW50RmxhZ3MiLCJob3Jpem9udGFsTWluIiwiRVhDRUVERURfSE9SSVpPTlRBTF9NSU4iLCJob3Jpem9udGFsTWF4IiwiRVhDRUVERURfSE9SSVpPTlRBTF9NQVgiLCJ2ZXJ0aWNhbE1pbiIsIkVYQ0VFREVEX1ZFUlRJQ0FMX01JTiIsInZlcnRpY2FsTWF4IiwiRVhDRUVERURfVkVSVElDQUxfTUFYIiwicmVzZXRHbG9iYWxDdXJzb3JTdHlsZSIsImRvY3VtZW50IiwiaGVhZCIsInJlbW92ZUNoaWxkIiwic2V0R2xvYmFsQ3Vyc29yU3R5bGUiLCJhcHBlbmRDaGlsZCIsImlubmVySFRNTCIsImlzS2V5RG93biIsImV2ZW50IiwidHlwZSIsImlzTW91c2VFdmVudCIsInN0YXJ0c1dpdGgiLCJpc1RvdWNoRXZlbnQiLCJnZXRSZXNpemVFdmVudENvb3JkaW5hdGVzIiwieCIsImNsaWVudFgiLCJ5IiwiY2xpZW50WSIsInRvdWNoIiwidG91Y2hlcyIsIkluZmluaXR5IiwiZ2V0SW5wdXRUeXBlIiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJpbnRlcnNlY3RzIiwicmVjdE9uZSIsInJlY3RUd28iLCJzdHJpY3QiLCJ3aWR0aCIsImhlaWdodCIsImNvbXBhcmUiLCJhIiwiYiIsImFuY2VzdG9ycyIsImdldF9hbmNlc3RvcnMiLCJjb21tb25fYW5jZXN0b3IiLCJhdCIsInBvcCIsImFzc2VydCIsInpfaW5kZXhlcyIsImdldF96X2luZGV4IiwiZmluZF9zdGFja2luZ19jb250ZXh0IiwiY2hpbGROb2RlcyIsImZ1cnRoZXN0X2FuY2VzdG9ycyIsImkiLCJsZW5ndGgiLCJjaGlsZCIsIk1hdGgiLCJzaWduIiwiaXNfZmxleF9pdGVtIiwibm9kZSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0X3BhcmVudCIsImNyZWF0ZXNfc3RhY2tpbmdfY29udGV4dCIsInBvc2l0aW9uIiwiekluZGV4Iiwib3BhY2l0eSIsInRyYW5zZm9ybSIsIndlYmtpdFRyYW5zZm9ybSIsIm1peEJsZW5kTW9kZSIsImZpbHRlciIsIndlYmtpdEZpbHRlciIsImlzb2xhdGlvbiIsInRlc3QiLCJ3aWxsQ2hhbmdlIiwid2Via2l0T3ZlcmZsb3dTY3JvbGxpbmciLCJub2RlcyIsIk51bWJlciIsInB1c2giLCJfbm9kZSRwYXJlbnROb2RlIiwicGFyZW50Tm9kZSIsImhvc3QiLCJpc0NvYXJzZVBvaW50ZXIiLCJpbnRlcnNlY3RpbmdIYW5kbGVzIiwiaXNQb2ludGVyRG93biIsIm93bmVyRG9jdW1lbnRDb3VudHMiLCJNYXAiLCJwYW5lbENvbnN0cmFpbnRGbGFncyIsInJlZ2lzdGVyZWRSZXNpemVIYW5kbGVycyIsIlNldCIsInJlZ2lzdGVyUmVzaXplSGFuZGxlIiwicmVzaXplSGFuZGxlSWQiLCJlbGVtZW50IiwiZGlyZWN0aW9uIiwiaGl0QXJlYU1hcmdpbnMiLCJzZXRSZXNpemVIYW5kbGVyU3RhdGUiLCJfb3duZXJEb2N1bWVudENvdW50cyQiLCJvd25lckRvY3VtZW50IiwiZGF0YSIsImNvdW50IiwiZ2V0Iiwic2V0IiwiYWRkIiwidXBkYXRlTGlzdGVuZXJzIiwidW5yZWdpc3RlclJlc2l6ZUhhbmRsZSIsIl9vd25lckRvY3VtZW50Q291bnRzJDIiLCJkZWxldGUiLCJoYW5kbGVQb2ludGVyRG93biIsInRhcmdldCIsInJlY2FsY3VsYXRlSW50ZXJzZWN0aW5nSGFuZGxlcyIsInVwZGF0ZVJlc2l6ZUhhbmRsZXJTdGF0ZXMiLCJwcmV2ZW50RGVmYXVsdCIsImhhbmRsZVBvaW50ZXJNb3ZlIiwidXBkYXRlQ3Vyc29yIiwiaGFuZGxlUG9pbnRlclVwIiwiY2xlYXIiLCJzcGxpY2UiLCJ0YXJnZXRFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJmb3JFYWNoIiwiZHJhZ0hhbmRsZUVsZW1lbnQiLCJkcmFnSGFuZGxlUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsInRvcCIsIm1hcmdpbiIsImNvYXJzZSIsImZpbmUiLCJldmVudEludGVyc2VjdHMiLCJjb250YWlucyIsImN1cnJlbnRFbGVtZW50IiwiZGlkSW50ZXJzZWN0IiwicGFyZW50RWxlbWVudCIsInJlcG9ydENvbnN0cmFpbnRzVmlvbGF0aW9uIiwiZmxhZyIsImludGVyc2VjdHNIb3Jpem9udGFsIiwiaW50ZXJzZWN0c1ZlcnRpY2FsIiwiXyIsImJvZHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJhY3Rpb24iLCJpc0FjdGl2ZSIsImluY2x1ZGVzIiwiZXhwZWN0ZWRDb25kaXRpb24iLCJtZXNzYWdlIiwiZXJyb3IiLCJQUkVDSVNJT04iLCJmdXp6eUNvbXBhcmVOdW1iZXJzIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJmcmFjdGlvbkRpZ2l0cyIsImRlbHRhIiwiZnV6enlOdW1iZXJzRXF1YWwiLCJmdXp6eUxheW91dHNFcXVhbCIsImluZGV4IiwiYWN0dWFsU2l6ZSIsImV4cGVjdGVkU2l6ZSIsInBhbmVsQ29uc3RyYWludHMiLCJwYW5lbENvbnN0cmFpbnRzQXJyYXkiLCJwYW5lbEluZGV4IiwiaGFsZndheVBvaW50IiwibWluIiwiYWRqdXN0TGF5b3V0QnlEZWx0YSIsImluaXRpYWxMYXlvdXQiLCJwaXZvdEluZGljZXMiLCJwcmV2TGF5b3V0IiwidHJpZ2dlciIsIm5leHRMYXlvdXQiLCJmaXJzdFBpdm90SW5kZXgiLCJzZWNvbmRQaXZvdEluZGV4IiwiZGVsdGFBcHBsaWVkIiwicHJldlNpemUiLCJsb2NhbERlbHRhIiwiYWJzIiwiaW5jcmVtZW50IiwibWF4QXZhaWxhYmxlRGVsdGEiLCJtYXhTYWZlU2l6ZSIsIm1pbkFic0RlbHRhIiwicGl2b3RJbmRleCIsImRlbHRhUmVtYWluaW5nIiwidW5zYWZlU2l6ZSIsInNhZmVTaXplIiwidG9QcmVjaXNpb24iLCJsb2NhbGVDb21wYXJlIiwibnVtZXJpYyIsInRvdGFsU2l6ZSIsInJlZHVjZSIsInRvdGFsIiwiZ2V0UmVzaXplSGFuZGxlRWxlbWVudHNGb3JHcm91cCIsInNjb3BlIiwiQXJyYXkiLCJmcm9tIiwicXVlcnlTZWxlY3RvckFsbCIsImdldFJlc2l6ZUhhbmRsZUVsZW1lbnRJbmRleCIsImhhbmRsZXMiLCJmaW5kSW5kZXgiLCJoYW5kbGUiLCJnZXRBdHRyaWJ1dGUiLCJkZXRlcm1pbmVQaXZvdEluZGljZXMiLCJkcmFnSGFuZGxlSWQiLCJwYW5lbEdyb3VwRWxlbWVudCIsImdldFBhbmVsR3JvdXBFbGVtZW50Iiwicm9vdEVsZW1lbnQiLCJfZGF0YXNldCIsImRhdGFzZXQiLCJwYW5lbEdyb3VwSWQiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0UmVzaXplSGFuZGxlRWxlbWVudCIsImdldFJlc2l6ZUhhbmRsZVBhbmVsSWRzIiwiaGFuZGxlSWQiLCJwYW5lbHNBcnJheSIsIl9wYW5lbHNBcnJheSRpbmRleCRpZCIsIl9wYW5lbHNBcnJheSRpbmRleCIsIl9wYW5lbHNBcnJheSRpZCIsIl9wYW5lbHNBcnJheSIsImluZGV4T2YiLCJpZEJlZm9yZSIsImlkQWZ0ZXIiLCJ1c2VXaW5kb3dTcGxpdHRlclBhbmVsR3JvdXBCZWhhdmlvciIsImNvbW1pdHRlZFZhbHVlc1JlZiIsImVhZ2VyVmFsdWVzUmVmIiwibGF5b3V0IiwicGFuZWxEYXRhQXJyYXkiLCJzZXRMYXlvdXQiLCJkaWRXYXJuQWJvdXRNaXNzaW5nUmVzaXplSGFuZGxlIiwiZWFnZXJWYWx1ZXMiLCJncm91cEVsZW1lbnQiLCJjbGVhbnVwRnVuY3Rpb25zIiwibWFwIiwib25LZXlEb3duIiwiZGVmYXVsdFByZXZlbnRlZCIsImtleSIsInBhbmVsRGF0YSIsImNsZWFudXBGdW5jdGlvbiIsImFyZUVxdWFsIiwiYXJyYXlBIiwiYXJyYXlCIiwiZ2V0UmVzaXplRXZlbnRDdXJzb3JQb3NpdGlvbiIsImlzSG9yaXpvbnRhbCIsImNhbGN1bGF0ZURyYWdPZmZzZXRQZXJjZW50YWdlIiwiaW5pdGlhbERyYWdTdGF0ZSIsImhhbmRsZUVsZW1lbnQiLCJpbml0aWFsQ3Vyc29yUG9zaXRpb24iLCJjdXJzb3JQb3NpdGlvbiIsImdyb3VwUmVjdCIsImdyb3VwU2l6ZUluUGl4ZWxzIiwib2Zmc2V0UGl4ZWxzIiwib2Zmc2V0UGVyY2VudGFnZSIsImNhbGN1bGF0ZURlbHRhUGVyY2VudGFnZSIsImtleWJvYXJkUmVzaXplQnkiLCJzaGlmdEtleSIsIm1vdmVtZW50IiwiY2FsbFBhbmVsQ2FsbGJhY2tzIiwicGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcCIsImxhc3ROb3RpZmllZFNpemUiLCJjb21wYXJlTGF5b3V0cyIsImNvbXB1dGVQYW5lbEZsZXhCb3hTdHlsZSIsImRyYWdTdGF0ZSIsInByZWNpc2lvbiIsImZsZXhCYXNpcyIsImZsZXhTaHJpbmsiLCJvdmVyZmxvdyIsInBvaW50ZXJFdmVudHMiLCJkZWJvdW5jZSIsImNhbGxiYWNrIiwiZHVyYXRpb25NcyIsInRpbWVvdXRJZCIsImNhbGxhYmxlIiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJpbml0aWFsaXplRGVmYXVsdFN0b3JhZ2UiLCJzdG9yYWdlT2JqZWN0IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm5hbWUiLCJzZXRJdGVtIiwidmFsdWUiLCJnZXRQYW5lbEdyb3VwS2V5IiwiYXV0b1NhdmVJZCIsImdldFBhbmVsS2V5IiwicGFuZWxzIiwicGFuZWwiLCJKU09OIiwic3RyaW5naWZ5Iiwic29ydCIsImpvaW4iLCJsb2FkU2VyaWFsaXplZFBhbmVsR3JvdXBTdGF0ZSIsInN0b3JhZ2UiLCJwYW5lbEdyb3VwS2V5Iiwic2VyaWFsaXplZCIsInBhcnNlZCIsInBhcnNlIiwic2F2ZVBhbmVsR3JvdXBTdGF0ZSIsInBhbmVsU2l6ZXNCZWZvcmVDb2xsYXBzZSIsInNpemVzIiwiX2xvYWRTZXJpYWxpemVkUGFuZWxHMiIsInBhbmVsS2V5IiwiZXhwYW5kVG9TaXplcyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsInZhbGlkYXRlUGFuZWxDb25zdHJhaW50cyIsIndhcm5pbmdzIiwidmFsaWRhdGVQYW5lbEdyb3VwTGF5b3V0IiwibmV4dExheW91dFRvdGFsU2l6ZSIsImFjY3VtdWxhdGVkIiwicmVtYWluaW5nU2l6ZSIsIkxPQ0FMX1NUT1JBR0VfREVCT1VOQ0VfSU5URVJWQUwiLCJkZWZhdWx0U3RvcmFnZSIsImRlYm91bmNlTWFwIiwiUGFuZWxHcm91cFdpdGhGb3J3YXJkZWRSZWYiLCJvbkxheW91dCIsInBhbmVsR3JvdXBFbGVtZW50UmVmIiwic2V0RHJhZ1N0YXRlIiwicGFuZWxJZFRvTGFzdE5vdGlmaWVkU2l6ZU1hcFJlZiIsInBhbmVsU2l6ZUJlZm9yZUNvbGxhcHNlUmVmIiwicHJldkRlbHRhUmVmIiwicGFuZWxEYXRhQXJyYXlDaGFuZ2VkIiwiZGlkTG9nSWRBbmRPcmRlcldhcm5pbmciLCJkaWRMb2dQYW5lbENvbnN0cmFpbnRzV2FybmluZyIsInByZXZQYW5lbElkcyIsImdldExheW91dCIsInVuc2FmZUxheW91dCIsInNhZmVMYXlvdXQiLCJkZWJvdW5jZWRTYXZlIiwiY2xvbmVkUGFuZWxEYXRhQXJyYXkiLCJjbG9uZWRQYW5lbFNpemVzQmVmb3JlQ29sbGFwc2UiLCJwYW5lbElkcyIsInBhbmVsc0hhdmVDaGFuZ2VkIiwiZmluZCIsImlzVmFsaWQiLCJwYW5lbFNpemUiLCJwYW5lbERhdGFIZWxwZXIiLCJpc0xhc3RQYW5lbCIsImZpbmRQYW5lbERhdGFJbmRleCIsInByZXZQYW5lbFNpemUiLCJiYXNlU2l6ZSIsImlzUGFuZWxFeHBhbmRlZCIsInBhbmVsQSIsInBhbmVsQiIsIm9yZGVyQSIsIm9yZGVyQiIsInJlc2l6ZUhhbmRsZXIiLCJkaXIiLCJsYXlvdXRDaGFuZ2VkIiwidW5zYWZlUGFuZWxTaXplIiwicHJldkNvbnN0cmFpbnRzIiwicHJldkNvbGxhcHNlZFNpemUiLCJwcmV2Q29sbGFwc2libGUiLCJuZXh0Q29sbGFwc2VkU2l6ZSIsIm5leHRDb2xsYXBzaWJsZSIsIm5leHRNYXhTaXplIiwibmV4dE1pblNpemUiLCJzdGFydERyYWdnaW5nIiwic3RvcERyYWdnaW5nIiwiZmxleERpcmVjdGlvbiIsIlByb3ZpZGVyIiwiUGFuZWxHcm91cCIsInByZXZQYW5lbERhdGEiLCJ1c2VXaW5kb3dTcGxpdHRlclJlc2l6ZUhhbmRsZXJCZWhhdmlvciIsImRpc2FibGVkIiwibmV4dEluZGV4IiwibmV4dEhhbmRsZSIsImZvY3VzIiwiUGFuZWxSZXNpemVIYW5kbGUiLCJvbkRyYWdnaW5nIiwidGFiSW5kZXgiLCJlbGVtZW50UmVmIiwiY2FsbGJhY2tzUmVmIiwicGFuZWxHcm91cENvbnRleHQiLCJyZWdpc3RlclJlc2l6ZUhhbmRsZVdpdGhQYXJlbnRHcm91cCIsInNldFN0YXRlIiwiaXNGb2N1c2VkIiwic2V0SXNGb2N1c2VkIiwic2V0UmVzaXplSGFuZGxlciIsIl9oaXRBcmVhTWFyZ2lucyRjb2FycyIsIl9oaXRBcmVhTWFyZ2lucyRmaW5lIiwidG91Y2hBY3Rpb24iLCJ1c2VyU2VsZWN0Iiwib25CbHVyIiwib25Gb2N1cyIsInJvbGUiLCJnZXRQYW5lbEVsZW1lbnQiLCJnZXRQYW5lbEVsZW1lbnRzRm9yR3JvdXAiLCJnZXRJbnRlcnNlY3RpbmdSZWN0YW5nbGUiLCJtYXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-resizable-panels/dist/react-resizable-panels.development.node.esm.js\n");

/***/ })

};
;